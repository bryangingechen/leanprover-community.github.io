---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/90385Typeclassesagain.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html">Type classes again</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="167264211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167264211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167264211">Sebastien Gouezel (Jun 04 2019 at 07:08)</a>:</h4>
<p>Trying to fix the <code>normed_space</code> issue, I ran into a weird behavior of typeclass resolution. The definition is now</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">normed_space</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">[</span><span class="n">normed_field</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">normed_group</span> <span class="n">β</span><span class="o">]</span>
  <span class="kn">extends</span> <span class="n">vector_space</span> <span class="n">α</span> <span class="n">β</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">norm_smul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">a</span><span class="o">:</span><span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span><span class="n">β</span><span class="o">),</span> <span class="n">norm</span> <span class="o">(</span><span class="n">a</span> <span class="err">•</span> <span class="n">b</span><span class="o">)</span> <span class="bp">=</span> <span class="n">has_norm</span><span class="bp">.</span><span class="n">norm</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">norm</span> <span class="n">b</span><span class="o">)</span>
</pre></div>


<p>Then, to define a normed space structure on the space of continuous linear maps between two normed spaces, I write</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">to_normed_group</span> <span class="o">:</span> <span class="n">normed_group</span> <span class="o">(</span><span class="n">E</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">normed_group</span><span class="bp">.</span><span class="n">of_core</span> <span class="bp">_</span> <span class="bp">⟨</span><span class="n">op_norm_zero_iff</span><span class="o">,</span> <span class="n">op_norm_triangle</span><span class="o">,</span> <span class="n">op_norm_neg</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="n">to_normed_space</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="n">k</span> <span class="o">(</span><span class="n">E</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">op_norm_smul</span><span class="bp">⟩</span>
</pre></div>


<p>The surprising behavior is that Lean can not infer the normed group structure on <code>E →L[k] (F × G)</code>.</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">to_normed_group_prod</span> <span class="o">:</span> <span class="n">normed_group</span> <span class="o">(</span><span class="n">E</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">(</span><span class="n">F</span> <span class="bp">×</span> <span class="n">G</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">continuous_linear_map</span><span class="bp">.</span><span class="n">to_normed_group</span>
</pre></div>


<p>works, but using <code>by apply_instance</code> instead of <code>continuous_linear_map.to_normed_group</code> fails. I can register this instance by hand as I just did, and then everything works fine, but I am afraid this shows there is something wrong with my definitions.</p>

<a name="167266754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167266754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167266754">Sebastien Gouezel (Jun 04 2019 at 07:47)</a>:</h4>
<p>If I try with <code>apply_instance</code>, the context is</p>
<div class="codehilite"><pre><span></span><span class="mi">1</span> <span class="n">goal</span>
<span class="n">k</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_1</span><span class="o">,</span>
<span class="n">E</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_2</span><span class="o">,</span>
<span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_3</span><span class="o">,</span>
<span class="n">G</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u_4</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_1</span> <span class="o">:</span> <span class="n">nondiscrete_normed_field</span> <span class="n">k</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_2</span> <span class="o">:</span> <span class="n">normed_group</span> <span class="n">E</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_3</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="n">k</span> <span class="n">E</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_4</span> <span class="o">:</span> <span class="n">normed_group</span> <span class="n">F</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_5</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="n">k</span> <span class="n">F</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_6</span> <span class="o">:</span> <span class="n">normed_group</span> <span class="n">G</span><span class="o">,</span>
<span class="bp">_</span><span class="n">inst_7</span> <span class="o">:</span> <span class="n">normed_space</span> <span class="n">k</span> <span class="n">G</span>
<span class="err">⊢</span> <span class="n">normed_group</span> <span class="o">(</span><span class="n">E</span> <span class="bp">→</span><span class="n">L</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="n">F</span> <span class="bp">×</span> <span class="n">G</span><span class="o">)</span>
</pre></div>


<p>and in the instance search trace I find the line</p>
<div class="codehilite"><pre><span></span><span class="o">[</span><span class="n">class_instances</span><span class="o">]</span> <span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="err">?</span><span class="n">x_36</span> <span class="o">:</span> <span class="bp">@</span><span class="n">normed_space</span> <span class="n">k</span> <span class="n">G</span> <span class="o">(</span><span class="bp">@</span><span class="n">nondiscrete_normed_field</span><span class="bp">.</span><span class="n">to_normed_field</span> <span class="n">k</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span> <span class="bp">_</span><span class="n">inst_6</span> <span class="o">:=</span> <span class="bp">_</span><span class="n">inst_7</span>
<span class="n">failed</span> <span class="n">is_def_eq</span>
</pre></div>


<p>I don't understand what is going on...</p>

<a name="167267018"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267018" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267018">Sebastien Gouezel (Jun 04 2019 at 07:50)</a>:</h4>
<p>Crap, universe issues: if I put all of them in <code>Type</code>, everything works...</p>

<a name="167267097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267097">Kevin Buzzard (Jun 04 2019 at 07:51)</a>:</h4>
<p>Try changing <code>Type*</code> to <code>Type u</code> in some places, if you want to remain polymorphic. That sometimes changes things.</p>

<a name="167267161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267161">Kevin Buzzard (Jun 04 2019 at 07:52)</a>:</h4>
<p>I have no proper understanding of why this helps, but apparently it changes elaboration. This might be an unrelated issue though of course.</p>

<a name="167267169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267169">Sebastien Gouezel (Jun 04 2019 at 07:52)</a>:</h4>
<p>I just tried this, but the problem remains.</p>

<a name="167267182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267182">Kevin Buzzard (Jun 04 2019 at 07:52)</a>:</h4>
<p>Well spotted though; universe problems are hard to debug.</p>

<a name="167267322"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267322" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267322">Kevin Buzzard (Jun 04 2019 at 07:54)</a>:</h4>
<p>I have in the past suggested that mathematicians would be better off working in only one universe -- after all, that's how mathematics of this nature actually works in practice. Since when did any mathematician ever want to consider two normed fields in two different universes? Universes are for people wrestling with categories in a serious way, not for people doing "normal" mathematics like this.</p>

<a name="167267337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267337">Kevin Buzzard (Jun 04 2019 at 07:54)</a>:</h4>
<p>I don't necessarily mean <code>Type</code>, but I'm suggesting <code>Type u</code> for everything.</p>

<a name="167267389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267389">Kevin Buzzard (Jun 04 2019 at 07:55)</a>:</h4>
<p>The CS guys like this "maximally universe polymorphic" approach but I have never seen a benefit when doing this kind of mathematics. Are these issues present in Isabelle/HOL?</p>

<a name="167267486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267486">Kevin Buzzard (Jun 04 2019 at 07:56)</a>:</h4>
<p>If Lean struggles with them, and we don't actually need them, then this is an argument for just using one universe.</p>

<a name="167267530"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267530" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267530">Kevin Buzzard (Jun 04 2019 at 07:57)</a>:</h4>
<p>What is done in Coq? Does anyone know?</p>

<a name="167267840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167267840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167267840">Sebastien Gouezel (Jun 04 2019 at 08:01)</a>:</h4>
<p>I agree with this (almost: I would be ready to have the field <code>k</code> in some universe -- think of the real numbers, they are in <code>Type</code> -- and the vector spaces in another one -- but in my example it doesn't work, they really all need to be in the same universe). I haven't seen any benefit of universe polymorphism either, and these issues don't exist in Isabelle. We really need the CS guys either to make it better, or to grant us the right to use only one universe :)</p>

<a name="167268035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268035">Johan Commelin (Jun 04 2019 at 08:03)</a>:</h4>
<p>Linear equivalences between vector spaces are currently not universe polymorphic... so it's not like you can't have non-universe polymorphic stuff in mathlib. It works like a virus though</p>

<a name="167268157"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268157" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268157">Johan Commelin (Jun 04 2019 at 08:04)</a>:</h4>
<p>I fear that the <code>ℚ_[ℓ]</code>-vector space that rolls out of étale cohomology will not live in <code>Type</code>.</p>

<a name="167268180"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268180" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268180">Johan Commelin (Jun 04 2019 at 08:04)</a>:</h4>
<p>I would still like to be able to apply general theorems to it.</p>

<a name="167268241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268241">Johan Commelin (Jun 04 2019 at 08:05)</a>:</h4>
<p>Currently mathlib makes it hard for me to express that it is isomorphic to its double dual... (assuming that this cohomology group is fin.dim., which is often the case).</p>

<a name="167268309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268309">Sebastien Gouezel (Jun 04 2019 at 08:06)</a>:</h4>
<p>Just for the record, with <code>pp.all</code> I have in the context</p>
<div class="codehilite"><pre><span></span><span class="bp">_</span><span class="n">inst_7</span> <span class="o">:</span> <span class="bp">@</span><span class="n">normed_space</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">uG</span><span class="o">}</span> <span class="n">k</span> <span class="n">G</span> <span class="o">(</span><span class="bp">@</span><span class="n">nondiscrete_normed_field</span><span class="bp">.</span><span class="n">to_normed_field</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">k</span> <span class="bp">_</span><span class="n">inst_1</span><span class="o">)</span> <span class="bp">_</span><span class="n">inst_6</span>
</pre></div>


<p>and the line that fails in instance search, if I read the trace correctly, is</p>
<div class="codehilite"><pre><span></span>[class_instances] (1) ?x_36 : @normed_space.{u uG} k G (@nondiscrete_normed_field.to_normed_field.{u} k _inst_1) _inst_6 := _inst_7
failed is_def_eq
</pre></div>


<p>This is really a mystery to me...</p>

<a name="167268338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268338">Johan Commelin (Jun 04 2019 at 08:07)</a>:</h4>
<p>That's really crazy...</p>

<a name="167268361"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268361" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268361">Keeley Hoek (Jun 04 2019 at 08:07)</a>:</h4>
<p>Is this the same reluctance to unify universe metavariables that makes you have to specify the category_theory morphism universe sometimes?</p>

<a name="167268425"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268425" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268425">Reid Barton (Jun 04 2019 at 08:08)</a>:</h4>
<p>So the category theory one I understand</p>

<a name="167268584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268584">Reid Barton (Jun 04 2019 at 08:10)</a>:</h4>
<p>The issue there is that, just like how in group theory we only talk about <code>G : Type u</code> and rely on the type class system to find <code>[group G]</code>, in category theory we talk about <code>C : Type u</code> and rely on the type class system to find <code>[category C]</code>. But there is a difference, because <code>category</code> has a second universe parameter <code>v</code> which is not determined by <code>C</code>. If you're unlucky it might also not be determined by whatever context is requiring the <code>category</code> instance and then Lean will refuse to "guess" <code>v</code> for you.</p>

<a name="167268618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268618">Reid Barton (Jun 04 2019 at 08:11)</a>:</h4>
<p>In that case you might need to add a <code>.{v}</code> somewhere.</p>

<a name="167268744"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167268744" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167268744">Reid Barton (Jun 04 2019 at 08:13)</a>:</h4>
<p>When I saw Sebastien's tactic state my first thought was that there is some problem about universe variables, but I don't understand what the problem was. It looks as though there is just a bug.</p>

<a name="167269587"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167269587" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167269587">Reid Barton (Jun 04 2019 at 08:26)</a>:</h4>
<blockquote>
<p>I agree with this (almost: I would be ready to have the field <code>k</code> in some universe -- think of the real numbers, they are in <code>Type</code> -- and the vector spaces in another one -- but in my example it doesn't work, they really all need to be in the same universe). I haven't seen any benefit of universe polymorphism either, and these issues don't exist in Isabelle. We really need the CS guys either to make it better, or to grant us the right to use only one universe :)</p>
</blockquote>
<p>I like the "<code>Type u</code> for everything" approach for all the parts of math that don't routinely use universes even in informal presentations.<br>
For cases where you want to work over some particular base field in <code>Type</code> there's always <code>ulift</code>. If <code>ulift real</code> isn't already a field then we can have someone go and make <code>algebra/ulift_instances</code>.</p>

<a name="167269733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167269733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167269733">Keeley Hoek (Jun 04 2019 at 08:29)</a>:</h4>
<p>What actually is the point of <code>Type u</code> not being in <code>Type u+2</code></p>

<a name="167270038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167270038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167270038">Kevin Buzzard (Jun 04 2019 at 08:34)</a>:</h4>
<blockquote>
<p>I fear that the <code>ℚ_[ℓ]</code>-vector space that rolls out of étale cohomology will not live in <code>Type</code>.</p>
</blockquote>
<p>Removing my computer science hat completely, you sound like you just said "I fear that the etale cohomology groups are not sets", to which I reply "Johan that is complete nonsense, of course they're sets! What are you talking about?"</p>

<a name="167270353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167270353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167270353">Reid Barton (Jun 04 2019 at 08:38)</a>:</h4>
<p>I think Johan means that the étale site of X is not small, but only essentially small. It's not clear what the best way to formalize this is--but informally we just pretend there's no difference at all.</p>

<a name="167270471"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167270471" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167270471">Johan Commelin (Jun 04 2019 at 08:39)</a>:</h4>
<p>I don't like have <code>ulift ℤ</code> and <code>ulift ℝ</code> all over the place... it's quite ugly. Otoh, battling universe issues is also ugly. I hope that we can jump between the two horns of this bull.</p>

<a name="167270713"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167270713" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167270713">Kevin Buzzard (Jun 04 2019 at 08:42)</a>:</h4>
<blockquote>
<p>The issue there is that, just like how in group theory we only talk about <code>G : Type u</code> and rely on the type class system to find <code>[group G]</code>, in category theory we talk about <code>C : Type u</code> and rely on the type class system to find <code>[category C]</code>. But there is a difference, because <code>category</code> has a second universe parameter <code>v</code> which is not determined by <code>C</code>. If you're unlucky it might also not be determined by whatever context is requiring the <code>category</code> instance and then Lean will refuse to "guess" <code>v</code> for you.</p>
</blockquote>
<p>My way of thinking about this completely solves this issue. Every category that I run into as a "normal mathematician" who is not explicitly trying to prove theorems about categories but is instead just using them as a tool to do "normal mathematics", is either a category where the class of all objects is a set (e.g. a diagram category), or a category where the class of all objects is not a set, but Hom(X,Y) is a set for all objects X and Y (e.g. the categories of sets, groups, rings, vector spaces over a field, schemes, topological spaces, insert arbitrary sane mathematical object here i.e. not "category"). So in all of "normal mathematics" there are only two things: small categories and big categories. In both cases v is determined by u. Mathematicians use these two kinds of categories in different ways too; diagram categories are for taking limits, all the other categories are for giving us a unified language for managing data and theorems, giving us a general language such as "adjoint functor" to save pen when we're trying to say what we want to say. </p>
<p>So the extension of my "just use one universe" argument to the category theory situation is "if you want to make the category of perfectoid spaces, make it a "category of the second kind" with just one universe parameter u, and have X : Type u and Hom(X,Y) : Type u. One universe, doing the thing which the ZFC universe was invented to solve". Problem solved. Not as universe polymorphic as some people like -- <em>but it works in Lean and it is enough for mathematicians</em>. </p>
<p>Sure if you want to develop some theories about higher categories or whatever then feel free to wrestle with universes; I am not saying that all of the maths everyone does should stick to one universe. But I want to argue that for "normal" mathematics, being universe polymorphic is <em>actively bad</em>. It is bad because things don't work. It is bad because normal mathematicians say "why are you assuming the existence of universes?". I have no good answer to this question. I want to start a campaign for one universe.</p>

<a name="167270902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167270902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167270902">Kevin Buzzard (Jun 04 2019 at 08:45)</a>:</h4>
<blockquote>
<p>I think Johan means that the étale site of X is not small, but only essentially small. It's not clear what the best way to formalize this is--but informally we just pretend there's no difference at all.</p>
</blockquote>
<p>I must understand all the mathematics here. How do we define the constant sheaf Z/nZ on the etale site? Insert definition here. It's a sheaf. H^0 is then in Type, right?</p>

<a name="167271017"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167271017" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167271017">Kevin Buzzard (Jun 04 2019 at 08:46)</a>:</h4>
<p>There are various ways of defining the higher H^i. Can't I just take some cohomologically trivial cover and then do some Cech-like thing? Is there really an issue here?</p>

<a name="167271433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167271433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167271433">Neil Strickland (Jun 04 2019 at 08:51)</a>:</h4>
<p>I don't really buy this.  It's a basic part of the formalism that any ring <code>R</code> is isomorphic to the ring of global sections of the structure sheaf on the Zariski site for <code>R</code>.  But under the natural framework of definitions, the latter ring will be in a higher universe.  You can probably avoid that, by some argument showing that it is sufficient to consider <code>R</code>-algebras of finite presentation, which can be specified by finite lists of elements of <code>R</code>.  But that will take some work.  However, there is some real mathematical content here: we have no right to expect that the obvious definition of etale cohomology does not lead to Russell-type paradoxes, and the reasons behind that are essentially the same as the universe considerations that we are discussing.</p>

<a name="167273439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167273439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167273439">Reid Barton (Jun 04 2019 at 09:16)</a>:</h4>
<p>Neil said basically what I was going to but just to spell out this "natural framework":<br>
Etale cohomology is an instance of sheaf cohomology, which we can define for any site. If F is a sheaf on a site (C, J) then H^0(F) is the limit of F over C^{op}. In general if we allow C to be a large category then H^0(F) might really be too big to be a set even if all the values of F are sets.<br>
Now in etale cohomology two things happen which each independently prevent this from occurring.</p>
<ul>
<li>The etale site of X has a terminal object (X itself) which means that H^0(F) is (isomorphic to) F(X). But we should regard this as a theorem, not a definition. Moreover we still have to do something about the higher H^i(F).</li>
<li>The etale site of X is essentially small (by the kind of cardinality arguments Neil mentioned) and therefore we can compute all the H^i(F) by replacing the etale site by an equivalent small category. Again there are theorems involved here (these cardinality arguments, and the fact that cohomology is unchanged under an equivalence of sites) but perhaps it's most ergonomic to define etale cohomology as the sheaf cohomology over a genuinely small category equivalent to the etale site of X.</li>
</ul>

<a name="167273625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167273625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167273625">Johan Commelin (Jun 04 2019 at 09:18)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> As mathematicians, we have <code>Type u ⊆ Type (u+1)</code>. Hence you're definition can spit out something in <code>Type (u+1)</code> but you can later prove that it actually lives in a smaller universe. We can't do that in Lean <span aria-label="sad" class="emoji emoji-2639" role="img" title="sad">:sad:</span></p>

<a name="167273825"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167273825" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167273825">Kevin Buzzard (Jun 04 2019 at 09:21)</a>:</h4>
<p>Conrad has thought hard about these issues and might have opinions on "the best way to do it". I'll see what he thinks. It will probably just be the "replace by an equivalent small category" argument.</p>

<a name="167273968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167273968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167273968">Kevin Buzzard (Jun 04 2019 at 09:23)</a>:</h4>
<p>I do think it's essential to prove that cohomology groups are in the right universe. Wait -- this is orthogonal to the underlying issue, isn't it? If I'm prepared once and for all to do some work (which should be done!) to prove that my cohomology groups are sets (which is one way of thinking about it with a ZFC perspective) then this is all just fine still; I still don't ever need more than one universe. I'm aware there's an issue, but I don't think universe polymorphism is the way to solve it; I think what Reid is saying is the way to solve it. This is hence not an argument for multiple universes.</p>

<a name="167274185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167274185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167274185">Johan Commelin (Jun 04 2019 at 09:26)</a>:</h4>
<p>It's not yet clear to me how we can define <code>H^i_et</code> to be in <code>Type</code> and also make it interact nicely with the sheaf cohomology machinery. The answer is probably to have comparison isomorphisms all over the place. And once we get sufficiently annoyed by them, we try to write a tactic that hides them for us.</p>

<a name="167274229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167274229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167274229">Johan Commelin (Jun 04 2019 at 09:27)</a>:</h4>
<blockquote>
<p>I do think it's essential to prove that cohomology groups are in the right universe.</p>
</blockquote>
<p>In Lean you cannot <em>prove</em> this. You have to make a definition, and that is the place where you have to get it right. If you mess up... bad luck.</p>

<a name="167274329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167274329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167274329">Johan Commelin (Jun 04 2019 at 09:29)</a>:</h4>
<p>But maybe we will have <code>norm_ulift</code> (-;</p>

<a name="167274836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167274836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167274836">Reid Barton (Jun 04 2019 at 09:36)</a>:</h4>
<p>I totally agree that having a field <code>k</code> and two <code>k</code>-algebras <code>R</code> and <code>S</code> and an <code>S</code>-module <code>M</code> all living in different universes is not sustainable and mathlib is probably close to exhausting the material for which it makes sense. If universes are causing any difficulty then just put everything in a single <code>Type u</code>. Kevin I'm not sure whether your "one universe" is <code>Type u</code> for a "fixed" <code>u</code> or genuinely <code>Type</code>--if the latter then I'm more skeptical.<br>
The reason we have two parameters in category theory is just to avoid duplication between small and large categories. We have definitions with up to four category parameters, I think, so there would be a lot of combinations.</p>

<a name="167275023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167275023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167275023">Johan Commelin (Jun 04 2019 at 09:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> But your problem didn't go away if you put everything in <code>Type u</code>, right? Only putting everything in <code>Type</code> worked, iirc...</p>

<a name="167275473"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167275473" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167275473">Sebastien Gouezel (Jun 04 2019 at 09:43)</a>:</h4>
<p>It works fine if everything is in <code>Type u</code>. If the field is in <code>Type u</code> and the normed spaces are in <code>Type v</code>, it doesn't.</p>

<a name="167283353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167283353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167283353">Mario Carneiro (Jun 04 2019 at 11:41)</a>:</h4>
<p>Coming back to the original question, is there a MWE?</p>

<a name="167309447"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167309447" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167309447">Kevin Buzzard (Jun 04 2019 at 16:05)</a>:</h4>
<p>From Brian:</p>
<blockquote>
<p>You don’t mean “equivalent to the etale site” (that can and should have arbitrarily huge disjoint unions in it), but rather the sheaf theory on such a more limited site is naturally equivalent (via restriction) to the sheaf theory on the actual small etale site. </p>
<p>This latter sheaf theory has no set-theoretic issues (in terms of Hom-sets being sets, etc.) because the sheaf theory only needs a “base” for the topology to determine objects up to unique isomorphisms and maps between objects.  So if for a scheme X you consider just affine schemes E equipped with an etale map f members U of a chosen base of Zariski open affines in X (to make it more “concrete”) then there’s a set of such triples (E, U, f) for which any triple is isomorphic to one of those, and if you throw in all finitely iterated fiber products among these then those objects and maps among them form a site and its sheaf theory is naturally equivalent to the one on X, so in that way you’ll get all the data you need to do the sheaf theory without set-theoretic issues.  The sheaf theory on the small etale site (etale X-schemes and etale covers thereof) is all that is needed for any of the foundational theorems and applications thereof (e.g., Weil II, etc.) that I have ever seen.</p>
<p>In EGA there is the important theorem that if Spec(B) —&gt; Spec(A) is etale, then Zariski-locally B looks “standard-etale” (i.e., (A[X]/(f))[1/f’]_h  for some monic f and some h in A[X]), but in the Stacks Project this is improved to avoid needing to Zariski-localize upstairs.  Same with smooth maps between affines.  Maybe that would be useful to you? </p>
<p>Brian</p>
</blockquote>

<a name="167317206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167317206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167317206">Sebastien Gouezel (Jun 04 2019 at 17:31)</a>:</h4>
<p>No MWE, it depends on two many modifications to mathlib. Once <a href="https://github.com/leanprover-community/mathlib/issues/1085" target="_blank" title="https://github.com/leanprover-community/mathlib/issues/1085">#1085</a> is merged, I will PR a branch with the workaround and showing the issue.</p>

<a name="167317375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Type%20classes%20again/near/167317375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/90385Typeclassesagain.html#167317375">Patrick Massot (Jun 04 2019 at 17:33)</a>:</h4>
<p>I'm working on it, but probably won't have time to finish before dinner, and then I need to bring one of my daughter to a spectacle...</p>


{% endraw %}
