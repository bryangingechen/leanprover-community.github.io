---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/32447listappendassocdefeq.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html">list.append_assoc defeq?</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="167736807"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167736807" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167736807">Scott Morrison (Jun 10 2019 at 06:30)</a>:</h4>
<p>This may be a strange question, but can anyone think of a way of modelling lists so the <code>append</code> operation becomes definitionally associative?</p>

<a name="167736812"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167736812" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167736812">Scott Morrison (Jun 10 2019 at 06:30)</a>:</h4>
<p>(i.e. in the sense that with normal <code>list</code>, <code>list.nil_append</code> is by <code>rfl</code>, but <code>list.append_nil</code> and <code>list.append_assoc</code> are proper theorems)</p>

<a name="167736888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167736888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167736888">Scott Morrison (Jun 10 2019 at 06:32)</a>:</h4>
<p>(For context, I just "proved" that every monoidal category was monoidally equivalent to a strictly associative one, by building an equivalence to a category whose objects were words in the objects of the original category. To a certain sort of mathematician, this is morally the right proof. However, in Lean it doesn't end up saying quite what you expected: the unitors and associator are not actually identities! Instead they are things like <code>eq_to_hom (list.append_assoc _ _ _)</code>.)</p>

<a name="167737463"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167737463" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167737463">Kevin Buzzard (Jun 10 2019 at 06:48)</a>:</h4>
<p>What happens with maps <code>fin n -&gt; alpha</code>?</p>

<a name="167737796"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167737796" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167737796">Keeley Hoek (Jun 10 2019 at 06:57)</a>:</h4>
<p>I get that for lists it's not definitional, but how is (e.g.) a unitor not an identity at the end of the day when <code>X</code> and <code>X \otimes 1</code> are equal on the nose?</p>

<a name="167738634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167738634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167738634">Kevin Buzzard (Jun 10 2019 at 07:17)</a>:</h4>
<p>I don't think <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><msub><mo>⊗</mo><mi>R</mi></msub><mi>R</mi></mrow><annotation encoding="application/x-tex">M \otimes_R R</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mbin"><span class="mbin">⊗</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mord mathit" style="margin-right:0.00773em;">R</span></span></span></span> are equal on the nose, despite every mathematician telling you they are</p>

<a name="167739457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167739457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167739457">Keeley Hoek (Jun 10 2019 at 07:34)</a>:</h4>
<p>Sure, but I think Scott is making the "strictification" of a monoidal category using lists, where the point is that in the new category nice things like <code>X</code> and <code>X \otimes 1</code> being equal actually hold because concatenation of lists is strictly associative.</p>

<a name="167741568"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167741568" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167741568">Reid Barton (Jun 10 2019 at 08:10)</a>:</h4>
<blockquote>
<p>This may be a strange question, but can anyone think of a way of modelling lists so the <code>append</code> operation becomes definitionally associative?</p>
</blockquote>
<p>Yes, it is true if you use difference lists, although it is not quite true with the <code>dlist</code> implementation in core for reasons I forget off-hand</p>

<a name="167741758"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167741758" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167741758">Reid Barton (Jun 10 2019 at 08:14)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/strictification/near/127139698" title="#narrow/stream/116395-maths/topic/strictification/near/127139698">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/strictification/near/127139698</a></p>

<a name="167742866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167742866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167742866">Kevin Buzzard (Jun 10 2019 at 08:38)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm">-</span>
<span class="cm">A difference list is a function that, given a list, returns the original</span>
<span class="cm">contents of the difference list prepended to the given list.</span>

<span class="cm">This structure supports `O(1)` `append` and `concat` operations on lists, making it</span>
<span class="cm">useful for append-heavy uses such as logging and pretty printing.</span>
<span class="cm">-/</span>
<span class="kn">structure</span> <span class="n">dlist</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">apply</span>     <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="n">invariant</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">apply</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">apply</span> <span class="o">[]</span> <span class="bp">++</span> <span class="n">l</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">dlist</span>
<span class="kn">open</span> <span class="n">function</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`</span><span class="err">♯</span><span class="bp">`</span><span class="o">:</span><span class="n">max</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">abstract</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">simp</span> <span class="o">}</span>

<span class="c">/-</span><span class="cm">- Convert a list to a dlist -/</span>
<span class="n">def</span> <span class="n">of_list</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">append</span> <span class="n">l</span><span class="o">,</span> <span class="err">♯</span><span class="bp">⟩</span>
</pre></div>


<p>I've never seen this before today. It looks to me like some sort of tedious implementation issue ;-)</p>

<a name="167742909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167742909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167742909">Kevin Buzzard (Jun 10 2019 at 08:39)</a>:</h4>
<p>wooah is that local notation being used to denote a tactic? What is this <code>abstract</code>?</p>

<a name="167742968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167742968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167742968">Kevin Buzzard (Jun 10 2019 at 08:40)</a>:</h4>
<p>So a <code>dlist</code> is a way of changing lists (to be thought of as appending the given list). This does feel like that whole monoid thing that Reid linked to.</p>

<a name="167743285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167743285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167743285">Kevin Buzzard (Jun 10 2019 at 08:46)</a>:</h4>
<p>Are two functions defeq if they defeqly agree everywhere?</p>

<a name="167743623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167743623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167743623">Reid Barton (Jun 10 2019 at 08:55)</a>:</h4>
<p><code>f</code> is equal to <code>λ x, f x</code> definitionally, so I guess that means yes</p>

<a name="167745920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167745920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167745920">Kevin Buzzard (Jun 10 2019 at 09:43)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">namespace</span> <span class="n">xena</span>

<span class="kn">structure</span> <span class="n">dlist</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">apply</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="c1">-- λ l, l ++ d</span>
<span class="o">(</span><span class="n">thm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">apply</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span> <span class="bp">++</span> <span class="n">apply</span> <span class="o">[])</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">to_list</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="o">[]</span>

<span class="kn">theorem</span> <span class="n">apply_def</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">l</span> <span class="bp">++</span> <span class="n">d</span><span class="bp">.</span><span class="n">to_list</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">d</span><span class="bp">.</span><span class="n">thm</span><span class="o">,</span>
  <span class="n">refl</span>
<span class="kn">end</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">nil</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">thm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">append_nil</span> <span class="n">l</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">}</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">append</span> <span class="o">(</span><span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">apply</span> <span class="o">(</span><span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="n">l</span><span class="o">),</span>
  <span class="n">thm</span> <span class="o">:=</span> <span class="k">begin</span>
    <span class="n">intro</span> <span class="n">l</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">apply_def</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">apply_def</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">apply_def</span><span class="o">,</span>
    <span class="n">rw</span> <span class="n">apply_def</span><span class="o">,</span>
    <span class="n">simp</span><span class="o">,</span>
  <span class="kn">end</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">dlist</span><span class="bp">.</span><span class="n">append</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">d</span> <span class="bp">+</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>


<span class="kn">end</span> <span class="n">xena</span>
</pre></div>

<a name="167745975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167745975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167745975">Kevin Buzzard (Jun 10 2019 at 09:44)</a>:</h4>
<p>I did it the other way to core (they go for <code>d ++ l</code>) and I'm not sure if it matters.</p>

<a name="167746032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746032">Johan Commelin (Jun 10 2019 at 09:45)</a>:</h4>
<p>Can we also have a <code>dnat</code> and <code>dint</code> etc? Where addition is associative by defeq...</p>

<a name="167746102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746102">Kevin Buzzard (Jun 10 2019 at 09:46)</a>:</h4>
<p>You define dnat to be the function which adds d to a nat.</p>

<a name="167746112"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746112" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746112">Reid Barton (Jun 10 2019 at 09:46)</a>:</h4>
<p>The original use for difference lists is to turn some arbitrary tree of appends into right-associated <code>a ++ (b ++ (c ++ ...))</code> which can be computed back to a list in linear time. If you append on the other side then you're always getting the worst case of <code>++</code> rather than always getting the best case.</p>

<a name="167746151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746151">Reid Barton (Jun 10 2019 at 09:47)</a>:</h4>
<p>But it doesn't matter if your goal is to achieve this strictification</p>

<a name="167746331"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746331" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746331">Johan Commelin (Jun 10 2019 at 09:50)</a>:</h4>
<p>I would love to have a <code>dint</code> where <code>i</code> is defeq to <code>(i - 1) + 1</code>.</p>

<a name="167746726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746726">Kenny Lau (Jun 10 2019 at 09:58)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">dint</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">apply</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span><span class="o">)</span>
<span class="o">(</span><span class="n">commutes</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">apply</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">i</span> <span class="bp">+</span> <span class="n">apply</span> <span class="mi">0</span><span class="o">)</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">dint</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="mi">1</span> <span class="o">(</span><span class="n">t</span><span class="bp">.</span><span class="mi">1</span> <span class="n">i</span><span class="o">),</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">s</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">t</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">t</span><span class="bp">.</span><span class="n">apply</span> <span class="mi">0</span><span class="o">),</span> <span class="n">add_assoc</span><span class="o">]</span><span class="bp">⟩⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">is_associative</span> <span class="n">dint</span> <span class="o">(</span><span class="bp">+</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>
</pre></div>

<a name="167746884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167746884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167746884">Kevin Buzzard (Jun 10 2019 at 10:01)</a>:</h4>
<p>I think that if I'd gone the core way then both zero_add and add_zero would be rfl</p>

<a name="167754335"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167754335" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167754335">Kevin Buzzard (Jun 10 2019 at 12:24)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">dlist</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">apply</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="c1">-- λ l, d ++ l</span>
<span class="o">(</span><span class="n">thm</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">l</span><span class="o">,</span> <span class="n">apply</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">apply</span> <span class="o">[]</span> <span class="bp">++</span> <span class="n">l</span><span class="o">)</span>

<span class="kn">variable</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">to_list</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span> <span class="o">:=</span> <span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="o">[]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">apply_def</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="n">l</span> <span class="bp">=</span> <span class="n">d</span><span class="bp">.</span><span class="n">to_list</span> <span class="bp">++</span> <span class="n">l</span><span class="o">:=</span>
<span class="k">by</span> <span class="o">{</span><span class="n">rw</span> <span class="n">d</span><span class="bp">.</span><span class="n">thm</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">nil</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span>
  <span class="n">thm</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">nil_append</span> <span class="n">l</span><span class="o">)}</span>

<span class="n">def</span> <span class="n">dlist</span><span class="bp">.</span><span class="n">append</span> <span class="o">(</span><span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">l</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="n">apply</span> <span class="o">(</span><span class="n">d</span><span class="bp">.</span><span class="n">apply</span> <span class="n">l</span><span class="o">),</span>
  <span class="n">thm</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">simp</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="o">(</span><span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">dlist</span><span class="bp">.</span><span class="n">append</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="o">(</span><span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="n">dlist</span><span class="bp">.</span><span class="n">nil</span> <span class="n">α</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="o">(</span><span class="n">c</span> <span class="bp">+</span> <span class="n">d</span><span class="o">)</span> <span class="bp">+</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">c</span> <span class="bp">+</span> <span class="o">(</span><span class="n">d</span> <span class="bp">+</span> <span class="n">e</span><span class="o">)</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">d</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">cases</span> <span class="n">d</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dlist</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">d</span> <span class="bp">=</span> <span class="n">d</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span><span class="n">cases</span> <span class="n">d</span><span class="o">,</span> <span class="n">refl</span><span class="o">}</span>
</pre></div>


<p>That's really annoying. How come I have to cases on d for add_zero and zero_add?</p>

<a name="167754523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167754523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167754523">Reid Barton (Jun 10 2019 at 12:26)</a>:</h4>
<p>Because one side is a variable and the other side is an application of <code>dlist.mk</code></p>

<a name="167754677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167754677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167754677">Kevin Buzzard (Jun 10 2019 at 12:29)</a>:</h4>
<p>And this is different to the add_assoc example?</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">dint</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="o">{</span> <span class="n">apply</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span>
  <span class="n">commutes</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">add_zero</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">}</span><span class="bp">⟩</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dint</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="n">d</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">cases</span> <span class="n">d</span><span class="bp">;</span> <span class="n">refl</span> <span class="c1">-- rfl fails</span>
</pre></div>


<p><span class="user-mention" data-user-id="110064">@Kenny Lau</span></p>

<a name="167754718"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167754718" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167754718">Reid Barton (Jun 10 2019 at 12:30)</a>:</h4>
<p>If we had definitional eta for structures then these would become defeq. (Same with unitality of bundled morphisms, functors, etc.)</p>

<a name="167754738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167754738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167754738">Reid Barton (Jun 10 2019 at 12:30)</a>:</h4>
<p>In associativity both sides are <code>dlist.mk</code> applications</p>

<a name="167755005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/list.append_assoc%20defeq%3F/near/167755005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/32447listappendassocdefeq.html#167755005">Kevin Buzzard (Jun 10 2019 at 12:34)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">d</span> <span class="o">:</span> <span class="n">dint</span><span class="o">)</span> <span class="o">:</span> <span class="n">d</span> <span class="bp">+</span> <span class="mi">0</span> <span class="bp">=</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">d</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>


<p>Penny has dropped</p>


{% endraw %}
