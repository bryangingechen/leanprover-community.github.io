---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/74840algebraicclosure.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/74840algebraicclosure.html">algebraic closure</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="166586393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebraic%20closure/near/166586393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74840algebraicclosure.html#166586393">Kenny Lau (May 26 2019 at 18:25)</a>:</h4>
<p>I have a new idea to construct an algebraic closure of a field F: for each (monic (irreducible)) polynomial p let Fp be a splitting field of p over F, and take the tensor product of all the Fp together (there is a construction of tensor product without direct limit but the direct limit construction might grant us quicker the fact that the ring is nonzero), and then quotient by a maximal ideal</p>

<a name="166587069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebraic%20closure/near/166587069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74840algebraicclosure.html#166587069">Neil Strickland (May 26 2019 at 18:43)</a>:</h4>
<p>I'd suggest something similar but a tiny bit different.  If <code>p</code> is monic of degree <code>n</code>, let <code>A_p</code> be the quotient of <code>F[a_1,..,a_n]</code> by the coefficients of <code>p - (x - a_1) * ... * (x - a_n)</code>.  The splitting field <code>L_p</code> is then the quotient of <code>A_p</code> by a maximal ideal.  Let <code>A</code> be the tensor product of all the <code>A_p</code>, and let <code>B</code> be the tensor product of all the <code>L_p</code>.  You are proposing to take the quotient of <code>B</code> by a maximal ideal, but it works just as well to take the quotient of <code>A</code> by a maximal ideal.  Moreover, you can specify a basis for <code>A_p</code> over <code>F</code> depending only on the degree of <code>p</code>, whereas the dimension of <code>L_p</code> depends in a delicate way on the Galois theoretic properties of <code>p</code>.  This makes it easier to deal with <code>A</code>.  Also, you can define <code>A</code> without explicit recourse to tensor products: you just take a polynomial ring over <code>F</code> with generators <code>a_{p,i}</code> for <code>i &lt; deg (p)</code> and take an appropriate quotient.</p>

<a name="166592739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebraic%20closure/near/166592739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74840algebraicclosure.html#166592739">Kenny Lau (May 26 2019 at 21:20)</a>:</h4>
<p>but we already have splitting fields</p>

<a name="166593443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebraic%20closure/near/166593443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74840algebraicclosure.html#166593443">Neil Strickland (May 26 2019 at 21:40)</a>:</h4>
<p>I know we have splitting fields.  But if you want to use splitting fields then you need to deal with colimits and tensor products, which you can avoid by the approach that I suggested.  And you will need to work a bit harder to verify that the relevant ring is nonzero.</p>

<a name="166596633"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebraic%20closure/near/166596633" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74840algebraicclosure.html#166596633">Kenny Lau (May 26 2019 at 23:11)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">linear_algebra</span><span class="bp">.</span><span class="n">basis</span>
<span class="kn">import</span> <span class="n">ring_theory</span><span class="bp">.</span><span class="n">algebra_operations</span>

<span class="kn">universe</span> <span class="n">u</span>

<span class="kn">private</span> <span class="n">def</span> <span class="n">monic_irred</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">p</span> <span class="o">:</span> <span class="n">polynomial</span> <span class="n">F</span> <span class="bp">//</span> <span class="n">p</span><span class="bp">.</span><span class="n">monic</span> <span class="bp">∧</span> <span class="kn">irreducible</span> <span class="n">p</span> <span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="kn">private</span> <span class="n">def</span> <span class="n">big_ring</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="o">:=</span>
<span class="n">mv_polynomial</span> <span class="o">(</span><span class="n">monic_irred</span> <span class="n">F</span><span class="o">)</span> <span class="n">F</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span> <span class="kn">private</span> <span class="n">def</span> <span class="n">big_ideal</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="n">ideal</span> <span class="o">(</span><span class="n">big_ring</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">ideal</span><span class="bp">.</span><span class="n">span</span> <span class="o">{</span> <span class="n">q</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">monic_irred</span> <span class="n">F</span><span class="o">,</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">eval₂</span> <span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">C</span> <span class="o">(</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">X</span> <span class="n">p</span><span class="o">)</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">}</span>

<span class="kn">private</span> <span class="n">def</span> <span class="n">big_basis</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">big_ideal</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">q</span> <span class="bp">|</span> <span class="bp">∃</span> <span class="n">p</span> <span class="o">:</span> <span class="n">monic_irred</span> <span class="n">F</span><span class="o">,</span> <span class="bp">∃</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">p</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">nat_degree</span><span class="o">,</span> <span class="n">ideal</span><span class="bp">.</span><span class="n">quotient</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_</span> <span class="o">((</span><span class="n">mv_polynomial</span><span class="bp">.</span><span class="n">X</span> <span class="n">p</span><span class="o">)</span><span class="err">^</span><span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="n">q</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="n">asdf</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">F</span> <span class="o">(</span><span class="n">big_ring</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kn">instance</span> <span class="n">ghjk</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="n">module</span> <span class="n">F</span> <span class="o">(</span><span class="n">big_ideal</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">quotient</span> <span class="o">:=</span>
<span class="n">sorry</span>

<span class="kn">private</span> <span class="kn">theorem</span> <span class="n">big_basis</span><span class="bp">.</span><span class="n">is_basis</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">discrete_field</span> <span class="n">F</span><span class="o">]</span> <span class="o">:</span> <span class="n">is_basis</span> <span class="n">F</span> <span class="o">(</span><span class="n">big_basis</span> <span class="n">F</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="166596676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/algebraic%20closure/near/166596676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/74840algebraicclosure.html#166596676">Kenny Lau (May 26 2019 at 23:12)</a>:</h4>
<p>when you want to rejoin Lean but you remember the frustration of <code>maximum class-instance resolution depth has been reached</code></p>


{% endraw %}
