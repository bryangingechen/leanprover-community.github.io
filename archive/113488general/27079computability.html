---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/27079computability.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html">computability</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="168155405"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168155405" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168155405">Kevin Buzzard (Jun 14 2019 at 17:34)</a>:</h4>
<p>It's about time I understood what Lean means by computability.</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>

<span class="c1">-- lean forces me to write noncomputable</span>
<span class="n">noncomputable</span> <span class="n">def</span> <span class="n">g</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">:</span> <span class="n">Y</span> <span class="bp">→</span> <span class="n">X</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">intro</span> <span class="n">y</span><span class="o">,</span>
  <span class="k">have</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">hf</span><span class="bp">.</span><span class="mi">2</span> <span class="n">y</span><span class="o">,</span>
  <span class="n">choose</span> <span class="n">x</span> <span class="n">hx</span> <span class="kn">using</span> <span class="n">h</span><span class="o">,</span>
  <span class="n">use</span> <span class="n">x</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">g</span> <span class="c1">-- it&#39;s supposed to be noncomputable but it looks like a computer program to me</span>

<span class="c1">-- Here I don&#39;t need to write noncomputable</span>
<span class="kn">theorem</span> <span class="n">g_property</span> <span class="o">{</span><span class="n">X</span> <span class="n">Y</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">}</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">Y</span><span class="o">)</span> <span class="o">(</span><span class="n">hf</span> <span class="o">:</span> <span class="n">function</span><span class="bp">.</span><span class="n">bijective</span> <span class="n">f</span><span class="o">)</span> <span class="o">(</span><span class="n">y</span> <span class="o">:</span> <span class="n">Y</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">f</span> <span class="o">(</span><span class="n">g</span> <span class="n">f</span> <span class="n">hf</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">exact</span> <span class="n">classical</span><span class="bp">.</span><span class="n">some_spec</span> <span class="o">(</span><span class="n">hf</span><span class="bp">.</span><span class="mi">2</span> <span class="n">y</span><span class="o">)</span>
<span class="kn">end</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span> <span class="n">g_property</span> <span class="c1">-- classical.choice</span>
<span class="c1">-- I used the axiom of choice but I&#39;m computable anyway.</span>

<span class="c1">-- and this is computable</span>
<span class="n">def</span> <span class="n">lem</span> <span class="o">(</span><span class="n">P</span> <span class="o">:</span> <span class="kt">Prop</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="bp">∨</span> <span class="bp">¬</span> <span class="n">P</span> <span class="o">:=</span> <span class="n">classical</span><span class="bp">.</span><span class="n">em</span> <span class="n">P</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">axioms</span> <span class="n">lem</span> <span class="c1">-- all the axioms</span>
</pre></div>


<p>In the definition of <code>g</code>, I am forced to mark it as noncomputable, but what does that mean? I thought proofs were programs. Is my definition of <code>g </code>not a program? My proof of g_property uses the axiom of choice according to <code>#print axioms</code> -- and yet it's computable anyway (in the sense that I was not asked to mark it as noncomputable). And I was not asked to mark my definition of <code>lem</code> as computable, but that's a definition which apparently uses the axiom of choice too. What is going on? It all still looks totally random to me but I think I might understand things enough to actually begin to see what this <code>noncomputable</code> thing which I'm randomly asked to put in front of definitions and possibly theorems (does that happen?) actually means, if someone tries to explain it to me...</p>

<a name="168155754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168155754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168155754">Kevin Buzzard (Jun 14 2019 at 17:38)</a>:</h4>
<blockquote>
<p>Lean’s standard library defines an additional axiom, propositional extensionality, and a quotient construction which in turn implies the principle of function extensionality. These extensions are used, for example, to develop theories of sets and finite sets. We will see below that using these theorems can block evaluation in Lean’s kernel, so that closed terms of type ℕ no longer evaluate to numerals. But Lean erases types and propositional information when compiling definitions to bytecode for its virtual machine evaluator, and since these axioms only add new propositions, they are compatible with that computational interpretation. Even computationally inclined users may wish to use the classical law of the excluded middle to reason about computation. This also blocks evaluation in the kernel, but it is compatible with compilation to bytecode.</p>
</blockquote>
<p>This is from TPIL and it's one of very few parts of the book which I still do not understand. But I don't understand this paragraph at all. I don't know what bytecode is or the virtual machine. I need to be told something easier first.</p>

<a name="168155900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168155900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168155900">Kevin Buzzard (Jun 14 2019 at 17:40)</a>:</h4>
<p>What I do understand is that there are conjectures I know such as Waring's problem, where there is a number which I regard as "well-defined", but for which no mathematician knows an algorithm for working them out. I can see that these aren't "computable". I guess I don't see why the other things are computable.</p>

<a name="168155976"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168155976" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168155976">Kevin Buzzard (Jun 14 2019 at 17:41)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Waring%27s_problem" target="_blank" title="https://en.wikipedia.org/wiki/Waring%27s_problem">https://en.wikipedia.org/wiki/Waring%27s_problem</a></p>
<p>It's known that <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mo>≤</mo><mi>G</mi><mo>(</mo><mn>3</mn><mo>)</mo><mo>≤</mo><mn>7</mn></mrow><annotation encoding="application/x-tex">4\leq G(3)\leq 7</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord mathrm">4</span><span class="mrel">≤</span><span class="mord mathit">G</span><span class="mopen">(</span><span class="mord mathrm">3</span><span class="mclose">)</span><span class="mrel">≤</span><span class="mord mathrm">7</span></span></span></span>.</p>

<a name="168157550"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168157550" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168157550">Chris Hughes (Jun 14 2019 at 18:01)</a>:</h4>
<p>It's okay to use choice to make a <code>Sort u</code>, or a proof. If you use it for anything else it's noncomputable.</p>

<a name="168157572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168157572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168157572">Reid Barton (Jun 14 2019 at 18:01)</a>:</h4>
<p>I think the rules are simply<br>
1. Types and propositions and proofs are always computable (because they are not actually represented at all at runtime). That is, anything whose type is <code>Sort u</code> for some <code>u</code>. This also extends to Pi-types ending in <code>Sort u</code>.<br>
2. Axioms are not computable (because they have no definition). Normally I think this only applies to <code>choice</code> because the other standard axioms are propositions.<br>
3. Anything that uses something noncomputable is noncomputable, except that rule 1 always takes priority.</p>

<a name="168157809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168157809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168157809">Reid Barton (Jun 14 2019 at 18:04)</a>:</h4>
<p>Maybe I've confused myself and rule 1 is really two separate rules (type erasure and proof irrelevance), not sure.</p>

<a name="168198303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168198303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168198303">Kevin Buzzard (Jun 15 2019 at 08:13)</a>:</h4>
<p>Ok so perhaps some examples of things which I might want to define are noncomputable <code>nat</code>s and noncomputable functions <code>f : X -&gt; Y</code>. So then my next, and I think my last, question is: what am I losing by having these things marked as noncomputable? Is the only difference that I am basically guaranteed not to be able to prove anything about these noncomputable gadgets using <code>rfl</code>? Is that it? I can just reason about these objects perfectly well using exactly the same sort of reasoning I would use in a maths paper. I would never want to use <code>rfl</code> on these objects anyway because I know they've been defined using some choice function.</p>
<p>With things like the perfectoid project I would work constructively by default, and would just write <code>noncomputable</code> in front of a definition every time Lean told me to. I could instead have just written <code>noncomputable theory</code> at the top of every file. What would I have lost if I'd done that? I am struggling to find any reason at all why I would ever care about computability. Let's say my goal was to define a perfectoid space and then state Scholze's tilting correspondence (this is feasible but would take a fair bit more work), and then let's say my next goal was to prove it (this would take an unfeasibly large amount of work unless I had a big team). Would I ever care about computability ever?</p>

<a name="168198845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168198845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168198845">Mario Carneiro (Jun 15 2019 at 08:30)</a>:</h4>
<p>Lean produces code for everything that's not marked <code>noncomputable</code></p>

<a name="168198852"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168198852" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168198852">Mario Carneiro (Jun 15 2019 at 08:30)</a>:</h4>
<p>you can look at this code, although it's not very intelligible</p>

<a name="168198880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168198880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168198880">Mario Carneiro (Jun 15 2019 at 08:32)</a>:</h4>
<p><code>noncomputable theory</code> has no downsides except that it makes computability less obvious (which itself may not be a downside depending on your POV). It actually means "please infer <code>noncomputable</code> for me"</p>

<a name="168198921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168198921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168198921">Mario Carneiro (Jun 15 2019 at 08:33)</a>:</h4>
<p>As I'm sure you've noticed, lean knows perfectly well which definitions are computable and which aren't, and without <code>noncomputable theory</code> it nags you until you put the markings it knows you should put. <code>noncomputable theory</code>just says to do this automatically without user interaction</p>

<a name="168198970"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168198970" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168198970">Kevin Buzzard (Jun 15 2019 at 08:34)</a>:</h4>
<p>I just don't get why computability is important to me if I just want to make mathematical objects and state and prove theorems about them.</p>

<a name="168198977"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168198977" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168198977">Mario Carneiro (Jun 15 2019 at 08:34)</a>:</h4>
<p>It's not, unless you are Anrdej Bauer</p>

<a name="168198995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168198995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168198995">Mario Carneiro (Jun 15 2019 at 08:35)</a>:</h4>
<p>and we're already long past that point since <code>choice</code> appears as an axiom so early in the development that it's difficult to do without</p>

<a name="168199051"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199051" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199051">Mario Carneiro (Jun 15 2019 at 08:37)</a>:</h4>
<p>You can still prove stuff about noncomputable gadgets using <code>rfl</code>, as long as you are doing some definition unfolding and such</p>

<a name="168199094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199094">Mario Carneiro (Jun 15 2019 at 08:38)</a>:</h4>
<p>you won't be able to do large scale rfl proofs like "compute the class number of this field", but I think you know when to use the word "compute" in this context</p>

<a name="168199103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199103">Mario Carneiro (Jun 15 2019 at 08:39)</a>:</h4>
<p>I think "noncomputable by default, computable for computations" is a reasonable stance for doing pure maths in lean</p>

<a name="168199151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199151">Kevin Buzzard (Jun 15 2019 at 08:40)</a>:</h4>
<p>I am not sure I know what "computations" mean. Kenny pointed out to me on Thursday at Xena that mathematicians and computer scientists use the term in two different ways.</p>

<a name="168199155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199155">Kevin Buzzard (Jun 15 2019 at 08:40)</a>:</h4>
<p>I think we use it incorrectly, and I think that the fact that I've been exposed to decades of incorrect usage of the term has clouded my thinking over the issue.</p>

<a name="168199206"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199206" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199206">Mario Carneiro (Jun 15 2019 at 08:42)</a>:</h4>
<p>roughly speaking, if you would open up GAP or a CAS to do it</p>

<a name="168199215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199215">Kenny Lau (Jun 15 2019 at 08:42)</a>:</h4>
<p>then you need a computable model of say Q-bar</p>

<a name="168199225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199225">Mario Carneiro (Jun 15 2019 at 08:43)</a>:</h4>
<p>sure, that's what I mean by "computable for computations"</p>

<a name="168199229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199229">Mario Carneiro (Jun 15 2019 at 08:43)</a>:</h4>
<p>unless you need that, computability does you no favors</p>

<a name="168199603"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199603" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199603">Kevin Buzzard (Jun 15 2019 at 08:57)</a>:</h4>
<p>The Curry-Howard correspondence says that "proofs are programs". Is there a program corresponding to the proof of the theorem that a product of non-empty sets is non-empty? What is a program? What language is this program supposed to be in?</p>

<a name="168199646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199646">Chris Hughes (Jun 15 2019 at 08:58)</a>:</h4>
<p>Yes. It's the program that returns (x,y), when x is the witness to X being nonempty, and y is the witness to Y being nonempty.</p>

<a name="168199650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199650">Kevin Buzzard (Jun 15 2019 at 08:58)</a>:</h4>
<p>infinite product!</p>

<a name="168199654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199654">Kevin Buzzard (Jun 15 2019 at 08:58)</a>:</h4>
<p>Then you want to give me a function.</p>

<a name="168199659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199659">Kevin Buzzard (Jun 15 2019 at 08:59)</a>:</h4>
<p>Is there a program corresponding to the proof of the theorem that the Riemann Hypothesis is either true or false?</p>

<a name="168199663"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199663" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199663">Chris Hughes (Jun 15 2019 at 08:59)</a>:</h4>
<p>I was thinking about this the other day</p>

<a name="168199710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199710">Kevin Buzzard (Jun 15 2019 at 09:00)</a>:</h4>
<p>Or maybe the Continuum Hypothesis would be a better example (something which is known not to be provable or disprovable from the axioms of maths)</p>

<a name="168199717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199717">Chris Hughes (Jun 15 2019 at 09:00)</a>:</h4>
<p>I think you can do this computably</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">{</span><span class="n">ι</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">ι</span> <span class="bp">→</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">S</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">setoid</span> <span class="o">(</span><span class="n">α</span> <span class="n">i</span><span class="o">)]</span>
  <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">quotient</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span><span class="o">))</span> <span class="o">:</span> <span class="bp">@</span><span class="n">quotient</span> <span class="o">(</span><span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="n">α</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span><span class="o">)</span>
</pre></div>

<a name="168199726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199726">Kevin Buzzard (Jun 15 2019 at 09:01)</a>:</h4>
<p>If I have <code>P : Prop</code> and then I have some Lean file which makes <code>hP : P</code>, is that <em>definitely</em> a program?</p>

<a name="168199733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199733">Kevin Buzzard (Jun 15 2019 at 09:01)</a>:</h4>
<p>Even if somewhere along the way, the construction of the term <code>hP</code> uses something <code>noncomputable</code>?</p>

<a name="168199775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199775">Chris Hughes (Jun 15 2019 at 09:02)</a>:</h4>
<p>In fact you could define this computably in <code>meta</code> using <code>quot.unquot</code> I think, and you would still have a function (even though you used <code>quot.unquot</code> which isn't a mathematical function</p>

<a name="168199779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199779">Kevin Buzzard (Jun 15 2019 at 09:02)</a>:</h4>
<p>There is something completely fundamental here which I don't understand. A <code>.lean</code> file looks to me like a program, because I can compile it using Lean on my computer. Does this have anything to do with computability though?</p>

<a name="168199781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199781">Chris Hughes (Jun 15 2019 at 09:02)</a>:</h4>
<p>And this is basically choice if all the quotients are true.</p>

<a name="168199790"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199790" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199790">Chris Hughes (Jun 15 2019 at 09:03)</a>:</h4>
<p>I guess it depends what you mean by computable.</p>

<a name="168199794"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199794" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199794">Kevin Buzzard (Jun 15 2019 at 09:03)</a>:</h4>
<p>Lean seems to have a perfectly well-defined notion of what it means for something to be computable.</p>

<a name="168199836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199836">Chris Hughes (Jun 15 2019 at 09:04)</a>:</h4>
<p><code>.lean</code> files aren't in the domain of that particular <code>computable</code> predicate.</p>

<a name="168199857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199857">Kevin Buzzard (Jun 15 2019 at 09:05)</a>:</h4>
<p>My understanding is that the initial interpretation of "proof = program" was that a proof was supposed to be interpreted as some sort of proof using only constructive logic or intuitionistic logic or whatever. As we all know, this is not what is going on maths departments across the world -- they have a more powerful notion of proof. Does this just <em>break</em> Curry-Howard, or is there a rigorous but wider interpretation of "program" which I can use which fixes it?</p>

<a name="168199893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199893">Mario Carneiro (Jun 15 2019 at 09:06)</a>:</h4>
<p>The quotient product example is one place where lean's syntactic notion of "computable" is overly restrictive</p>

<a name="168199901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199901">Kenny Lau (Jun 15 2019 at 09:06)</a>:</h4>
<p>just use Haskell's setoid-without-quotient philosophy</p>

<a name="168199903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199903">Kenny Lau (Jun 15 2019 at 09:06)</a>:</h4>
<p>then the quotient.choice is computable</p>

<a name="168199904"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199904" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199904">Mario Carneiro (Jun 15 2019 at 09:06)</a>:</h4>
<p>aka setoid hell</p>

<a name="168199909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199909">Kevin Buzzard (Jun 15 2019 at 09:06)</a>:</h4>
<p>I learnt about that from Nicola Gambini last week.</p>

<a name="168199917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199917">Mario Carneiro (Jun 15 2019 at 09:07)</a>:</h4>
<p>There are curry howard interpretations of LEM but they are a bit weird</p>

<a name="168199923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199923">Kevin Buzzard (Jun 15 2019 at 09:07)</a>:</h4>
<p>So Curry-Howard is a lie?</p>

<a name="168199964"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199964" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199964">Mario Carneiro (Jun 15 2019 at 09:08)</a>:</h4>
<p>Constructive proofs are programs</p>

<a name="168199971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199971">Chris Hughes (Jun 15 2019 at 09:08)</a>:</h4>
<p>What I don't quite get is if I have computable choice and computable univalence, shouldn't I be able to get computable em. Obviously I can't, but I don't see where the proof breaks down.</p>

<a name="168199979"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199979" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199979">Kevin Buzzard (Jun 15 2019 at 09:09)</a>:</h4>
<p>C-H is pithy, alliterative, beautiful-looking, but not actually true in maths departments because we have a different definition of proof and there is no corresponding definition of program.</p>

<a name="168199993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199993">Mario Carneiro (Jun 15 2019 at 09:09)</a>:</h4>
<p>I have heard it argued that for most of history mathematics was constructive</p>

<a name="168199996"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168199996" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168199996">Kevin Buzzard (Jun 15 2019 at 09:10)</a>:</h4>
<p>I don't live in the past.</p>

<a name="168200042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200042">Mario Carneiro (Jun 15 2019 at 09:10)</a>:</h4>
<p>it wasn't until dedekind and such that we started getting a more general notion of function that doesn't readily admit "execution"</p>

<a name="168200055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200055">Mario Carneiro (Jun 15 2019 at 09:11)</a>:</h4>
<p>You don't need to convince me that you don't see the point in constructivity</p>

<a name="168200059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200059">Kevin Buzzard (Jun 15 2019 at 09:11)</a>:</h4>
<p>Maybe we can say that the age of Curry-Howard is passed. What I am confused about is the fact that I can prove Tychonoff's theorem (or some other theorem equivalence to the mathematician's axiom of choice) in Lean and make a text file called <code>tykonov.lean</code> which looks to a mathematician like a computer program.</p>

<a name="168200100"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200100" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200100">Kevin Buzzard (Jun 15 2019 at 09:12)</a>:</h4>
<p>Is it not a computer program?</p>

<a name="168200104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200104">Mario Carneiro (Jun 15 2019 at 09:12)</a>:</h4>
<p>It is not</p>

<a name="168200105"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200105" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200105">Kevin Buzzard (Jun 15 2019 at 09:12)</a>:</h4>
<p>But I can compile it and it runs.</p>

<a name="168200108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200108">Kevin Buzzard (Jun 15 2019 at 09:12)</a>:</h4>
<p>It produces no output.</p>

<a name="168200109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200109">Mario Carneiro (Jun 15 2019 at 09:12)</a>:</h4>
<p>it is input to a computer program that analyzes the information in the file</p>

<a name="168200119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200119">Mario Carneiro (Jun 15 2019 at 09:13)</a>:</h4>
<p>There are many computer programs in the world, not all of them are compilers</p>

<a name="168200120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200120">Kevin Buzzard (Jun 15 2019 at 09:13)</a>:</h4>
<p>Aah, so Lean is the program, but my .lean file is not a program?</p>

<a name="168200130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200130">Kevin Buzzard (Jun 15 2019 at 09:13)</a>:</h4>
<p>I thought Lean compiled my .lean file into an .olean file</p>

<a name="168200133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200133">Mario Carneiro (Jun 15 2019 at 09:13)</a>:</h4>
<p>Just like when you write TeX code it's input to a program but it's not a program itself, it's just a data representation</p>

<a name="168200177"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200177" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200177">Mario Carneiro (Jun 15 2019 at 09:14)</a>:</h4>
<p>unless you write esoteric TeX macros which would be analogous to lean metaprograms which are actually programs</p>

<a name="168200193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200193">Mario Carneiro (Jun 15 2019 at 09:15)</a>:</h4>
<p>But the key point is this: when you write a proof that is <code>computable</code> in lean, it is literally both a proof and a program</p>

<a name="168200196"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200196" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200196">Mario Carneiro (Jun 15 2019 at 09:15)</a>:</h4>
<p>you can run it with <code>#eval</code></p>

<a name="168200239"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200239" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200239">Mario Carneiro (Jun 15 2019 at 09:16)</a>:</h4>
<p>and that's the main idea behind the computability interpretation of intuitionistic math</p>

<a name="168200248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200248">Kevin Buzzard (Jun 15 2019 at 09:16)</a>:</h4>
<p>macros: I did this in my thesis, which was written in plain TeX (which has no theorem numbering macros); I wrote the macros myself. I think my confusion is now resolved. I don't want to lose track of Chris' question above about computable <code>em</code>, I know he's been thinking a lot about univalence recently. <span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> do you know anything about </p>
<blockquote>
<p>What I don't quite get is if I have computable choice and computable univalence, shouldn't I be able to get computable em. Obviously I can't, but I don't see where the proof breaks down.</p>
</blockquote>
<p>Mario -- thanks as ever.</p>

<a name="168200269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200269">Kevin Buzzard (Jun 15 2019 at 09:17)</a>:</h4>
<p>Wait -- I thought the whole problem with HoTT was that univalence wasn't computable? And I have this vague idea that cubical type theory was an attempt to fix this.</p>

<a name="168200315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200315">Mario Carneiro (Jun 15 2019 at 09:18)</a>:</h4>
<p>that's right</p>

<a name="168200319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200319">Kevin Buzzard (Jun 15 2019 at 09:18)</a>:</h4>
<p>So Chris it seems to me that you have to become an expert in cubical type theory now.</p>

<a name="168200329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200329">Mario Carneiro (Jun 15 2019 at 09:19)</a>:</h4>
<p>univalence is not a nonconstructive principle, meaning that we have long believed that it has a constructive interpretation, but as defined in book HoTT it's an axiom, meaning that when you have to "call" it like a function you don't know what to do</p>

<a name="168200382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200382">Mario Carneiro (Jun 15 2019 at 09:20)</a>:</h4>
<p>In cubical type theory it's a theorem, so the implementation of that function (in terms of new primitives not in HoTT) is now known</p>

<a name="168200393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200393">Mario Carneiro (Jun 15 2019 at 09:20)</a>:</h4>
<p>Re: univalence and choice, I would try going through DIaconescu with a constructive mindset to see what happens</p>

<a name="168200404"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200404" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200404">Kevin Buzzard (Jun 15 2019 at 09:21)</a>:</h4>
<p>I have this uncomfortable feeling about this (univalence axiom). When I was moaning about having built a bunch of structure on a ring R and then wanting to move it onto an isomorphic ring S,  people were saying "use HoTT". Now I wonder whether some of the terms I'd get out of this HoTT strategy would just be useless in practice because they have been created using an axiom. On the other hand I guess I make terms using the axiom of choice and seem to get away with it.</p>

<a name="168200456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200456">Mario Carneiro (Jun 15 2019 at 09:22)</a>:</h4>
<p>It is an open question whether all the consequences of univalence computability are provable in book HoTT. AFAIK it's true</p>

<a name="168200467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200467">Mario Carneiro (Jun 15 2019 at 09:23)</a>:</h4>
<p>So you wouldn't actually get stuck, but you would need to prove lemmas about how transport works on different structures</p>

<a name="168200472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200472">Mario Carneiro (Jun 15 2019 at 09:23)</a>:</h4>
<p>(transport is the function <code>a = b -&gt; P a -&gt; P b</code>)</p>

<a name="168200733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168200733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168200733">Kevin Buzzard (Jun 15 2019 at 09:30)</a>:</h4>
<blockquote>
<p>But the key point is this: when you write a proof that is <code>computable</code> in lean, it is literally both a proof and a program</p>
</blockquote>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">X</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">+</span> <span class="mi">2</span> <span class="bp">=</span> <span class="mi">4</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="n">X</span> <span class="c1">-- #0</span>
</pre></div>

<a name="168201060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168201060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168201060">Kevin Buzzard (Jun 15 2019 at 09:41)</a>:</h4>
<p>Wait, I am confused again. I thought every proof was computable in Lean, in the sense that you don't have to mark it noncomputable because it's a proof?</p>

<a name="168201061"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168201061" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168201061">Alex J. Best (Jun 15 2019 at 09:41)</a>:</h4>
<blockquote>
<p>But the key point is this: when you write a proof that is <code>computable</code> in lean, it is literally both a proof and a program</p>
</blockquote>
<p>I'm still amazed by how fast</p>
<div class="codehilite"><pre><span></span>import data.zmod.quadratic_reciprocity
#eval (zmodp.legendre_sym 1111 3119 (by sorry))
</pre></div>


<p>runs.</p>

<a name="168201168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168201168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168201168">Mario Carneiro (Jun 15 2019 at 09:44)</a>:</h4>
<p>The caveat is that lean doesn't run what we normally call proofs, i.e. elements of elements of Prop. These are erased in the VM, so they are trivially computable</p>

<a name="168201189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168201189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168201189">Mario Carneiro (Jun 15 2019 at 09:45)</a>:</h4>
<p>It is possible to build a theorem prover such that these proofs are executable, and actually lean will reduce proofs if you use <code>#reduce</code>, but there are some efficiency problems with doing this at large scale</p>

<a name="168201363"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/computability/near/168201363" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/27079computability.html#168201363">Kevin Buzzard (Jun 15 2019 at 09:50)</a>:</h4>
<p>What about my proof that the noncomputable inverse of a bijection was indeed an inverse?</p>


{% endraw %}
