---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/83688syntax.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html">syntax</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="127544480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544480">Reid Barton (Jun 04 2018 at 13:22)</a>:</h4>
<p>Fun fact: <code>notation</code> applies even in <code>namespace</code> commands, so if you write <code>notation `foo` := bar</code> and then <code>namespace foo</code> it means <code>namespace bar</code></p>

<a name="127544555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544555">Simon Hudon (Jun 04 2018 at 13:24)</a>:</h4>
<p>Cool! :)</p>

<a name="127544571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544571">Simon Hudon (Jun 04 2018 at 13:25)</a>:</h4>
<p>I don't know if that's a good thing but I was properly surprised when I realized what you meant</p>

<a name="127544624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544624">Reid Barton (Jun 04 2018 at 13:26)</a>:</h4>
<p>If you don't want this to happen (like I didn't) then you can write <code>namespace «foo»</code></p>

<a name="127544649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544649">Simon Hudon (Jun 04 2018 at 13:27)</a>:</h4>
<p>Curiously enough, it also works on binders: <code>∀ foo, f foo</code> actually means <code>∀ bar, f bar</code> which is inconvenient when the notation is a short hand for an expression, not an identifier</p>

<a name="127544653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544653">Simon Hudon (Jun 04 2018 at 13:27)</a>:</h4>
<p>Thanks for the fix</p>

<a name="127544833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544833">Sebastian Ullrich (Jun 04 2018 at 13:31)</a>:</h4>
<p>o.O</p>

<a name="127544900"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544900" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544900">Simon Hudon (Jun 04 2018 at 13:32)</a>:</h4>
<p>I take it that's unintended behavior?</p>

<a name="127544969"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127544969" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127544969">Reid Barton (Jun 04 2018 at 13:34)</a>:</h4>
<p>(I was actually using <code>local notation</code>, in case that matters)</p>

<a name="127545111"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545111" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545111">Sebastian Ullrich (Jun 04 2018 at 13:37)</a>:</h4>
<p>I get "identifier expected" in both cases</p>
<div class="codehilite"><pre><span></span>constants foo bar : Type
local notation `foo` := bar
#check ∀ foo, foo
namespace foo
</pre></div>

<a name="127545171"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545171" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545171">Reid Barton (Jun 04 2018 at 13:38)</a>:</h4>
<p>Oh, I might have jumped to conclusions.<br>
What actually happened was that I was inside <code>namespace foo</code> and then I defined <code>foo</code> as local notation for something, and then <code>end foo</code> stopped working.</p>

<a name="127545183"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545183" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545183">Reid Barton (Jun 04 2018 at 13:39)</a>:</h4>
<p>with some error like "identifier expected"</p>

<a name="127545332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545332">Simon Hudon (Jun 04 2018 at 13:42)</a>:</h4>
<p>Yes, you're right. That's what happens for me too. Sorry about the confusion</p>

<a name="127545397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545397">Sebastian Ullrich (Jun 04 2018 at 13:44)</a>:</h4>
<p>I see. This will probably be fixed in Lean 4 automatically since we will be using a parser combinator without a scanner, so we can skip notations where we only want to parse identifiers.</p>

<a name="127545431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545431">Simon Hudon (Jun 04 2018 at 13:45)</a>:</h4>
<p>How is that going by the way?</p>

<a name="127545680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545680">Sebastian Ullrich (Jun 04 2018 at 13:51)</a>:</h4>
<p>Let's... say that we're transitioning from the planning phase to the implementation phase (parser, compiler, and other refactorings)</p>

<a name="127545899"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/127545899" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#127545899">Simon Hudon (Jun 04 2018 at 13:56)</a>:</h4>
<p>Exciting :D I can't wait to see where that will end up!</p>

<a name="166864691"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166864691" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166864691">Tim Daly (May 29 2019 at 22:54)</a>:</h4>
<p>Is there an EBNF description of the Lean syntax?</p>

<a name="166864806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166864806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166864806">Wojciech Nawrocki (May 29 2019 at 22:56)</a>:</h4>
<p>Maybe this: <a href="https://leanprover.github.io/reference/lexical_structure.html" target="_blank" title="https://leanprover.github.io/reference/lexical_structure.html">https://leanprover.github.io/reference/lexical_structure.html</a> ? I'm not sure if it's actually EBNF</p>

<a name="166864945"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166864945" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166864945">Tim Daly (May 29 2019 at 22:59)</a>:</h4>
<p>That doesn't describe, for example, the syntax of optional types, etc. It is more like a tokenizer syntax.</p>

<a name="166865244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166865244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166865244">Wojciech Nawrocki (May 29 2019 at 23:03)</a>:</h4>
<p>Oh, that's true</p>

<a name="166865321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166865321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166865321">Tim Daly (May 29 2019 at 23:04)</a>:</h4>
<p>I'd like to accept Lean syntax as part of a system I'm building, making it easier to export proofs to Lean</p>

<a name="166865501"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166865501" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166865501">Wojciech Nawrocki (May 29 2019 at 23:08)</a>:</h4>
<p>Perhaps <a href="https://bitbucket.org/gebner/pygments-main/src/d5e82e6ed58cfedf985cb1d5d55d056e477aa667/pygments/lexers/theorem.py?at=default#lines-377" target="_blank" title="https://bitbucket.org/gebner/pygments-main/src/d5e82e6ed58cfedf985cb1d5d55d056e477aa667/pygments/lexers/theorem.py?at=default#lines-377">the Pygments syntax description</a> might help?</p>

<a name="166865935"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166865935" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166865935">Tim Daly (May 29 2019 at 23:14)</a>:</h4>
<p>Wow,  the person who wrote that code is multilingual. Still it is only a tokenizer. I was hoping that I didn't have to create the EBNF from Leonardo's source code.</p>

<a name="166887712"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/166887712" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#166887712">Mario Carneiro (May 30 2019 at 07:44)</a>:</h4>
<p>I think <span class="user-mention" data-user-id="115334">@Thales</span> wrote a Lean grammar for Mehnir, which is probably the closest approximation yet. Part of the problem is that lean isn't actually context free, so you have to make a bunch of approximations and it's not actually sure to work (or even likely to work without a lot of hard-coding) on a real lean file</p>

<a name="167059113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167059113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167059113">Tim Daly (Jun 01 2019 at 06:55)</a>:</h4>
<p>Well, I read the sources looking for EBNF. Unfortunately(?) Lean uses Pratt parsing. You can change syntax on the fly.</p>

<a name="167061418"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167061418" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167061418">Mario Carneiro (Jun 01 2019 at 08:03)</a>:</h4>
<p>right, that's the <code>notation</code> command</p>

<a name="167061486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167061486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167061486">Mario Carneiro (Jun 01 2019 at 08:04)</a>:</h4>
<p>You can still do decently if you know what syntaxes are defined, and parse up to the next command keyword</p>

<a name="167064470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167064470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167064470">Tim Daly (Jun 01 2019 at 09:27)</a>:</h4>
<p>This causes a portability problem. I'd like to have a parser / exporter that can communicate freely with Lean. But if the notation command is used the associations can change dynamically making previously accepted communications fail. The obvious workaround would be to export the led-nud tables but I don't see anything in the source code that provides that. Another alternative would be to communicate using only "unsugared syntax". I will read more about that level of detail soon.</p>

<a name="167065160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167065160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167065160">Tim Daly (Jun 01 2019 at 09:47)</a>:</h4>
<p>I am trying to combine proofs with code. This is a "30 year horizon" effort so it is important that the proofs are repeatable and stable (think latex, common lisp, and pdfs). The ability to modify syntax is one problem. The ability to modify tactics is another. Proofs are difficult, time consuming, and require a lot of effort. The hope is that today's proof will be accepted by the system years from now with the same result.</p>

<a name="167065472"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167065472" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167065472">Tim Daly (Jun 01 2019 at 09:57)</a>:</h4>
<p>At the moment the only path seems to be to extract the Lean kernel and, for every proof, have the system dump a "kernel version" that used no syntax or tactics, just kernel-level I/O. That would enable proofs to be developed at the higher levels but stored and replayed as kernel code. The assumption is that the kernel is small and "30 year horizion" stable.</p>

<a name="167065647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167065647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167065647">Andrew Ashworth (Jun 01 2019 at 10:02)</a>:</h4>
<p>The API is likely to change drastically regardless when Lean v4 arrives later this year. There will be many breaking changes. At a minimum mutually inductive types are going to move into the kernel for performance reasons, and there is no reason to believe other things may not move into the kernel if necessary for usability.</p>

<a name="167065649"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167065649" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167065649">Tim Daly (Jun 01 2019 at 10:02)</a>:</h4>
<p>My code uses theorems from the 1890s so long-term proof stability is a vital issue.</p>

<a name="167065809"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167065809" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167065809">Andrew Ashworth (Jun 01 2019 at 10:07)</a>:</h4>
<p>I can't think of a single proof language with that kind of stability, unfortunately.</p>

<a name="167066235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167066235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167066235">Tim Daly (Jun 01 2019 at 10:19)</a>:</h4>
<p>How can I build up chains of Definitions and Lemmas proving code correctness if the whole thing fails a week later? I don't know how to do computational mathematics on that basis. I have common lisp source code for my computer algebra system that still compiles and executes with the same results today that it had when it was written in 1980. I have latex documents from then. It seems perfectly reasonable to expect that a "proof" by machine code would continue to be checkable in 2049.</p>

<a name="167066617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167066617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167066617">Andrew Ashworth (Jun 01 2019 at 10:30)</a>:</h4>
<p>If you're willing to never upgrade or import results from the proof community at large, you could fix a version of &lt;your favorite proof language&gt;. Hardly appealing, I know.</p>

<a name="167066810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167066810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167066810">Tim Daly (Jun 01 2019 at 10:37)</a>:</h4>
<p>It might be useful to consider a "standards effort" in proof technology. There used to be many competing lisp dialects and they eventually agreed on common lisp. I used lisp 1.5, maclisp, lispvm, psl, and many others and was good at "porting code". Now the common lisp standard makes that pointless. Perhaps there needs to be a Common Proof effort that provides a stable basis for (at least primitive syntax) of proofs  that can be universally accepted. Computational mathematics IS mathematics so it seems that long-term "30 year horizon" stability ought to be a major goal.</p>

<a name="167067071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067071">Tim Daly (Jun 01 2019 at 10:44)</a>:</h4>
<p>Competing on "features" is for game programmers, not mathematicians.</p>

<a name="167067132"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067132" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067132">Patrick Massot (Jun 01 2019 at 10:46)</a>:</h4>
<p>I think you don't quite understand where we stand now. Freezing stuff at such an early stage would probably be very counter-productive. See <a href="https://deducteam.github.io/" target="_blank" title="https://deducteam.github.io/">https://deducteam.github.io/</a> however (but keep in mind that this is also very much work in progress)</p>

<a name="167067381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067381">Scott Morrison (Jun 01 2019 at 10:54)</a>:</h4>
<p>At the moment we are still before the beginning of history. Theorem provers are not yet useful for mathematics.</p>

<a name="167067386"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067386" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067386">Scott Morrison (Jun 01 2019 at 10:54)</a>:</h4>
<p>(That is not to say they are not worth investing significant time in.)</p>

<a name="167067397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067397">Scott Morrison (Jun 01 2019 at 10:55)</a>:</h4>
<p>But any serious plans for backwards compatibility should wait (implementation at least, not discussion) until we have something.</p>

<a name="167067836"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067836" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067836">Tim Daly (Jun 01 2019 at 11:08)</a>:</h4>
<p>Systems that use CIC, for instance, ought to have a compatible "raw" language for accepting each other's proofs. At minimum, a system ought to accept its own "raw" logic no matter what else changes. The logic is stable. The issue isn't "backward compatiblity" but "forward compatibilty". I can still compile and run my C code from my PDP-11/03 (1976). It seems obvious that a proof system should always accept a "proven" proof forever.</p>

<a name="167067971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167067971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167067971">Andrew Ashworth (Jun 01 2019 at 11:12)</a>:</h4>
<p>In fact, the underlying logic isn't stable. For example, Coq only recently got universe polymorphism in version 8.5, and the underlying implementation is still subject to change.</p>

<a name="167068043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068043">Tim Daly (Jun 01 2019 at 11:15)</a>:</h4>
<p>So Coq doesn't have a stable proven kernel of logic?</p>

<a name="167068160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068160">Andrew Ashworth (Jun 01 2019 at 11:18)</a>:</h4>
<p>No. Extensions to CIC are allowed (as in Lean) as long as the developers think it's a good idea.</p>

<a name="167068175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068175">Tim Daly (Jun 01 2019 at 11:19)</a>:</h4>
<p>Do they invalidate prior proofs? (Will Flyspeck become junk?)</p>

<a name="167068523"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068523" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068523">Andrew Ashworth (Jun 01 2019 at 11:28)</a>:</h4>
<p>I'm just looking at Flyspeck's project history and the most recent source code change was in Jan 25, 2019. Despite the fact the project was finished five years ago.</p>

<a name="167068536"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068536" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068536">Patrick Massot (Jun 01 2019 at 11:29)</a>:</h4>
<p>According to Manuel Eberl, the Flyspeck project is compiled <em>every day</em> against current version of the relevant proof assistant.</p>

<a name="167068537"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068537" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068537">Patrick Massot (Jun 01 2019 at 11:29)</a>:</h4>
<p>(automatically of course)</p>

<a name="167068792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167068792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167068792">Tim Daly (Jun 01 2019 at 11:36)</a>:</h4>
<p>It seems my understanding of "the trusted kernel" is bogus. I'll read the source code and try to get a better grounding. Thanks.</p>

<a name="167073089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167073089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167073089">Reid Barton (Jun 01 2019 at 13:41)</a>:</h4>
<blockquote>
<p>At the moment the only path seems to be to extract the Lean kernel and, for every proof, have the system dump a "kernel version" that used no syntax or tactics, just kernel-level I/O. That would enable proofs to be developed at the higher levels but stored and replayed as kernel code. The assumption is that the kernel is small and "30 year horizion" stable.</p>
</blockquote>
<p><code>lean --export</code> is something like this</p>

<a name="167073209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167073209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167073209">Reid Barton (Jun 01 2019 at 13:45)</a>:</h4>
<p>There are external type checkers that can check the output of <code>lean --export</code>, for example <a href="https://github.com/dselsam/tc" target="_blank" title="https://github.com/dselsam/tc">https://github.com/dselsam/tc</a></p>

<a name="167073283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167073283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167073283">Reid Barton (Jun 01 2019 at 13:47)</a>:</h4>
<p>So there is at least a very small amount of portability, namely, to outside the Lean kernel itself</p>

<a name="167075291"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167075291" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167075291">Mario Carneiro (Jun 01 2019 at 14:45)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span>  I am sad I missed this discussion. Lean is not the place to look for stability, but there are proof languages that are designed for long term stability. Long future archiving and maintenance in perpetuity is among the selling points of Metamath. It has a standard, which was written down, in a published book from the 1990s and still remains valid (although additions have grown in the gaps, like HTML). There are as a result a whole ecosystem of independent verifiers, and in fact no single verifier "dominates the market", which is not something I can say about any other proof language I know. The axiom system is not completely stable but has changed only a few times in its 20 year history, and is based on an old mathematical standard, ZFC.</p>
<p>The downside to this kind of long term standardization is that it doesn't leave a lot of room for "syntax sugar" and building conveniences into the language, which is where Lean and Coq are coming from. I try to provide some assurance of "monotonicity" of proofs that are submitted to mathlib, but it's not easy. The axiom system is dependent on subtleties that make the proofs not portable to similar systems (such as Coq or other DTT systems), the syntax changes every few years, and we've literally thrown away the library and started afresh since the previous version, and while I don't intend to repeat that experience with lean 4 the language changes are just as traumatic. This is done in the quest for an easy to use language, where you can just sit down and write proofs and it's easy, and I respect that goal; but I think that this need not conflict with standardization.</p>
<p>Consider HTML and Javascript. This is a standard from the early 90s that we still use today. It has changed, but slowly and with a clearly defined standards body behind it. It has not hampered our ability to build new and glitzy things on top, but the key is that no one actually writes HTML/JS directly anymore. Instead the glitzy front end is written in some framework or language that didn't exist a year ago, and is hooked to a compiler that produces standards conformant HTML. I think this approach is very powerful, and I wish people would think more about having a separate back end with a well understood logic, and a core verifier that anyone can write.</p>

<a name="167075619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167075619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167075619">Johan Commelin (Jun 01 2019 at 14:55)</a>:</h4>
<p>In principal I really like this idea... but it seems very non-trivial to build this. Quite a bit harder than HTML, I would think</p>

<a name="167075674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167075674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167075674">Johan Commelin (Jun 01 2019 at 14:56)</a>:</h4>
<p>And already with the HTML + JS example you see that every new year brings a new framework, but it's hard to make them interact</p>

<a name="167075678"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167075678" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167075678">Kevin Buzzard (Jun 01 2019 at 14:56)</a>:</h4>
<p>I still write html ;-)</p>

<a name="167075704"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/syntax/near/167075704" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/83688syntax.html#167075704">Johan Commelin (Jun 01 2019 at 14:57)</a>:</h4>
<p>If proofs are written in some framework that still compiles in 50 (or 500) years, that is of course fabulous. But if those theorems can't be applied, because the framework they are written in is outdated, I don't see how this is any better than saying "Ooh, Flyspeck (or whatever) compiles with $ANCIENT version of $THEOREM_PROVER".</p>


{% endraw %}
