---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113488general/87130T50000challenge.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113488general/index.html">general</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html">-T50000 challenge</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="165857644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165857644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165857644">Kevin Buzzard (May 16 2019 at 23:17)</a>:</h4>
<p>I just tried compiling mathlib with the timeout flag set to T50000 and it doesn't compile -- there are some deterministic timeouts.</p>
<p>Why do this? Well, when making the perfectoid project there were times when we were really battling against timeouts; for example check out </p>
<p><a href="https://github.com/leanprover-community/lean-perfectoid-spaces/blob/c1fec0fe89a6bac395935c759b8387316df0e3a6/src/valuation/field.lean#L653" target="_blank" title="https://github.com/leanprover-community/lean-perfectoid-spaces/blob/c1fec0fe89a6bac395935c759b8387316df0e3a6/src/valuation/field.lean#L653">https://github.com/leanprover-community/lean-perfectoid-spaces/blob/c1fec0fe89a6bac395935c759b8387316df0e3a6/src/valuation/field.lean#L653</a></p>
<p>which should be a one line term mode proof but Lean would time out at -T100000 (the default time-out value) so we had to tread really carefully to make the proof compile. At the time I thought that we were pushing Lean to the edge -- but since Mario responded in the timeout thread and showed us some more tricks I realise now that actually we were simply not getting Lean to unify efficiently. <span class="user-mention" data-user-id="110049">@Mario Carneiro</span> I don't know whether a judicious <code>: _</code> fixes that proof, but definitely a judicious bunch of <code>let</code>s makes the proof compile instantly -- I've made this happen myself.</p>
<p>Compiling mathlib with <code>-T50000</code> might show up some more instances where people have written code which takes several seconds to compile instead of several tenths of a second because of similar issues. The first issue I ran into is</p>
<div class="codehilite"><pre><span></span>mathlib-community-master/src/category_theory/equivalence.lean:124:33: error: (deterministic) timeout
mathlib-community-master/src/category_theory/equivalence.lean:124:30: error: (deterministic) timeout
mathlib-community-master/src/category_theory/equivalence.lean:124:30: error: (deterministic) timeout
mathlib-community-master/src/category_theory/equivalence.lean:123:2: error: (deterministic) timeout
mathlib-community-master/src/category_theory/equivalence.lean:122:23: error: (deterministic) timeout
</pre></div>


<p>with code</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">adjointify_Œ∑</span> <span class="o">:</span> <span class="mi">ùü≠</span> <span class="n">C</span> <span class="err">‚âÖ</span> <span class="n">F</span> <span class="err">‚ãô</span> <span class="n">G</span> <span class="o">:=</span>
<span class="n">Œ∑</span> <span class="err">‚â™‚â´</span> <span class="n">iso_whisker_left</span> <span class="n">F</span> <span class="o">((</span><span class="n">left_unitor</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span> <span class="err">‚â™‚â´</span>
  <span class="n">iso_whisker_right</span> <span class="n">Œµ</span><span class="bp">.</span><span class="n">symm</span> <span class="n">G</span><span class="o">)</span> <span class="err">‚â™‚â´</span> <span class="n">iso_whisker_right</span> <span class="n">Œ∑</span><span class="bp">.</span><span class="n">symm</span> <span class="o">(</span><span class="n">F</span> <span class="err">‚ãô</span> <span class="n">G</span><span class="o">)</span>
</pre></div>


<p>Is there some way of making Lean unify this more quickly? </p>
<p>NB the easiest way to play along at home is to open mathlib in VS Code, File -&gt; Preferences -&gt; Settings, search for Lean and find the timeout value and change it from 100000 to 50000, and then add and remove a character from equivalence.lean to make it recompile.</p>

<a name="165858601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165858601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165858601">Floris van Doorn (May 16 2019 at 23:32)</a>:</h4>
<p>Yeah, I can imagine that that definition is a stress test on Lean. So for functors the associator <code>(F ‚ãô G) ‚ãô H ‚âÖ F ‚ãô (G ‚ãô H</code> is true by reflexivity and the unitors <code>1 ‚ãô F ‚âÖ F</code> are true by reflexivity as long as <code>F</code> is of the form <code>‚ü®_, _, _, _‚ü©</code> (usually this is the case if <code>F</code> is anything other than a variable). In the category theory library we can use/abuse this, by not explicitly writing down these associators and unitors, but at the cost of making Lean do (a lot of) extra work. We maybe should decide that we want to avoid doing these rules silently. However, this would change the definitions of natural isomorphisms we are defining, which might make future proofs more finicky. See also the discussion below this comment:<br>
<a href="https://github.com/leanprover-community/mathlib/pull/1018#discussion_r283978240" target="_blank" title="https://github.com/leanprover-community/mathlib/pull/1018#discussion_r283978240">https://github.com/leanprover-community/mathlib/pull/1018#discussion_r283978240</a></p>
<p>In this particular case I think there are two silent associators and one silent left unitor (and 1 non-silent one). We should probably include them explicitly. <span class="user-mention" data-user-id="110087">@Scott Morrison</span></p>

<a name="165858733"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165858733" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165858733">Scott Morrison (May 16 2019 at 23:34)</a>:</h4>
<p>I agree this is a problem, and perhaps it indicates we should go back to your original construction for <code>adjointify</code>, which explicitly provided the components, at the expense of needing to check naturality.</p>

<a name="165858738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165858738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165858738">Scott Morrison (May 16 2019 at 23:34)</a>:</h4>
<p>Actually, what we really should do is both.</p>

<a name="165858761"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165858761" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165858761">Scott Morrison (May 16 2019 at 23:35)</a>:</h4>
<p>Define <code>adjointify</code> so that it is obviously natural, but inserting unitors and associators so elaboration fast</p>

<a name="165858770"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165858770" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165858770">Scott Morrison (May 16 2019 at 23:35)</a>:</h4>
<p>and then give a simp lemma that says the components are what you want them to be.</p>

<a name="165858864"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165858864" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165858864">Kevin Buzzard (May 16 2019 at 23:36)</a>:</h4>
<p>Out of interest, when we compiled the perfectoid project at -T50000 there were problems in four places. Two were fixed with Mario's <code>: _</code> trick, one was a <code>use</code> which we changed to <code>existsi</code>, and one was <code>embedding f</code> which had a potential overload and was fixed by changing it to <code>_root_.embedding f</code>. In all four cases elaboration time dropped dramatically from "takes several seconds to compile" to "compiles instantly".</p>

<a name="165858894"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165858894" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165858894">Kevin Buzzard (May 16 2019 at 23:37)</a>:</h4>
<p>But is this associator thing yet another kind of problem?</p>

<a name="165858943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165858943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165858943">Floris van Doorn (May 16 2019 at 23:37)</a>:</h4>
<blockquote>
<p>Actually, what we really should do is both.</p>
</blockquote>
<p>I wanted to also suggest that. That is basically what I did in the Lean 2 HoTT library:<br>
<a href="https://github.com/leanprover/lean2/blob/master/hott/algebra/category/functor/equivalence.hlean#L82-L102" target="_blank" title="https://github.com/leanprover/lean2/blob/master/hott/algebra/category/functor/equivalence.hlean#L82-L102">https://github.com/leanprover/lean2/blob/master/hott/algebra/category/functor/equivalence.hlean#L82-L102</a><br>
I defined the new <code>Œ∑</code> first on components, and to show naturality I showed that it was equal to the map of a natural transformation, defined fully explicit.</p>

<a name="165859067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165859067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165859067">Kevin Buzzard (May 16 2019 at 23:39)</a>:</h4>
<p>What I feel I learnt from this experiment was that long elaboration times are not always inevitable -- sometimes persuading Lean to elaborate the same thing slightly differently can have a massively beneficial effect and perhaps even teach us something.</p>

<a name="165859297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165859297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165859297">Floris van Doorn (May 16 2019 at 23:43)</a>:</h4>
<blockquote>
<p>But is this associator thing yet another kind of problem?</p>
</blockquote>
<p>Yes, but we're basically abusing the Lean type checker. We have an expression <code>(F ‚ãô ((G ‚ãô F) ‚ãô G)</code> which we need to match with <code>(F ‚ãô G) ‚ãô (F ‚ãô G)</code>. We should really rewrite one expression to the other (using natural isomorphisms), but we proof it "by reflexivity". This is true, but only if Lean unfolds all occurrences of <code>‚ãô</code> (and likely gets a huge term in the process).<br>
It's roughly similar to proving <code>1000 + 1000 = 2000</code> by <code>refl</code> instead of <code>norm_num</code>.</p>

<a name="165877926"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165877926" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165877926">Kevin Buzzard (May 17 2019 at 07:04)</a>:</h4>
<p>Oh that's a very clear explanation Floris, thanks!</p>

<a name="165877990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165877990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165877990">Kevin Buzzard (May 17 2019 at 07:05)</a>:</h4>
<p>The next one is this, from <code>src/data/complex/exponential.lean:456:0</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">cos_add</span> <span class="o">:</span> <span class="n">cos</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">cos</span> <span class="n">y</span> <span class="bp">-</span> <span class="n">sin</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">sin</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">‚Üê</span> <span class="n">domain</span><span class="bp">.</span><span class="n">mul_left_inj</span> <span class="o">(</span><span class="bp">@</span><span class="n">two_ne_zero&#39;</span> <span class="n">‚ÑÇ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span>
      <span class="err">‚Üê</span> <span class="n">domain</span><span class="bp">.</span><span class="n">mul_left_inj</span> <span class="o">(</span><span class="bp">@</span><span class="n">two_ne_zero&#39;</span> <span class="n">‚ÑÇ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)],</span>
  <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">mul_sub</span><span class="o">,</span> <span class="n">sub_mul</span><span class="o">,</span> <span class="n">exp_add</span><span class="o">,</span> <span class="n">div_mul_div</span><span class="o">,</span>
    <span class="n">div_add_div_same</span><span class="o">,</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="o">(</span><span class="n">div_div_eq_div_mul</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span><span class="bp">.</span><span class="n">symm</span><span class="o">,</span>
    <span class="n">mul_div_cancel&#39;</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">two_ne_zero&#39;</span> <span class="n">‚ÑÇ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span> <span class="n">sin</span><span class="o">,</span> <span class="n">cos</span><span class="o">],</span>
  <span class="n">apply</span> <span class="n">complex</span><span class="bp">.</span><span class="n">ext</span><span class="bp">;</span> <span class="n">simp</span> <span class="o">[</span><span class="n">mul_add</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">exp_add</span><span class="o">]</span><span class="bp">;</span> <span class="n">ring</span>
<span class="kn">end</span>
</pre></div>


<p>Times out at -T50000.</p>

<a name="165881328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165881328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165881328">Mario Carneiro (May 17 2019 at 08:17)</a>:</h4>
<p>This one is a bit perplexing. Consider the following proof of <code>sin_add</code>:</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">two_sin</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">sin</span> <span class="n">x</span> <span class="bp">=</span> <span class="o">(</span><span class="n">exp</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span> <span class="bp">*</span> <span class="n">I</span><span class="o">)</span> <span class="bp">-</span> <span class="n">exp</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">I</span><span class="o">))</span> <span class="bp">*</span> <span class="n">I</span> <span class="o">:=</span>
<span class="n">mul_div_cancel&#39;</span> <span class="bp">_</span> <span class="n">two_ne_zero&#39;</span>

<span class="kn">lemma</span> <span class="n">two_cos</span> <span class="o">:</span> <span class="mi">2</span> <span class="bp">*</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">exp</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">I</span><span class="o">)</span> <span class="bp">+</span> <span class="n">exp</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span> <span class="bp">*</span> <span class="n">I</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">mul_div_cancel&#39;</span> <span class="bp">_</span> <span class="n">two_ne_zero&#39;</span>

<span class="kn">lemma</span> <span class="n">sin_add</span> <span class="o">:</span> <span class="n">sin</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">sin</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">cos</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">sin</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">‚Üê</span> <span class="n">domain</span><span class="bp">.</span><span class="n">mul_left_inj</span> <span class="o">(</span><span class="bp">@</span><span class="n">two_ne_zero&#39;</span> <span class="n">‚ÑÇ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span> <span class="n">two_sin</span><span class="o">,</span>
      <span class="n">neg_add</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">exp_add</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">exp_add</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">,</span>
      <span class="n">mul_add</span><span class="o">,</span> <span class="err">‚Üê</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">two_sin</span><span class="o">,</span> <span class="n">mul_left_comm</span><span class="o">,</span> <span class="n">two_sin</span><span class="o">,</span>
      <span class="err">‚Üê</span> <span class="n">domain</span><span class="bp">.</span><span class="n">mul_left_inj</span> <span class="o">(</span><span class="bp">@</span><span class="n">two_ne_zero&#39;</span> <span class="n">‚ÑÇ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span> <span class="n">mul_add</span><span class="o">,</span>
      <span class="n">mul_left_comm</span><span class="o">,</span> <span class="n">two_cos</span><span class="o">,</span> <span class="err">‚Üê</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">two_cos</span><span class="o">],</span> <span class="n">ring</span>
<span class="kn">end</span>
</pre></div>


<p>The <code>rw</code> part of the proof is instantaneous (less than 150ms if you replace <code>ring</code> by <code>sorry</code>). The <code>ring</code> tactic is also fast (a fraction of a second). The kernel is also quickly able to check the proof. Yet the <em>elaborator</em> spends a whopping 30s on... something... coming from the <code>ring</code>  tactic, despite the fact that <code>ring</code> produces fully elaborated proof terms.</p>

<a name="165881647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165881647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165881647">Mario Carneiro (May 17 2019 at 08:23)</a>:</h4>
<p>Bizarrely, this takes a long time...</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">sin_add</span> <span class="o">:</span> <span class="n">sin</span> <span class="o">(</span><span class="n">x</span> <span class="bp">+</span> <span class="n">y</span><span class="o">)</span> <span class="bp">=</span> <span class="n">sin</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">cos</span> <span class="n">y</span> <span class="bp">+</span> <span class="n">cos</span> <span class="n">x</span> <span class="bp">*</span> <span class="n">sin</span> <span class="n">y</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">[</span><span class="err">‚Üê</span> <span class="n">domain</span><span class="bp">.</span><span class="n">mul_left_inj</span> <span class="o">(</span><span class="bp">@</span><span class="n">two_ne_zero&#39;</span> <span class="n">‚ÑÇ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span> <span class="n">two_sin</span><span class="o">,</span>
      <span class="n">neg_add</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">exp_add</span><span class="o">,</span> <span class="n">add_mul</span><span class="o">,</span> <span class="n">exp_add</span><span class="o">,</span> <span class="n">eq_comm</span><span class="o">,</span>
      <span class="n">mul_add</span><span class="o">,</span> <span class="err">‚Üê</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">two_sin</span><span class="o">,</span> <span class="n">mul_left_comm</span><span class="o">,</span> <span class="n">two_sin</span><span class="o">,</span>
      <span class="err">‚Üê</span> <span class="n">domain</span><span class="bp">.</span><span class="n">mul_left_inj</span> <span class="o">(</span><span class="bp">@</span><span class="n">two_ne_zero&#39;</span> <span class="n">‚ÑÇ</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">),</span> <span class="n">mul_add</span><span class="o">,</span>
      <span class="n">mul_left_comm</span><span class="o">,</span> <span class="n">two_cos</span><span class="o">,</span> <span class="err">‚Üê</span> <span class="n">mul_assoc</span><span class="o">,</span> <span class="n">two_cos</span><span class="o">],</span>
  <span class="n">generalize</span><span class="o">:</span> <span class="n">exp</span> <span class="o">(</span><span class="n">x</span> <span class="bp">*</span> <span class="n">I</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a</span><span class="o">,</span> <span class="n">generalize</span><span class="o">:</span> <span class="n">exp</span> <span class="o">(</span><span class="bp">-</span><span class="n">x</span> <span class="bp">*</span> <span class="n">I</span><span class="o">)</span> <span class="bp">=</span> <span class="n">b</span><span class="o">,</span>
  <span class="n">generalize</span><span class="o">:</span> <span class="n">exp</span> <span class="o">(</span><span class="n">y</span> <span class="bp">*</span> <span class="n">I</span><span class="o">)</span> <span class="bp">=</span> <span class="n">c</span><span class="o">,</span> <span class="n">generalize</span><span class="o">:</span> <span class="n">exp</span> <span class="o">(</span><span class="bp">-</span><span class="n">y</span> <span class="bp">*</span> <span class="n">I</span><span class="o">)</span> <span class="bp">=</span> <span class="n">d</span><span class="o">,</span>
  <span class="n">ring</span>
<span class="kn">end</span>
</pre></div>


<p>because <code>generalize</code> takes 6s</p>

<a name="165882367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165882367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165882367">Kevin Buzzard (May 17 2019 at 08:35)</a>:</h4>
<p>I'm glad that this slightly frivolous challenge is throwing up interesting questions!</p>

<a name="165891888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165891888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165891888">Rob Lewis (May 17 2019 at 11:32)</a>:</h4>
<blockquote>
<p>The <code>rw</code> part of the proof is instantaneous (less than 150ms if you replace <code>ring</code> by <code>sorry</code>). The <code>ring</code> tactic is also fast (a fraction of a second). The kernel is also quickly able to check the proof. Yet the <em>elaborator</em> spends a whopping 30s on... something... coming from the <code>ring</code>  tactic, despite the fact that <code>ring</code> produces fully elaborated proof terms.</p>
</blockquote>
<p>This is really strange. There's something going on in the <code>is_def_eq</code> call in <code>add_atom</code>. The profiler says <code>ring</code> is spending 6 seconds there. But each call is a fraction of a millisecond and there are only a couple dozen calls.</p>

<a name="165891918"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165891918" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165891918">Rob Lewis (May 17 2019 at 11:33)</a>:</h4>
<p>I used this to profile:</p>
<div class="codehilite"><pre><span></span><span class="n">meta</span> <span class="n">def</span> <span class="n">time_defeq</span> <span class="o">(</span><span class="n">e</span> <span class="n">e&#39;</span> <span class="o">:</span> <span class="n">expr</span><span class="o">)</span> <span class="o">:</span> <span class="n">tactic</span> <span class="n">unit</span> <span class="o">:=</span>
<span class="n">do</span> <span class="n">pe</span> <span class="err">‚Üê</span> <span class="n">pp</span> <span class="n">e</span><span class="o">,</span>
   <span class="n">pe&#39;</span> <span class="err">‚Üê</span> <span class="n">pp</span> <span class="n">e&#39;</span><span class="o">,</span>
   <span class="n">timeit</span> <span class="o">(</span><span class="s2">&quot;defeq</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">pe</span> <span class="bp">++</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="bp">++</span> <span class="n">to_string</span> <span class="n">pe&#39;</span><span class="bp">++</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">sleep</span> <span class="mi">1</span> <span class="bp">&gt;&gt;</span> <span class="n">is_def_eq</span> <span class="n">e</span> <span class="n">e&#39;</span><span class="o">)</span>
</pre></div>


<p><code>ring</code> spends 6500 ms in <code>time_defeq</code>, 18 in <code>pp</code>, and 1 in <code>timeit</code>.</p>

<a name="165892003"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892003" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892003">Rob Lewis (May 17 2019 at 11:35)</a>:</h4>
<p>Hmm, but this profiling is wrong, increasing the sleep time doesn't change the profile time of <code>timeit</code>?</p>

<a name="165892285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892285">Keeley Hoek (May 17 2019 at 11:40)</a>:</h4>
<p>ah, <code>timeit</code> doesn't time tactics</p>

<a name="165892289"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892289" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892289">Keeley Hoek (May 17 2019 at 11:40)</a>:</h4>
<p>I think you're timing how long it takes to build the monad or something</p>

<a name="165892293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892293">Keeley Hoek (May 17 2019 at 11:40)</a>:</h4>
<p>(I think)</p>

<a name="165892303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892303">Keeley Hoek (May 17 2019 at 11:41)</a>:</h4>
<p>Isn't there a tactic version</p>

<a name="165892318"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892318" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892318">Rob Lewis (May 17 2019 at 11:41)</a>:</h4>
<p>You're right, it's <code>timetac</code>, not <code>timeit</code>. Getting my timers mixed up.</p>

<a name="165892467"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892467" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892467">Rob Lewis (May 17 2019 at 11:44)</a>:</h4>
<p>Would it be safe to set <code>complex.exp</code> to be irreducible at the end of <code>complex/exponential.lean</code>?</p>

<a name="165892478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892478">Rob Lewis (May 17 2019 at 11:44)</a>:</h4>
<p>This is the culprit. <code>is_def_eq</code> is unfolding that and getting lost.</p>

<a name="165892483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892483">Mario Carneiro (May 17 2019 at 11:44)</a>:</h4>
<p>yeah, that makes sense</p>

<a name="165892502"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892502" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892502">Mario Carneiro (May 17 2019 at 11:45)</a>:</h4>
<p>We should probably back off on <code>is_def_eq</code> as well though</p>

<a name="165892518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892518">Mario Carneiro (May 17 2019 at 11:45)</a>:</h4>
<p>use some reducibility setting</p>

<a name="165892721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165892721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165892721">Rob Lewis (May 17 2019 at 11:48)</a>:</h4>
<p>I'm not sure if syntactic eq is enough there, it might be. But I guess a weaker <code>is_def_eq</code> probably is.</p>

<a name="165893518"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165893518" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165893518">Mario Carneiro (May 17 2019 at 11:57)</a>:</h4>
<p>it is enough for this goal, but of course not for some goals</p>

<a name="165893527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165893527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165893527">Rob Lewis (May 17 2019 at 11:57)</a>:</h4>
<p>Hmm, no, this goes back to the discussion we had a few months ago about <code>ring</code> and <code>linarith</code> handling defeq atoms. Weakening that check means <code>linarith</code> fails to prove <code>id x ‚â• x</code>.</p>

<a name="165893618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165893618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165893618">Mario Carneiro (May 17 2019 at 11:58)</a>:</h4>
<p>but I definitely want to avoid a cost for unfolding defeq when it's not even necessary. <code>assumption</code> has the same problem</p>

<a name="165893703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165893703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165893703">Mario Carneiro (May 17 2019 at 11:59)</a>:</h4>
<p>it's triggering because it wants to find out if <code>exp x =?= exp (-x)</code> and other variations</p>

<a name="165893838"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165893838" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165893838">Rob Lewis (May 17 2019 at 12:00)</a>:</h4>
<p>Instead of using <code>is_def_eq</code> less, maybe we should be marking more things <code>irreducible</code>.</p>

<a name="165893863"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165893863" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165893863">Mario Carneiro (May 17 2019 at 12:00)</a>:</h4>
<p>This is what reducibility settings are for</p>

<a name="165893881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165893881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165893881">Mario Carneiro (May 17 2019 at 12:00)</a>:</h4>
<p>like how <code>rw</code> tries <code>refl</code> but not really hard in case it's not true</p>

<a name="165894094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165894094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165894094">Mario Carneiro (May 17 2019 at 12:02)</a>:</h4>
<p>I guess that's not enough to get <code>id x &gt;= x</code> though</p>

<a name="165894116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165894116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165894116">Mario Carneiro (May 17 2019 at 12:03)</a>:</h4>
<p>because <code>id</code> is semireducible</p>

<a name="165894254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165894254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165894254">Mario Carneiro (May 17 2019 at 12:04)</a>:</h4>
<p>how about giving <code>linarith</code> and <code>ring</code> a reducibility config option? I think the default should be unfold reducible</p>

<a name="165894366"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165894366" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165894366">Rob Lewis (May 17 2019 at 12:05)</a>:</h4>
<p>Exactly. Same thing in the example here: <a href="#narrow/stream/144837-PR-reviews/topic/.23878.20.20remove.20dependencies" title="#narrow/stream/144837-PR-reviews/topic/.23878.20.20remove.20dependencies">https://leanprover.zulipchat.com/#narrow/stream/144837-PR-reviews/topic/.23878.20.20remove.20dependencies</a> . Matching up to defeq lets <code>ring</code> and <code>linarith</code> unify two different coercions, which is sensible to do. But I'm pretty sure those coercions are semireducible.</p>

<a name="165894376"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165894376" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165894376">Rob Lewis (May 17 2019 at 12:05)</a>:</h4>
<p>That would work.</p>

<a name="165894432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165894432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165894432">Rob Lewis (May 17 2019 at 12:06)</a>:</h4>
<p>Linarith already has a bunch of config options. I worry this one would be pretty obscure.</p>

<a name="165894462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165894462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165894462">Rob Lewis (May 17 2019 at 12:07)</a>:</h4>
<p>On the other hand, they were both using syntactic eq for a while with no issues. It wouldn't be a big loss to go half a step back and add a config option.</p>

<a name="165894625"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165894625" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165894625">Rob Lewis (May 17 2019 at 12:08)</a>:</h4>
<p>Regardless, I think we should also be a bit more aggressive about marking things irreducible.</p>

<a name="165911267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165911267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165911267">Kevin Buzzard (May 17 2019 at 15:46)</a>:</h4>
<p>So this one has actually now been fixed by the latest PR! Nice!</p>
<p>The next one is I think one of <span class="user-mention" data-user-id="110032">@Reid Barton</span> 's:</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">stone_cech</span><span class="bp">.</span><span class="n">t2_space</span> <span class="o">:</span> <span class="n">t2_space</span> <span class="o">(</span><span class="n">stone_cech</span> <span class="n">Œ±</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">t2_iff_ultrafilter</span><span class="o">,</span>
  <span class="n">rintros</span> <span class="n">g</span> <span class="bp">‚ü®</span><span class="n">x</span><span class="bp">‚ü©</span> <span class="bp">‚ü®</span><span class="n">y</span><span class="bp">‚ü©</span> <span class="n">u</span> <span class="n">gx</span> <span class="n">gy</span><span class="o">,</span>
  <span class="n">apply</span> <span class="n">quotient</span><span class="bp">.</span><span class="n">sound</span><span class="o">,</span>
  <span class="n">intros</span> <span class="n">Œ≥</span> <span class="n">tŒ≥</span> <span class="n">h‚ÇÅ</span> <span class="n">h‚ÇÇ</span> <span class="n">f</span> <span class="n">hf</span><span class="o">,</span>
  <span class="n">resetI</span><span class="o">,</span>
  <span class="n">change</span> <span class="n">stone_cech_extend</span> <span class="n">hf</span> <span class="err">‚ü¶</span><span class="n">x</span><span class="err">‚üß</span> <span class="bp">=</span> <span class="n">stone_cech_extend</span> <span class="n">hf</span> <span class="err">‚ü¶</span><span class="n">y</span><span class="err">‚üß</span><span class="o">,</span>
  <span class="n">refine</span> <span class="n">tendsto_nhds_unique</span> <span class="n">u</span><span class="bp">.</span><span class="mi">1</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span>
  <span class="o">{</span> <span class="n">exact</span> <span class="n">stone_cech_extend</span> <span class="n">hf</span> <span class="o">},</span>
  <span class="n">all_goals</span>
  <span class="o">{</span> <span class="n">refine</span> <span class="n">le_trans</span> <span class="o">(</span><span class="n">map_mono</span> <span class="bp">_</span><span class="o">)</span> <span class="o">((</span><span class="n">continuous_stone_cech_extend</span> <span class="n">hf</span><span class="o">)</span><span class="bp">.</span><span class="n">tendsto</span> <span class="bp">_</span><span class="o">),</span>
    <span class="n">assumption</span> <span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>Times out at -T50000. It's in <code>src/topology/stone_cech.lean</code>, <a href="https://github.com/leanprover-community/mathlib/blob/f633c948ff523b9a47b3b41bc1dc0b1b4b2be5c4/src/topology/stone_cech.lean#L253" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/f633c948ff523b9a47b3b41bc1dc0b1b4b2be5c4/src/topology/stone_cech.lean#L253">line 253</a>.</p>

<a name="165911320"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165911320" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165911320">Reid Barton (May 17 2019 at 15:47)</a>:</h4>
<p>I think Patrick sent me a faster version of this proof at some point, let me check whether it got merged...</p>

<a name="165911620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165911620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165911620">Reid Barton (May 17 2019 at 15:50)</a>:</h4>
<p>Indeed this is still the old version</p>

<a name="165911914"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165911914" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165911914">Kevin Buzzard (May 17 2019 at 15:53)</a>:</h4>
<p>Did Patrick figure out why it was slow?</p>

<a name="165912091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165912091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165912091">Kevin Buzzard (May 17 2019 at 15:55)</a>:</h4>
<p>I think it's kind of important that we understand the various reasons that code ends up running slowly, because if we're not careful then slow code can turn into code which doesn't compile.</p>

<a name="165912131"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165912131" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165912131">Reid Barton (May 17 2019 at 15:55)</a>:</h4>
<p>I don't know.</p>

<a name="165912285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165912285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165912285">Rob Lewis (May 17 2019 at 15:57)</a>:</h4>
<p>The problem is solving the very last goal <code>g ‚â§ nhds ‚ü¶y‚üß</code>, the second branch of the <code>all_goals</code>. It succeeds with the assumption <code>gy : g ‚â§ nhds (quot.mk setoid.r y)</code> but first it tries <code>gx : g ‚â§ nhds (quot.mk setoid.r x)</code> and takes ages to fail.</p>

<a name="165912459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/-T50000%20challenge/near/165912459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113488general/87130T50000challenge.html#165912459">Rob Lewis (May 17 2019 at 15:59)</a>:</h4>
<p>Did we not have a variant of <code>assumption</code> that takes a reducibility setting?</p>


{% endraw %}
