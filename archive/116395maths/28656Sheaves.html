---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/28656Sheaves.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html">Sheaves</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="167766087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167766087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167766087">Kevin Buzzard (Jun 10 2019 at 14:55)</a>:</h4>
<p>Kenny and I have been playing about with the schemes repo; I've been trying to glue sheaves together on subspaces. I realise when doing this work that there are big design decisions that need to be made. A sheaf in maths is just some assignment of a type to each open subset of a topological space, modulo a bit of extra structure and some axioms. I'd been working with <code>opens X</code> but now I'm working with sheaves on open subsets of X I am forever wrestling with <code>opens U</code> with <code>U : opens X</code> and having to dig through subtypes of subtypes etc. Sure I could write a bunch of API for <code>opens U</code>. On the other hand I could just try and avoid subtypes completely -- this was <span class="user-mention" data-user-id="110064">@Kenny Lau</span> 's suggestion -- and even go so far as to define a sheaf on an open subspace of a topological space just to be pair (U,F) where U is open, F is a sheaf on all of X, and the values of F are irrelevant if we evaluate on a set that isn't an open subset of U. This seems to be leading to some sort of "how to do this sort of thing optimally in dependent type theory" conversation and it reminds me a lot of <span class="user-mention" data-user-id="110172">@Assia Mahboubi</span> using subgroups instead of groups in Coq (the rooster and the butterfly) and so on. Doing it like this, the restriction of F to an open subspace is very very easy indeed.</p>
<p>On the other hand, my plan has always been to use <span class="user-mention" data-user-id="110087">@Scott Morrison</span> 's category theory work to do sheaves, as this is the language which is used in practice by mathematicians. However in some sense I now feel that this would drift even further from the "very easy" approach and force me to write even more API. I do not object to writing more API. But I'm just confused about the best approach to take. Scott's approach seems to be far closer to what a mathematician would do, and Kenny's to what a computer scientist would do. I don't know which one I want to be though, in this context. I somehow get the feeling that it matters though.</p>

<a name="167766197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Sheaves/near/167766197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/28656Sheaves.html#167766197">Kenny Lau (Jun 10 2019 at 14:56)</a>:</h4>
<p>I'm proud of my construction :P</p>


{% endraw %}
