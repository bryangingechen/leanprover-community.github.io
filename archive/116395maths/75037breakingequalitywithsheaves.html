---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/75037breakingequalitywithsheaves.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html">breaking equality with sheaves</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="168696896"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168696896" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168696896">Kevin Buzzard (Jun 21 2019 at 16:47)</a>:</h4>
<p>A sheaf of types <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">F</mi></mrow></mrow><annotation encoding="application/x-tex">\mathcal{F}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span></span></span></span> on a topological space <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> is, for every open set <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">V\subseteq X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>, a type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi mathvariant="script">F</mi></mrow><mo>(</mo><mi>V</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\mathcal{F}(V)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mclose">)</span></span></span></span>, plus some extra data and some axioms.</p>
<p>As part of the schemes project we would like to glue sheaves on open subsets. In short, given an open cover <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> and sheaves on each <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> which are compatible in some precise way, one can glue the sheaves together to get a sheaf on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>. I tried to formalise this the naive way, and formalising the compatibility was a real nightmare, because a sheaf is on a topological space so I had to really work with types <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and I had to constantly be moving between the type <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">U_i\cap U_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span>, the open subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">U_i\cap U_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, the open subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">U_i\cap U_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> of $U_j$$ and the open subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub><mo>∩</mo><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">U_i\cap U_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>; all of these four objects show up. One of the compatibilities one needs is a "cocycle identity" which involves three subsets <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">U_j</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">U_k</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span>, and it was pretty horrible.</p>
<p>Kenny suggested a completely insane way around this. He defined a sheaf on an open subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span></span></span></span> of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> to simply be a sheaf on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>! It is true that given a sheaf on an open subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi><mo>⊆</mo><mi>X</mi></mrow><annotation encoding="application/x-tex">U\subseteq X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> one can push it forward to get a sheaf on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span>, given a sheaf on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> one can pull it back to get a sheaf on an open subset <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span></span></span></span>, but it is also true that two sheaves on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.07847em;">X</span></span></span></span> which are not equal (resp isomorphic), can become equal (resp isomorphic) when restricted to <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span></span></span></span>. </p>
<p>In short, Kenny has proposed a definition of a sheaf on <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span></span></span></span> for which Lean's <code>=</code> type is <em>wrong</em> -- it does not correctly capture the notion of equality of sheaves. </p>
<p>Kenny went on to define morphisms of sheaves-on-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span></span></span></span> (using his definition) and a notion of <code>equiv</code> which is the correct definition. So we do have the correct notion of isomorphism, and the sheaves-on-<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.68333em;vertical-align:0em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.10903em;">U</span></span></span></span> form a category which is equivalent to the correct category. This category has the extraordinary (to me) property that the notion of equality on it is incorrect. However I have just formalised the statement of the universal property which the glued sheaf has to satisfy (its restriction to the <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>U</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">U_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> should be isomorphic to the sheaf <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="script">F</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\mathcal{F}_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord"><span class="mord mathcal" style="margin-right:0.09931em;">F</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> we started with -- <em>not</em> equal to it) and at least the statement looks fine.</p>
<p>Am I going to run into trouble later?</p>
<p>One way of thinking about this is that a sheaf is a functor, so we have made some functor category, and we are interested in restricting this functor to a subcategory to get a new functor category, and I want to define it to be the actual restriction, but Kenny has just defined it to be the original functor and has basically said screw equality.</p>

<a name="168701236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168701236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168701236">Kenny Lau (Jun 21 2019 at 17:47)</a>:</h4>
<p>we don't ever want to say that two (at least set-valued-) sheaves are equal right</p>

<a name="168701920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168701920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168701920">Kevin Buzzard (Jun 21 2019 at 17:56)</a>:</h4>
<p>I guess that's my question. They are two terms of some type so I thought that equality was ok. But they involve some dependent type so maybe it's not ok</p>

<a name="168701997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168701997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168701997">Kevin Buzzard (Jun 21 2019 at 17:57)</a>:</h4>
<p>You can prove that if two sheaves are equal when restricted to an open subset then they are equal. This is very counterintuitive to me</p>

<a name="168702026"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168702026" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168702026">Kevin Buzzard (Jun 21 2019 at 17:57)</a>:</h4>
<p>Perhaps your argument is that equality of sheaves is never ok</p>

<a name="168702043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168702043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168702043">Kenny Lau (Jun 21 2019 at 17:57)</a>:</h4>
<p>that is indeed my argument</p>

<a name="168702102"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168702102" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168702102">Kevin Buzzard (Jun 21 2019 at 17:58)</a>:</h4>
<p>It is not true that if two sheaves are the same when restricted to an open subset then they are the same</p>

<a name="168702120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168702120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168702120">Kevin Buzzard (Jun 21 2019 at 17:58)</a>:</h4>
<p>But I have become more and more confused about what "the same" means recently</p>

<a name="168702163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168702163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168702163">Kevin Buzzard (Jun 21 2019 at 17:59)</a>:</h4>
<p>I find this very surprising. Here we have an equality on a type which is literally not correct -- it is too weak</p>

<a name="168702383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168702383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168702383">Kevin Buzzard (Jun 21 2019 at 18:02)</a>:</h4>
<p>My rule of thumb was that <code>x = y</code> was not good if <code>x : Sort u</code> but <code>x = y</code> was OK if <code>x : T</code> with <code>T : Type u</code>. This is a counterexample.</p>

<a name="168704673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168704673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168704673">Sebastien Gouezel (Jun 21 2019 at 18:30)</a>:</h4>
<p>I encountered a similar situation with manifolds. The basic objects is charts, i.e., local homeomorphisms (defined on their source), that one keeps composing (thereby restricting the sources by taking the intersection of the source of the first guy and the preimage of the source of the second guy). There are (at least) three ways to formalize them:</p>
<ul>
<li>(1) use a homeomorphism defined on a subtype</li>
<li>(2) use a map taking values in <code>option ...</code>, which is none outside of the source</li>
<li>(3) use a map defined on all the space, that happens to be a homeomorphism on a subset of the space that you call <code>source</code>, and do not care about what this map does outside of <code>source</code>.</li>
</ul>
<p>(1) is a nightmare from the point of view of intersections of subtypes just as what you have for sheaves. (2) is a nightmare when you want to define regularity classes because you always need to distinguish between points in the genuine space and points in <code>option</code>. (3) looks crazy, but in fact it works very well. The only drawback is that you want to say that two local homeomorphisms are "equal" if they have the same source and coincide there. This is an <code>equiv</code>, that I introduced. But in fact it turns out that in 99% of the proofs I don't need to talk about equality of local homeomorphisms, I just need to compose them. So it works fine. And I think it more or less corresponds to Kenny's suggestion for sheaves.</p>
<p>There was already a discussion on the chat where people told me to use (1) or (2) instead. And I agree that from a mathematical point of view this is the right thing to do, but from an implementation point of view (3) simply works better. Yesterday, I asked Assia Mahboubi , who has done way more formalization using DTT than anyone on this chat, about what to choose between (1), (2), (3), and her reaction was: (3) is clearly better.</p>

<a name="168704742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168704742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168704742">Kevin Buzzard (Jun 21 2019 at 18:31)</a>:</h4>
<p>OK I'm convinced :-)</p>

<a name="168704862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168704862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168704862">Kevin Buzzard (Jun 21 2019 at 18:33)</a>:</h4>
<p>In fact I was already half-convinced when I realised that I could formalise the glueing lemma and the statement of its universal property. I guess what I am half-worried about is rewriting. If we lose the true meaning of <code>=</code> then we lose the ability to rewrite.</p>
<p>I will try and formalise the proof of the glueing lemma over the weekend, this will be a very good test case I think.</p>

<a name="168705381"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168705381" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168705381">Sebastien Gouezel (Jun 21 2019 at 18:39)</a>:</h4>
<p>Yes, you can not rewrite. But if you have enough lemmas saying that, under the assumption that two objects are "equivalent", then some property holds, then you can rewrite using these lemmas.</p>

<a name="168705484"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168705484" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168705484">Kevin Buzzard (Jun 21 2019 at 18:40)</a>:</h4>
<p>I do not yet have a feeling as to how much of a handicap this will be.</p>

<a name="168705546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168705546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168705546">Sebastien Gouezel (Jun 21 2019 at 18:41)</a>:</h4>
<p>I think it will be very interesting to hear how your proof of the glueing lemma goes.</p>

<a name="168716480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168716480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168716480">Mario Carneiro (Jun 21 2019 at 21:03)</a>:</h4>
<p>There is a way to recover equality while still using sheaves on X. There is a condition you can put on your sheaf such that pushing back to U and then forward to X recovers the same sheaf</p>

<a name="168717921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168717921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168717921">Kevin Buzzard (Jun 21 2019 at 21:24)</a>:</h4>
<p>Yes you're right; I discussed this privately with Kenny. The condition is that for all V open in X, the restriction map from F(V) to F(V intersect U) is an isomorphism (in the appropriate category). Here are several comments about this idea.</p>
<p>Firstly, we have a restriction map from F(V) to F(V intersect U), but we have no inverse, so one would have to make a choice about either just saying it's a bijection, or demanding an inverse. This seemed a bit weird.</p>
<p>Secondly, if we do this then sheaves on U are a subtype of sheaves on X, so we get the right equality but we'd have to constantly be carrying round and checking these proofs. </p>
<p>Thirdly, I can see that my philosophy is wrong. If <code>x, y : T</code> with <code>T : Type u</code> then sometimes it's fine to talk about <code>x = y</code> (e.g. if T=nat). If <code>x, y : Type u</code> then in general I can see that it is not really the right thing to do in dependent type theory, and I am quite happy with the weaker concept of being isomorphic, although I still think that there should be a whole bunch of automation which is not currently in Lean which will enable me to rewrite along isomorphisms in certain cases, with auto-generated proofs. However I do see that equality of two types is a bit weird. With the sheaf setting, equality really does look weird, because here <code>x, y : T</code> and <code>T : Type u</code> but T is a structure which has a dependent type as a field, and equality of x and y would imply equality of those dependent functions, which by functional extensionality boils down to equality of types again. This does not seem to be a good idea in type theory. If we go with the philosophy that equality of types is to be avoided, then equality of these particular terms should also I think be avoided.</p>
<p>Another way to recover equality is simply to quotient out by the correct notion. Whether this comes out nicer or more nastily than the subtype approach Mario is suggesting -- who knows. But currently my plan is to go with Kenny's crazy idea, because Sebastian and Assia seem to think that it's not so crazy after all, and I am open to the suggestion that losing the ability to rewrite will not hurt me. After all, if I have sheaves F_i on U_i and glue them together to get a sheaf F on X, the universal property really is <em>not</em> the statement that the restriction of F to U_i equals F_i, it is the data of an isomorphism.</p>

<a name="168719290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719290">Mario Carneiro (Jun 21 2019 at 21:45)</a>:</h4>
<p>I agree that equality of sheafs should be avoided. What I want to avoid is "random" data inside a sheaf</p>

<a name="168719373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719373">Kevin Buzzard (Jun 21 2019 at 21:47)</a>:</h4>
<p>So currently we have random data. I agree that there are several ways of getting rid of the randomness, including replacing sheaves on X by either a sub or a quotient. But each of these is more inconvenient to work with.</p>

<a name="168719416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719416">Kevin Buzzard (Jun 21 2019 at 21:48)</a>:</h4>
<p>I thought that randomness was everywhere in topology in Lean, with functions being randomly extended. Even 1/ 0  = 0 is a random choice.</p>

<a name="168719417"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719417" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719417">Mario Carneiro (Jun 21 2019 at 21:48)</a>:</h4>
<p>A similar sort of example is subfilters. A filter on X is not the same as a filter on a subset S, but given a filter on a subset there is a canonical way to extend it to a filter, and restrict any filter to a subset, and the filters that are extended subset filters are exactly those such that <code>S \in F</code></p>

<a name="168719486"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719486" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719486">Mario Carneiro (Jun 21 2019 at 21:48)</a>:</h4>
<p>random meaning not uniquely defined</p>

<a name="168719552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719552">Kevin Buzzard (Jun 21 2019 at 21:49)</a>:</h4>
<p>If I was buying into your idea I think I would go with the subtype. But then there's the question of how you say that the map F(V) -&gt; F(U intersect V) is an isomorphism. Do you just state that there exists an inverse, or do you give it?</p>

<a name="168719630"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719630" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719630">Kevin Buzzard (Jun 21 2019 at 21:50)</a>:</h4>
<p>Another alternative is extension by zero. You just define F(V) to be zero if V is not a subset of U, or whatever the appropriate initial object is</p>

<a name="168719664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719664">Mario Carneiro (Jun 21 2019 at 21:51)</a>:</h4>
<p>You said there is a way to go from a sheaf on U to one on X and back. How does that work? what map F(V) -&gt; F(U \cap V) does it give you?</p>

<a name="168719680"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719680" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719680">Kevin Buzzard (Jun 21 2019 at 21:51)</a>:</h4>
<p>There is more than one way.</p>

<a name="168719688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719688">Kevin Buzzard (Jun 21 2019 at 21:51)</a>:</h4>
<p>You don't know about the 6 functor formalism? ;-)</p>

<a name="168719703"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719703" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719703">Kevin Buzzard (Jun 21 2019 at 21:52)</a>:</h4>
<p><a href="https://en.wikipedia.org/wiki/Six_operations" target="_blank" title="https://en.wikipedia.org/wiki/Six_operations">https://en.wikipedia.org/wiki/Six_operations</a></p>

<a name="168719748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719748">Mario Carneiro (Jun 21 2019 at 21:52)</a>:</h4>
<p>mathematician naming at its best</p>

<a name="168719754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719754">Kevin Buzzard (Jun 21 2019 at 21:52)</a>:</h4>
<p>At least there are 6 of them.</p>

<a name="168719769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719769">Kevin Buzzard (Jun 21 2019 at 21:52)</a>:</h4>
<p>You can see how to get from a sheaf on X to a sheaf on U, right? This is just some kind of forgetful functor.</p>

<a name="168719785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719785">Kevin Buzzard (Jun 21 2019 at 21:52)</a>:</h4>
<p>Well guess what: in many situations this has both a left and a right adjoint, which typically do not agree.</p>

<a name="168719816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719816">Mario Carneiro (Jun 21 2019 at 21:53)</a>:</h4>
<p>If G is the sheaf on X, then it is defined by G(V) = F(U cap V), yes?</p>

<a name="168719830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719830">Kevin Buzzard (Jun 21 2019 at 21:53)</a>:</h4>
<p>That's one of the ways of going from sheaves on U to sheaves on X, yes.</p>

<a name="168719849"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719849" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719849">Mario Carneiro (Jun 21 2019 at 21:53)</a>:</h4>
<p>oh it's backwards?</p>

<a name="168719850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719850">Kevin Buzzard (Jun 21 2019 at 21:53)</a>:</h4>
<p>The other way is G(V)=0 if V is not a subset of U, and G(V)=F(V)otherwise.</p>

<a name="168719913"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719913" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719913">Mario Carneiro (Jun 21 2019 at 21:54)</a>:</h4>
<p>I want the original one you said, sheaf on U -&gt; sheaf on X</p>

<a name="168719921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719921">Kevin Buzzard (Jun 21 2019 at 21:54)</a>:</h4>
<p>That one is just G(V)=F(V)</p>

<a name="168719930"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719930" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719930">Kevin Buzzard (Jun 21 2019 at 21:55)</a>:</h4>
<p>wait, notation</p>

<a name="168719963"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719963" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719963">Kevin Buzzard (Jun 21 2019 at 21:55)</a>:</h4>
<p>There are two ways of going from U to X. There is one way of going from X to U. There are two theorems that say something is adjoint to something else.</p>

<a name="168719975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719975">Kevin Buzzard (Jun 21 2019 at 21:55)</a>:</h4>
<p>The trivial thing is going from X to U. U is a subset of X here.</p>

<a name="168719978"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168719978" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168719978">Mario Carneiro (Jun 21 2019 at 21:55)</a>:</h4>
<p>But if G is the newly defined sheaf on X, shouldn't it take an open set in X? so F(V) doesn't necessarily work</p>

<a name="168720050"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720050" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720050">Kevin Buzzard (Jun 21 2019 at 21:56)</a>:</h4>
<p>The non-trivial things are going from sheaves on U to sheaves on X. One way is G(V)=F(V intersect U). The other way is G(V)=F(V) if this makes sense and 0 otherwise</p>

<a name="168720073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720073">Kevin Buzzard (Jun 21 2019 at 21:57)</a>:</h4>
<p>I am so used to thinking about etale sheaves, I am not even sure if this is right for sheaves on a top space.</p>

<a name="168720077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720077">Kevin Buzzard (Jun 21 2019 at 21:57)</a>:</h4>
<p>i might need to go and check the sheaf axiom. If it doesn't work, I might have to sheafify :-/</p>

<a name="168720108"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720108" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720108">Mario Carneiro (Jun 21 2019 at 21:58)</a>:</h4>
<p>where 0 is an empty type?</p>

<a name="168720142"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720142" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720142">Kevin Buzzard (Jun 21 2019 at 21:58)</a>:</h4>
<p>0 is an initial object.</p>

<a name="168720149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720149">Kevin Buzzard (Jun 21 2019 at 21:58)</a>:</h4>
<p>I'm thinking about sheaves taking values in some arbitrary category really.</p>

<a name="168720156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720156">Mario Carneiro (Jun 21 2019 at 21:58)</a>:</h4>
<p>so we can't really avoid some variation here</p>

<a name="168720158"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720158" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720158">Kevin Buzzard (Jun 21 2019 at 21:58)</a>:</h4>
<p>I'm thinking about sheaves taking values in the category of abelian groups, truth be told.</p>

<a name="168720200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720200">Kevin Buzzard (Jun 21 2019 at 21:59)</a>:</h4>
<p>I think the extension by 0 is OK.</p>

<a name="168720245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720245">Kevin Buzzard (Jun 21 2019 at 22:00)</a>:</h4>
<p>It looks like the sort of thing you computer scientist would really like. "Don't know the answer? Try zero!"</p>

<a name="168720275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720275">Mario Carneiro (Jun 21 2019 at 22:00)</a>:</h4>
<p>I think that it would be best to have the actual definition be the one you started with, using subtypes, but then build an API to see them as sheafs on X</p>

<a name="168720300"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720300" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720300">Kevin Buzzard (Jun 21 2019 at 22:01)</a>:</h4>
<p>If I wanted to build an API I'd just define them as sheaves on U and then go through all the pain ;-)</p>

<a name="168720311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720311">Mario Carneiro (Jun 21 2019 at 22:01)</a>:</h4>
<p>is all this pain just to build the API?</p>

<a name="168720333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720333">Kevin Buzzard (Jun 21 2019 at 22:01)</a>:</h4>
<p>Kenny built an API for sheaves on U just being sheaves on X.</p>

<a name="168720351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720351">Kevin Buzzard (Jun 21 2019 at 22:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">sheaves</span><span class="bp">.</span><span class="n">sheaf</span>

<span class="n">universes</span> <span class="n">v</span> <span class="n">w</span> <span class="n">u₁</span> <span class="n">v₁</span> <span class="n">u</span>

<span class="kn">open</span> <span class="n">topological_space</span>

<span class="n">def</span> <span class="n">sheaf_on_opens</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">X</span>

<span class="kn">namespace</span> <span class="n">sheaf_on_opens</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">{</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">}</span>

<span class="n">def</span> <span class="kn">eval</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span> <span class="o">:=</span>
<span class="n">presheaf</span><span class="bp">.</span><span class="n">F</span> <span class="o">(</span><span class="n">sheaf</span><span class="bp">.</span><span class="n">F</span> <span class="n">F</span><span class="o">)</span> <span class="n">V</span>

<span class="n">def</span> <span class="n">res</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span>
  <span class="o">(</span><span class="n">HWU</span> <span class="o">:</span> <span class="n">W</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">HWV</span> <span class="o">:</span> <span class="n">W</span> <span class="err">⊆</span> <span class="n">V</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">V</span> <span class="n">HVU</span> <span class="bp">→</span> <span class="n">F</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">W</span> <span class="n">HWU</span> <span class="o">:=</span>
<span class="n">presheaf</span><span class="bp">.</span><span class="n">res</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">HWV</span>

<span class="n">def</span> <span class="n">res_subset</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span> <span class="n">X</span> <span class="n">V</span> <span class="o">:=</span>
<span class="n">F</span>

<span class="kn">structure</span> <span class="n">morphism</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">map</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">V</span> <span class="n">H</span> <span class="bp">→</span> <span class="n">G</span><span class="bp">.</span><span class="kn">eval</span> <span class="n">V</span> <span class="n">H</span><span class="o">)</span>
<span class="o">(</span><span class="n">commutes</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HV</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">W</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HW</span> <span class="o">:</span> <span class="n">W</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">HWV</span> <span class="o">:</span> <span class="n">W</span> <span class="err">⊆</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span><span class="o">),</span>
  <span class="n">map</span> <span class="n">W</span> <span class="n">HW</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">W</span> <span class="n">HW</span> <span class="n">HWV</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">G</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">W</span> <span class="n">HW</span> <span class="n">HWV</span> <span class="o">(</span><span class="n">map</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">x</span><span class="o">))</span>

<span class="kn">namespace</span> <span class="n">morphism</span>

<span class="kn">protected</span> <span class="n">def</span> <span class="n">id</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">F</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">V</span> <span class="n">HV</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span>
  <span class="n">commutes</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">W</span> <span class="n">HW</span> <span class="n">HWV</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">comp</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">u₁</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span>
  <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">ξ</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">H</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">x</span><span class="o">,</span> <span class="n">η</span><span class="bp">.</span><span class="n">map</span> <span class="n">V</span> <span class="n">HV</span> <span class="o">(</span><span class="n">ξ</span><span class="bp">.</span><span class="n">map</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">x</span><span class="o">),</span>
  <span class="n">commutes</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">W</span> <span class="n">HW</span> <span class="n">HWV</span> <span class="n">x</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">ξ</span><span class="bp">.</span><span class="n">commutes</span><span class="o">,</span> <span class="n">η</span><span class="bp">.</span><span class="n">commutes</span><span class="o">]</span> <span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">extensionality</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">ext</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span>
  <span class="o">{</span><span class="n">η</span> <span class="n">ξ</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">G</span><span class="o">}</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">x</span><span class="o">,</span> <span class="n">η</span><span class="bp">.</span><span class="n">map</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">ξ</span><span class="bp">.</span><span class="n">map</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">η</span> <span class="bp">=</span> <span class="n">ξ</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cases</span> <span class="n">η</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">ξ</span><span class="bp">;</span> <span class="n">congr</span><span class="bp">;</span> <span class="n">ext</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">H</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">id_comp</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">morphism</span><span class="bp">.</span><span class="n">id</span> <span class="n">G</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">η</span> <span class="bp">=</span> <span class="n">η</span> <span class="o">:=</span>
<span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_id</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">η</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">morphism</span><span class="bp">.</span><span class="n">id</span> <span class="n">F</span><span class="o">)</span> <span class="bp">=</span> <span class="n">η</span> <span class="o">:=</span>
<span class="n">ext</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">V</span> <span class="n">HV</span> <span class="n">x</span><span class="o">,</span> <span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_assoc</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">u₁</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v₁</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span>
  <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">H</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">I</span><span class="o">)</span> <span class="o">(</span><span class="n">ξ</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">χ</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">η</span><span class="bp">.</span><span class="n">comp</span> <span class="n">ξ</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="n">χ</span> <span class="bp">=</span> <span class="n">η</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">ξ</span><span class="bp">.</span><span class="n">comp</span> <span class="n">χ</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="n">def</span> <span class="n">res_subset</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span><span class="bp">.</span><span class="n">morphism</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">map</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">W</span> <span class="n">HWV</span><span class="o">,</span> <span class="n">η</span><span class="bp">.</span><span class="n">map</span> <span class="n">W</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">HWV</span> <span class="n">HVU</span><span class="o">),</span>
  <span class="n">commutes</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">S</span> <span class="n">HSV</span> <span class="n">T</span> <span class="n">HTV</span><span class="o">,</span> <span class="n">η</span><span class="bp">.</span><span class="n">commutes</span> <span class="n">S</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">HSV</span> <span class="n">HVU</span><span class="o">)</span> <span class="n">T</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="n">HTV</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">}</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">comp_res_subset</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">u₁</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span>
  <span class="o">(</span><span class="n">η</span> <span class="o">:</span> <span class="n">G</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">H</span><span class="o">)</span> <span class="o">(</span><span class="n">ξ</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">morphism</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">η</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span><span class="bp">.</span><span class="n">comp</span> <span class="o">(</span><span class="n">ξ</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">η</span><span class="bp">.</span><span class="n">comp</span> <span class="n">ξ</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">id_res_subset</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span>
  <span class="o">(</span><span class="n">morphism</span><span class="bp">.</span><span class="n">id</span> <span class="n">F</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span> <span class="bp">=</span> <span class="n">morphism</span><span class="bp">.</span><span class="n">id</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">:=</span>
<span class="n">rfl</span>

<span class="kn">end</span> <span class="n">morphism</span>

<span class="kn">structure</span> <span class="n">equiv</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">to_fun</span> <span class="o">:</span> <span class="n">morphism</span> <span class="n">F</span> <span class="n">G</span><span class="o">)</span>
<span class="o">(</span><span class="n">inv_fun</span> <span class="o">:</span> <span class="n">morphism</span> <span class="n">G</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">left_inv</span> <span class="o">:</span> <span class="n">inv_fun</span><span class="bp">.</span><span class="n">comp</span> <span class="n">to_fun</span> <span class="bp">=</span> <span class="n">morphism</span><span class="bp">.</span><span class="n">id</span> <span class="n">F</span><span class="o">)</span>
<span class="o">(</span><span class="n">right_inv</span> <span class="o">:</span> <span class="n">to_fun</span><span class="bp">.</span><span class="n">comp</span> <span class="n">inv_fun</span> <span class="bp">=</span> <span class="n">morphism</span><span class="bp">.</span><span class="n">id</span> <span class="n">G</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">equiv</span>

<span class="n">def</span> <span class="n">refl</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">F</span> <span class="n">F</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">morphism</span><span class="bp">.</span><span class="n">id</span> <span class="n">F</span><span class="o">,</span> <span class="n">morphism</span><span class="bp">.</span><span class="n">id</span> <span class="n">F</span><span class="o">,</span> <span class="n">rfl</span><span class="o">,</span> <span class="n">rfl</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">symm</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">F</span> <span class="n">G</span><span class="o">)</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">G</span> <span class="n">F</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">e</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="mi">4</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="mi">3</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">trans</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">H</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">u₁</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span>
  <span class="o">(</span><span class="n">e₁</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">F</span> <span class="n">G</span><span class="o">)</span> <span class="o">(</span><span class="n">e₂</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">G</span> <span class="n">H</span><span class="o">)</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">F</span> <span class="n">H</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">e₂</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">comp</span> <span class="n">e₁</span><span class="bp">.</span><span class="mi">1</span><span class="o">,</span> <span class="n">e₁</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">comp</span> <span class="n">e₂</span><span class="bp">.</span><span class="mi">2</span><span class="o">,</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">morphism</span><span class="bp">.</span><span class="n">comp_assoc</span><span class="o">,</span> <span class="err">←</span> <span class="n">e₂</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">comp_assoc</span><span class="o">,</span> <span class="n">e₂</span><span class="bp">.</span><span class="mi">3</span><span class="o">,</span> <span class="n">morphism</span><span class="bp">.</span><span class="n">id_comp</span><span class="o">,</span> <span class="n">e₁</span><span class="bp">.</span><span class="mi">3</span><span class="o">],</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">morphism</span><span class="bp">.</span><span class="n">comp_assoc</span><span class="o">,</span> <span class="err">←</span> <span class="n">e₁</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">comp_assoc</span><span class="o">,</span> <span class="n">e₁</span><span class="bp">.</span><span class="mi">4</span><span class="o">,</span> <span class="n">morphism</span><span class="bp">.</span><span class="n">id_comp</span><span class="o">,</span> <span class="n">e₂</span><span class="bp">.</span><span class="mi">4</span><span class="o">]</span><span class="bp">⟩</span>

<span class="n">def</span> <span class="n">res_subset</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">{</span><span class="n">G</span> <span class="o">:</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">w</span><span class="o">}</span> <span class="n">X</span> <span class="n">U</span><span class="o">}</span> <span class="o">(</span><span class="n">e</span> <span class="o">:</span> <span class="n">equiv</span> <span class="n">F</span> <span class="n">G</span><span class="o">)</span>
  <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="err">⊆</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">equiv</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">(</span><span class="n">G</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">e</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="mi">2</span><span class="bp">.</span><span class="n">res_subset</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">,</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">morphism</span><span class="bp">.</span><span class="n">comp_res_subset</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="mi">3</span><span class="o">,</span> <span class="n">morphism</span><span class="bp">.</span><span class="n">id_res_subset</span><span class="o">],</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">morphism</span><span class="bp">.</span><span class="n">comp_res_subset</span><span class="o">,</span> <span class="n">e</span><span class="bp">.</span><span class="mi">4</span><span class="o">,</span> <span class="n">morphism</span><span class="bp">.</span><span class="n">id_res_subset</span><span class="o">]</span><span class="bp">⟩</span>

<span class="kn">end</span> <span class="n">equiv</span>

<span class="c1">-- should be in mathlib</span>

<span class="kn">namespace</span> <span class="n">opens</span>

<span class="n">def</span> <span class="n">Union</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">set</span><span class="bp">.</span><span class="n">Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="o">),</span> <span class="n">is_open_Union</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">s</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="mi">2</span><span class="o">)</span><span class="bp">⟩</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">subset_Union</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">s</span> <span class="n">i</span> <span class="err">⊆</span> <span class="n">Union</span> <span class="n">s</span> <span class="o">:=</span>
<span class="c1">-- why does lattice.le_supr need complete lattice?</span>
<span class="bp">λ</span> <span class="n">s</span> <span class="n">i</span> <span class="n">x</span> <span class="n">hx</span><span class="o">,</span> <span class="n">set</span><span class="bp">.</span><span class="n">mem_Union</span><span class="bp">.</span><span class="mi">2</span> <span class="bp">⟨</span><span class="n">i</span><span class="o">,</span> <span class="n">hx</span><span class="bp">⟩</span>

<span class="c">/-</span><span class="cm"> Other things I might need about this Union</span>

<span class="cm">@[simp] theorem mem_Union {x : β} {s : ι → set β} : x ∈ Union s ↔ ∃ i, x ∈ s i :=</span>
<span class="cm">⟨assume ⟨t, ⟨⟨a, (t_eq : s a = t)⟩, (h : x ∈ t)⟩⟩, ⟨a, t_eq.symm ▸ h⟩,</span>
<span class="cm">  assume ⟨a, h⟩, ⟨s a, ⟨⟨a, rfl⟩, h⟩⟩⟩</span>
<span class="cm">/- alternative proof: dsimp [Union, supr, Sup]; simp -/</span>
<span class="cm">  -- TODO: more rewrite rules wrt forall / existentials and logical connectives</span>
<span class="cm">  -- TODO: also eliminate ∃i, ... ∧ i = t ∧ ...</span>

<span class="cm">theorem Union_subset {s : ι → set β} {t : set β} (h : ∀ i, s i ⊆ t) : (⋃ i, s i) ⊆ t :=</span>
<span class="cm">-- TODO: should be simpler when sets&#39; order is based on lattices</span>
<span class="cm">@supr_le (set β) _ set.lattice_set _ _ h</span>

<span class="cm">theorem Union_subset_iff {α : Sort u} {s : α → set β} {t : set β} : (⋃ i, s i) ⊆ t ↔ (∀ i, s i ⊆ t):=</span>
<span class="cm">⟨assume h i, subset.trans (le_supr s _) h, Union_subset⟩</span>

<span class="cm">theorem subset_Union : ∀ (s : ι → set β) (i : ι), s i ⊆ (⋃ i, s i) := le_supr</span>

<span class="cm">theorem Union_const [inhabited ι] (s : set β) : (⋃ i:ι, s) = s :=</span>
<span class="cm">ext $ by simp</span>

<span class="cm">theorem inter_Union_left (s : set β) (t : ι → set β) :</span>
<span class="cm">  s ∩ (⋃ i, t i) = ⋃ i, s ∩ t i :=</span>
<span class="cm">ext $ by simp</span>

<span class="cm">theorem inter_Union_right (s : set β) (t : ι → set β) :</span>
<span class="cm">  (⋃ i, t i) ∩ s = ⋃ i, t i ∩ s :=</span>
<span class="cm">ext $ by simp</span>

<span class="cm">theorem Union_union_distrib (s : ι → set β) (t : ι → set β) :</span>
<span class="cm">  (⋃ i, s i ∪ t i) = (⋃ i, s i) ∪ (⋃ i, t i) :=</span>
<span class="cm">ext $ by simp [exists_or_distrib]</span>

<span class="cm">theorem union_Union_left [inhabited ι] (s : set β) (t : ι → set β) :</span>
<span class="cm">  s ∪ (⋃ i, t i) = ⋃ i, s ∪ t i :=</span>
<span class="cm">by rw [Union_union_distrib, Union_const]</span>

<span class="cm">theorem union_Union_right [inhabited ι] (s : set β) (t : ι → set β) :</span>
<span class="cm">  (⋃ i, t i) ∪ s = ⋃ i, t i ∪ s :=</span>
<span class="cm">by rw [Union_union_distrib, Union_const]</span>

<span class="cm">theorem diff_Union_right (s : set β) (t : ι → set β) :</span>
<span class="cm">  (⋃ i, t i) \ s = ⋃ i, t i \ s :=</span>
<span class="cm">inter_Union_right _ _</span>

<span class="cm">-/</span>

<span class="kn">end</span> <span class="n">opens</span>

<span class="n">def</span> <span class="n">glue</span> <span class="o">{</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span><span class="o">))</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span>
    <span class="n">equiv</span> <span class="o">((</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">((</span><span class="n">F</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">Hφ1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">φ</span> <span class="n">i</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">))</span>
  <span class="o">(</span><span class="n">Hφ2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">,</span>
    <span class="o">((</span><span class="n">φ</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span>
      <span class="o">((</span><span class="n">φ</span> <span class="n">j</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)))</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">φ</span> <span class="n">i</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)))</span> <span class="o">:</span>
  <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="o">(</span><span class="n">opens</span><span class="bp">.</span><span class="n">Union</span> <span class="n">S</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span>
  <span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">W</span><span class="o">,</span> <span class="o">{</span> <span class="n">f</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="kn">eval</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="bp">//</span>
      <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span><span class="o">,</span> <span class="o">(</span><span class="n">φ</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="mi">1</span><span class="bp">.</span><span class="n">map</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">)</span> <span class="err">∩</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span>
        <span class="o">((</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">res</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="n">W</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span>
          <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span>
          <span class="o">(</span><span class="n">f</span> <span class="n">i</span><span class="o">))</span> <span class="bp">=</span>
        <span class="o">(</span><span class="n">F</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">res</span> <span class="o">((</span><span class="n">S</span> <span class="n">j</span><span class="o">)</span> <span class="err">∩</span> <span class="n">W</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span>
          <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span>
          <span class="o">(</span><span class="n">f</span> <span class="n">j</span><span class="o">)</span> <span class="o">},</span>
    <span class="n">res</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HUV</span> <span class="n">f</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">i</span><span class="o">,</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">res</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span> <span class="err">∩</span> <span class="n">U</span><span class="o">)</span> <span class="bp">_</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span> <span class="err">∩</span> <span class="n">V</span><span class="o">)</span> <span class="bp">_</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_inter_right</span> <span class="bp">_</span> <span class="n">HUV</span><span class="o">)</span> <span class="o">(</span><span class="n">f</span><span class="bp">.</span><span class="mi">1</span> <span class="n">i</span><span class="o">),</span>
      <span class="k">begin</span> <span class="n">sorry</span>

      <span class="kn">end</span><span class="bp">⟩</span><span class="o">,</span>
    <span class="n">Hid</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
    <span class="n">Hcomp</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">},</span>
  <span class="n">locality</span> <span class="o">:=</span> <span class="n">sorry</span><span class="o">,</span>
  <span class="n">gluing</span> <span class="o">:=</span> <span class="n">sorry</span> <span class="o">}</span>

<span class="n">def</span> <span class="n">universal_property</span> <span class="o">(</span><span class="n">I</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="o">:</span> <span class="n">I</span> <span class="bp">→</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span> <span class="n">sheaf_on_opens</span><span class="bp">.</span><span class="o">{</span><span class="n">v</span><span class="o">}</span> <span class="n">X</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span><span class="o">))</span>
  <span class="o">(</span><span class="n">φ</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">i</span> <span class="n">j</span> <span class="o">:</span> <span class="n">I</span><span class="o">),</span>
    <span class="n">equiv</span> <span class="o">((</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">((</span><span class="n">F</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)))</span>
  <span class="o">(</span><span class="n">Hφ1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span><span class="o">,</span> <span class="n">φ</span> <span class="n">i</span> <span class="n">i</span> <span class="bp">=</span> <span class="n">equiv</span><span class="bp">.</span><span class="n">refl</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">))</span>
  <span class="o">(</span><span class="n">Hφ2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="o">,</span>
    <span class="o">((</span><span class="n">φ</span> <span class="n">i</span> <span class="n">j</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span><span class="bp">.</span><span class="n">trans</span>
      <span class="o">((</span><span class="n">φ</span> <span class="n">j</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)))</span> <span class="bp">=</span>
    <span class="o">(</span><span class="n">φ</span> <span class="n">i</span> <span class="n">k</span><span class="o">)</span><span class="bp">.</span><span class="n">res_subset</span> <span class="o">((</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">j</span><span class="o">)</span> <span class="err">∩</span> <span class="o">(</span><span class="n">S</span> <span class="n">k</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset_inter</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">subset</span><span class="bp">.</span><span class="n">trans</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_left</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">))</span> <span class="o">(</span><span class="n">set</span><span class="bp">.</span><span class="n">inter_subset_right</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">)))</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="n">i</span> <span class="o">:</span> <span class="n">I</span><span class="o">,</span> <span class="n">equiv</span> <span class="o">(</span><span class="n">res_subset</span> <span class="o">(</span><span class="n">glue</span> <span class="n">S</span> <span class="n">F</span> <span class="n">φ</span> <span class="n">Hφ1</span> <span class="n">Hφ2</span><span class="o">)</span> <span class="o">(</span><span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="err">$</span> <span class="n">opens</span><span class="bp">.</span><span class="n">subset_Union</span> <span class="n">S</span> <span class="n">i</span><span class="o">)</span> <span class="o">(</span><span class="n">F</span> <span class="n">i</span><span class="o">)</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">end</span> <span class="n">sheaf_on_opens</span>
</pre></div>

<a name="168720434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720434">Kevin Buzzard (Jun 21 2019 at 22:03)</a>:</h4>
<p>If I fill in the sorries then I've proved that Kenny's random idea works out. The alternative is to use a subtype, but then I need " F(V) -&gt; F(U intersect V) is an isomorphism" to be a Prop, so things might get noncomputable.</p>

<a name="168720438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720438">Mario Carneiro (Jun 21 2019 at 22:03)</a>:</h4>
<p>wait so you still have a separate definition? This seems like a lot of duplication</p>

<a name="168720439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720439">Kevin Buzzard (Jun 21 2019 at 22:03)</a>:</h4>
<p>Not that I care, but you might.</p>

<a name="168720452"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720452" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720452">Kevin Buzzard (Jun 21 2019 at 22:04)</a>:</h4>
<p>We have a wrapper:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">sheaf_on_opens</span> <span class="o">(</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">topological_space</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">opens</span> <span class="n">X</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="o">(</span><span class="n">v</span><span class="bp">+</span><span class="mi">1</span><span class="o">))</span> <span class="o">:=</span>
<span class="n">sheaf</span><span class="bp">.</span><span class="o">{</span><span class="n">u</span> <span class="n">v</span><span class="o">}</span> <span class="n">X</span>
</pre></div>

<a name="168720496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720496">Mario Carneiro (Jun 21 2019 at 22:04)</a>:</h4>
<p>Remind me the original definitions, I will show how to do this without all the proof obligations</p>

<a name="168720552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720552">Mario Carneiro (Jun 21 2019 at 22:04)</a>:</h4>
<p>The <code>res</code> function need not take a proof arg, nor <code>eval</code></p>

<a name="168720572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720572">Kevin Buzzard (Jun 21 2019 at 22:05)</a>:</h4>
<p>Right!</p>

<a name="168720575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720575">Kevin Buzzard (Jun 21 2019 at 22:05)</a>:</h4>
<p><a href="https://github.com/ramonfmir/lean-scheme/blob/master/src/sheaves/sheaf.lean" target="_blank" title="https://github.com/ramonfmir/lean-scheme/blob/master/src/sheaves/sheaf.lean">https://github.com/ramonfmir/lean-scheme/blob/master/src/sheaves/sheaf.lean</a></p>

<a name="168720593"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720593" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720593">Kevin Buzzard (Jun 21 2019 at 22:05)</a>:</h4>
<p>That's the definition of a sheaf.</p>

<a name="168720658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168720658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168720658">Kevin Buzzard (Jun 21 2019 at 22:06)</a>:</h4>
<p>It uses the file presheaf.lean in the same directory, plus epsilon about open coverings.</p>

<a name="168723312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168723312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168723312">Mario Carneiro (Jun 21 2019 at 22:52)</a>:</h4>
<p>I will come back to this later, but here's the first pass:</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">presheaf</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">semilattice_inf</span> <span class="n">α</span><span class="o">]</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">F</span>     <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">)</span>
<span class="o">(</span><span class="n">res</span>   <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">),</span> <span class="n">F</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">F</span> <span class="n">V</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hid</span>   <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span><span class="o">),</span> <span class="n">res</span> <span class="n">U</span> <span class="n">U</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">U</span><span class="o">)</span> <span class="bp">=</span> <span class="n">id</span><span class="o">)</span>
<span class="o">(</span><span class="n">Hcomp</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">HWV</span> <span class="o">:</span> <span class="n">W</span> <span class="bp">≤</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">),</span>
  <span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">HWV</span> <span class="n">HVU</span><span class="o">)</span> <span class="bp">=</span> <span class="n">res</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="err">∘</span> <span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span>

<span class="kn">namespace</span> <span class="n">presheaf</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">semilattice_inf</span> <span class="n">α</span><span class="o">]</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_coe_to_fun</span> <span class="o">(</span><span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">F</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="bp">_</span><span class="o">,</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">,</span>
  <span class="n">coe</span> <span class="o">:=</span> <span class="n">presheaf</span><span class="bp">.</span><span class="n">F</span> <span class="o">}</span>

<span class="c1">-- Simplification lemmas for Hid and Hcomp.</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">Hcomp&#39;</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">U</span> <span class="n">V</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">HWV</span> <span class="o">:</span> <span class="n">W</span> <span class="bp">≤</span> <span class="n">V</span><span class="o">)</span> <span class="o">(</span><span class="n">HVU</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">),</span>
  <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="o">(</span><span class="n">le_trans</span> <span class="n">HWV</span> <span class="n">HVU</span><span class="o">))</span> <span class="n">s</span> <span class="bp">=</span>
  <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span><span class="o">)</span> <span class="o">((</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">HVU</span><span class="o">)</span> <span class="n">s</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="n">HVU</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">F</span><span class="bp">.</span><span class="n">Hcomp</span> <span class="n">U</span> <span class="n">V</span> <span class="n">W</span> <span class="n">HWV</span> <span class="n">HVU</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">lemma</span> <span class="n">Hid&#39;</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">),</span>
  <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">U</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">U</span><span class="o">))</span> <span class="n">s</span> <span class="bp">=</span> <span class="n">s</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="n">U</span> <span class="n">s</span><span class="o">,</span> <span class="k">by</span> <span class="n">rw</span> <span class="n">F</span><span class="bp">.</span><span class="n">Hid</span> <span class="n">U</span><span class="bp">;</span> <span class="n">simp</span>

<span class="n">def</span> <span class="n">total</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">max</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">:=</span> <span class="err">Σ</span> <span class="n">U</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">F</span> <span class="n">U</span>

<span class="kn">instance</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">has_coe_t</span> <span class="o">(</span><span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="n">F</span><span class="bp">.</span><span class="n">total</span> <span class="o">:=</span>
<span class="bp">⟨</span><span class="n">sigma</span><span class="bp">.</span><span class="n">mk</span> <span class="bp">_⟩</span>

<span class="bp">@</span><span class="o">[</span><span class="n">elab_as_eliminator</span><span class="o">]</span>
<span class="kn">theorem</span> <span class="n">total</span><span class="bp">.</span><span class="n">cases_on</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">total</span> <span class="bp">→</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span>
  <span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">),</span> <span class="n">C</span> <span class="n">x</span><span class="o">)</span> <span class="o">:</span> <span class="n">C</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">cases</span> <span class="n">x</span><span class="bp">;</span> <span class="n">apply</span> <span class="n">H</span>

<span class="n">def</span> <span class="n">res&#39;</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">V</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">total</span> <span class="bp">→</span> <span class="n">F</span><span class="bp">.</span><span class="n">total</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">U</span><span class="o">,</span> <span class="n">x</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">inf_le_left</span> <span class="n">x</span>

<span class="kn">theorem</span> <span class="n">res&#39;_def</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="n">V</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">inf_le_left</span> <span class="n">x</span> <span class="o">:=</span> <span class="n">rfl</span>

<span class="kn">theorem</span> <span class="n">res&#39;_val</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">V</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="n">V</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">h</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">have</span> <span class="bp">∀</span> <span class="n">W</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">W</span> <span class="bp">≤</span> <span class="n">U</span><span class="o">),</span> <span class="n">W</span> <span class="bp">=</span> <span class="n">V</span> <span class="bp">→</span>
  <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">W</span> <span class="n">H</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">total</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">h</span> <span class="n">x</span> <span class="o">:=</span>
  <span class="k">by</span> <span class="n">rintro</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">rfl</span><span class="bp">;</span> <span class="n">refl</span><span class="o">,</span>
<span class="n">this</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">inf_of_le_right</span> <span class="n">h</span><span class="o">)</span>

<span class="kn">theorem</span> <span class="n">res&#39;_eq_inf</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="n">V</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">res&#39;_def</span><span class="o">,</span> <span class="err">←</span> <span class="n">res&#39;_val</span> <span class="bp">_</span> <span class="bp">_</span> <span class="n">inf_le_left</span><span class="o">]</span>

<span class="kn">theorem</span> <span class="n">res&#39;_eq_left</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span> <span class="n">W</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">(</span><span class="n">H</span> <span class="o">:</span> <span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span> <span class="bp">=</span> <span class="n">U</span> <span class="err">⊓</span> <span class="n">W</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="n">V</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="n">W</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">res&#39;_eq_inf</span><span class="o">,</span> <span class="n">H</span><span class="o">,</span> <span class="err">←</span> <span class="n">res&#39;_eq_inf</span><span class="o">]</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">res&#39;_id</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">U</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">)</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="n">U</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">x</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">res&#39;_val</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">le_refl</span> <span class="n">U</span><span class="o">),</span> <span class="n">F</span><span class="bp">.</span><span class="n">Hid</span><span class="o">]</span><span class="bp">;</span> <span class="n">refl</span>

<span class="bp">@</span><span class="o">[</span><span class="n">simp</span><span class="o">]</span> <span class="kn">theorem</span> <span class="n">res&#39;_comp</span> <span class="o">{</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">}</span> <span class="o">{</span><span class="n">U</span> <span class="n">V</span><span class="o">}</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">F</span><span class="bp">.</span><span class="n">total</span><span class="o">)</span> <span class="o">:</span>
  <span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="n">U</span> <span class="o">(</span><span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="n">V</span> <span class="n">x</span><span class="o">)</span> <span class="bp">=</span> <span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="o">(</span><span class="n">U</span> <span class="err">⊓</span> <span class="n">V</span><span class="o">)</span> <span class="n">x</span> <span class="o">:=</span>
<span class="n">total</span><span class="bp">.</span><span class="n">cases_on</span> <span class="n">F</span> <span class="n">x</span> <span class="err">$</span> <span class="bp">λ</span> <span class="n">W</span> <span class="n">x</span><span class="o">,</span>
<span class="k">by</span> <span class="n">rw</span> <span class="o">[</span><span class="n">res&#39;_def</span><span class="o">,</span> <span class="n">res&#39;_def</span><span class="o">,</span> <span class="err">←</span> <span class="n">F</span><span class="bp">.</span><span class="n">Hcomp&#39;</span><span class="o">,</span> <span class="err">←</span> <span class="n">res&#39;_val</span><span class="o">,</span> <span class="n">res&#39;_eq_left</span><span class="o">]</span><span class="bp">;</span>
   <span class="n">simp</span> <span class="o">[</span><span class="n">inf_left_comm</span><span class="o">,</span> <span class="n">inf_comm</span><span class="o">]</span>

<span class="kn">end</span> <span class="n">presheaf</span>
</pre></div>

<a name="168724242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724242">Kevin Buzzard (Jun 21 2019 at 23:06)</a>:</h4>
<p>I think your definition of presheaf is essentially the definition of a functor</p>

<a name="168724260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724260">Kevin Buzzard (Jun 21 2019 at 23:07)</a>:</h4>
<p>To Type</p>

<a name="168724267"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724267" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724267">Reid Barton (Jun 21 2019 at 23:07)</a>:</h4>
<p>it had better be!</p>

<a name="168724270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724270">Mario Carneiro (Jun 21 2019 at 23:07)</a>:</h4>
<p>more or less; it's a preorder category on the left too, and I use the existence of infima a lot</p>

<a name="168724277"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724277" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724277">Mario Carneiro (Jun 21 2019 at 23:07)</a>:</h4>
<p>which I think means products?</p>

<a name="168724352"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724352" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724352">Mario Carneiro (Jun 21 2019 at 23:08)</a>:</h4>
<p>However this generalization is basically zero cost, while I'm not sure that generalizing to functor is also zero cost</p>

<a name="168724382"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724382" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724382">Mario Carneiro (Jun 21 2019 at 23:09)</a>:</h4>
<p>it's not really even relevant, it's just sort of an obvious generalization the way it's been written</p>

<a name="168724387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724387">Kevin Buzzard (Jun 21 2019 at 23:09)</a>:</h4>
<p>But functors are already there. <span class="user-mention" data-user-id="110087">@Scott Morrison</span> and I had talked about this being a very good use case for the category theory library.</p>

<a name="168724391"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724391" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724391">Mario Carneiro (Jun 21 2019 at 23:09)</a>:</h4>
<p>the point I want to make involves <code>res'</code></p>

<a name="168724439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724439">Kevin Buzzard (Jun 21 2019 at 23:10)</a>:</h4>
<p>And this <code>total</code> trick</p>

<a name="168724444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724444">Mario Carneiro (Jun 21 2019 at 23:10)</a>:</h4>
<p>once again, untyped to the rescue</p>

<a name="168724497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724497">Mario Carneiro (Jun 21 2019 at 23:11)</a>:</h4>
<p>there is still some unpacking to do with the definition of <code>locality</code> and <code>gluing</code>; one wants the statement to be in terms of families not sets</p>

<a name="168724547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724547">Kevin Buzzard (Jun 21 2019 at 23:12)</a>:</h4>
<p>There seem to be several approaches to this. I remember Scott saying that presheaves were fine but the sheaf axiom got a bit grotty in the sense that he wasn't happy with his attempts to formalise it. The sheaf axiom is <code>gluing \and locality</code></p>

<a name="168724559"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724559" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724559">Kevin Buzzard (Jun 21 2019 at 23:13)</a>:</h4>
<p>You can make them into one axiom by changing that exists in the conclusion of glueing to exists unique, but Ramon found it nicer to keep them separate.</p>

<a name="168724634"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724634" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724634">Mario Carneiro (Jun 21 2019 at 23:14)</a>:</h4>
<p>Oh, this is epsilon nicer:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">gluing</span> <span class="o">(</span><span class="n">F</span> <span class="o">:</span> <span class="n">presheaf</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="bp">∀</span> <span class="o">{{</span><span class="n">U</span> <span class="o">:</span> <span class="n">α</span><span class="o">}}</span> <span class="o">{{</span><span class="n">S</span><span class="o">}},</span> <span class="n">is_lub</span> <span class="n">S</span> <span class="n">U</span> <span class="bp">→</span>
<span class="bp">∀</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="bp">Π</span> <span class="n">V</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span> <span class="n">F</span> <span class="n">V</span><span class="o">),</span>
<span class="o">(</span><span class="bp">∀</span> <span class="n">V</span> <span class="n">W</span> <span class="o">:</span> <span class="n">S</span><span class="o">,</span>
  <span class="n">res&#39;</span> <span class="n">F</span> <span class="o">(</span><span class="n">V</span> <span class="err">⊓</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">V</span><span class="o">)</span> <span class="bp">=</span> <span class="n">res&#39;</span> <span class="n">F</span> <span class="o">(</span><span class="n">V</span> <span class="err">⊓</span> <span class="n">W</span><span class="o">)</span> <span class="o">(</span><span class="n">s</span> <span class="n">W</span><span class="o">))</span> <span class="bp">→</span>
<span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">F</span> <span class="n">U</span><span class="o">,</span> <span class="bp">∀</span> <span class="n">V</span><span class="o">:</span><span class="n">S</span><span class="o">,</span> <span class="n">F</span><span class="bp">.</span><span class="n">res&#39;</span> <span class="n">V</span> <span class="n">x</span> <span class="bp">=</span> <span class="n">s</span> <span class="n">V</span>
</pre></div>

<a name="168724646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724646">Kevin Buzzard (Jun 21 2019 at 23:14)</a>:</h4>
<p>So what is the advantage of this approach over Kenny's, given that I decided I didn't care about equality being broken? <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span> does this approach have an analogue in your chart world?</p>

<a name="168724659"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724659" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724659">Mario Carneiro (Jun 21 2019 at 23:15)</a>:</h4>
<p>Axiomatically, this is equivalent to the very first definition we started with when we first looked at it</p>

<a name="168724665"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724665" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724665">Mario Carneiro (Jun 21 2019 at 23:15)</a>:</h4>
<p>All I'm doing is layering a more convenient API on top</p>

<a name="168724667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724667">Kevin Buzzard (Jun 21 2019 at 23:15)</a>:</h4>
<p>In the schemes project we need sheaves of rings, and then sheaves of modules over the rings.</p>

<a name="168724714"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724714" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724714">Mario Carneiro (Jun 21 2019 at 23:16)</a>:</h4>
<p>You can change <code>Type</code> to a category here without changing anything</p>

<a name="168724720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724720">Kevin Buzzard (Jun 21 2019 at 23:16)</a>:</h4>
<p>I'm not sure there's a category of modules over the category of rings, as it were</p>

<a name="168724721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724721">Mario Carneiro (Jun 21 2019 at 23:16)</a>:</h4>
<p>well that's not exactly true; I'm using  a sigma type which needs the underlying space to be a type</p>

<a name="168724747"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724747" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724747">Kevin Buzzard (Jun 21 2019 at 23:17)</a>:</h4>
<p>In the perfectoid project we need sheaves of topological rings, and there's an extra subtlety there</p>

<a name="168724784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724784">Kevin Buzzard (Jun 21 2019 at 23:18)</a>:</h4>
<p>The sheaf axiom says that a certain map is an equalizer, and we're writing it as "there exists unique x" but in the category of topological spaces there's more to it than that.</p>

<a name="168724820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724820">Kevin Buzzard (Jun 21 2019 at 23:18)</a>:</h4>
<p>We need two topologies on a ring to coincide as well. This seems like a good excuse to go full category with the target</p>

<a name="168724823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724823">Mario Carneiro (Jun 21 2019 at 23:18)</a>:</h4>
<p>Eh, I'm not really sure about the quality of any remarks I make here. Show me the code and we can talk</p>

<a name="168724882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724882">Mario Carneiro (Jun 21 2019 at 23:19)</a>:</h4>
<p>Make this definition in the generality that you actually need</p>

<a name="168724884"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724884" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724884">Kevin Buzzard (Jun 21 2019 at 23:19)</a>:</h4>
<p>I'm just thinking of all the "extreme" notions of sheaves which I've encountered so far in my Lean work.</p>

<a name="168724933"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724933" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724933">Kevin Buzzard (Jun 21 2019 at 23:20)</a>:</h4>
<blockquote>
<p>Make this definition in the generality that you actually need</p>
</blockquote>
<p>That's not the right approach, because the generality we actually need is sheaves of categories on a site.</p>

<a name="168724944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724944">Kevin Buzzard (Jun 21 2019 at 23:20)</a>:</h4>
<p>That's what we'll need when we start doing etale cohomology.</p>

<a name="168724960"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168724960" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168724960">Kevin Buzzard (Jun 21 2019 at 23:20)</a>:</h4>
<p>So now you won't be able to get away with lattices, there is a category with a Grothendieck topology.</p>

<a name="168725044"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725044" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725044">Kevin Buzzard (Jun 21 2019 at 23:22)</a>:</h4>
<p>The whole "work in the correct generality" thing might work for basic Lean stuff but in maths things get so absurdly general sometimes that it's really not that clear that you want to work in the fullest 2019 generality.</p>

<a name="168725047"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725047" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725047">Kevin Buzzard (Jun 21 2019 at 23:22)</a>:</h4>
<p>Not least because you might be out of date in 5 years anyway.</p>

<a name="168725077"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725077" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725077">Mario Carneiro (Jun 21 2019 at 23:23)</a>:</h4>
<p>I don't mean the possible generality that exists, I mean the generality that suffices for the short to mid term future</p>

<a name="168725128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725128">Mario Carneiro (Jun 21 2019 at 23:24)</a>:</h4>
<p>like "what we need for the current major milestone"</p>

<a name="168725135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725135">Kevin Buzzard (Jun 21 2019 at 23:24)</a>:</h4>
<p>For all I know they're doing sheaves on infinity,1 categories nowadays.</p>

<a name="168725153"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725153" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725153">Mario Carneiro (Jun 21 2019 at 23:25)</a>:</h4>
<p>always have a concrete application in mind that is not in danger of being pushed off to the infinite future</p>

<a name="168725268"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725268" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725268">Kevin Buzzard (Jun 21 2019 at 23:27)</a>:</h4>
<p>The reason I'm thinking about gluing sheaves is that we have a nice theory of affine schemes, and then to make general schemes you have to glue affine schemes together. We can glue topological spaces together, so all we have to do is to glue sheaves together and we can make general schemes. That would be a cool milestone. To do that we would need to be able to glue sheaves of commutative rings together.</p>

<a name="168725279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725279">Mario Carneiro (Jun 21 2019 at 23:27)</a>:</h4>
<p>Okay, so you need to have more than sheaves on Type then. Do you need more than lattices?</p>

<a name="168725333"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725333" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725333">Kevin Buzzard (Jun 21 2019 at 23:28)</a>:</h4>
<p>A sheaf of commutative rings is just a sheaf of types but all the res maps are ring homs. We're still talking about sheaves on topological spaces here, so if opens X is a lattice then we don't need more than lattices.</p>

<a name="168725375"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725375" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725375">Kevin Buzzard (Jun 21 2019 at 23:29)</a>:</h4>
<p>I've been thinking about the next few things which it would be fun to formalise (and looking for students to do them). I should perhaps post them as issues, as per Scott's suggestion.</p>

<a name="168725662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725662">Mario Carneiro (Jun 21 2019 at 23:35)</a>:</h4>
<p>something like this then?</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">sheaf</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">semilattice_inf</span> <span class="n">α</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">presheaf</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">locality</span> <span class="o">:</span> <span class="n">to_presheaf</span><span class="bp">.</span><span class="n">locality</span><span class="o">)</span>
<span class="o">(</span><span class="n">gluing</span>   <span class="o">:</span> <span class="n">to_presheaf</span><span class="bp">.</span><span class="n">gluing</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">sheaf_of_rings</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">semilattice_inf</span> <span class="n">α</span><span class="o">]</span> <span class="kn">extends</span> <span class="n">sheaf</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">[</span><span class="n">ring</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span><span class="o">,</span> <span class="n">ring</span> <span class="o">(</span><span class="n">F</span> <span class="n">U</span><span class="o">)]</span>
<span class="o">[</span><span class="n">ring_hom</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">U</span> <span class="n">V</span> <span class="n">h</span><span class="o">,</span> <span class="n">is_ring_hom</span> <span class="o">(</span><span class="n">res</span> <span class="n">U</span> <span class="n">V</span> <span class="n">h</span><span class="o">)]</span>
</pre></div>

<a name="168725820"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168725820" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168725820">Mario Carneiro (Jun 21 2019 at 23:38)</a>:</h4>
<p>you can't prove that <code>res'</code> is a ring_hom because it has the wrong type, but you could either use a different total space that is a ring, like Reid suggested in the CDGA thread, or you could just prove concretely that it preserves addition and so on modulo a coercion</p>

<a name="168726652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168726652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168726652">Mario Carneiro (Jun 21 2019 at 23:56)</a>:</h4>
<p>Ah, actually neither of those options works. Apparently rings don't have a very nice indexed coproduct; it can be trivial because of characteristic constraints. And it's not really easy to talk about addition and so on over a coercion unless the total space has an addition</p>

<a name="168726762"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/breaking%20equality%20with%20sheaves/near/168726762" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/75037breakingequalitywithsheaves.html#168726762">Mario Carneiro (Jun 21 2019 at 23:58)</a>:</h4>
<p>But this definition is so higher order that perhaps you aren't really doing actual algebra on the rings anymore, and knowing that the res maps are abstractly a ring hom is sufficient</p>


{% endraw %}
