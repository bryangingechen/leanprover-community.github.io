---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/116395maths/78527Orderontopologies.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/116395maths/index.html">maths</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html">Order on topologies</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="167570928"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167570928" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167570928">Patrick Massot (Jun 07 2019 at 12:15)</a>:</h4>
<p>I already asked this question in the middle of another thread and got no answer, let me try again:</p>
<p>Is the order relation on topological_space and uniform_space open for debate? Currently we have incompatibility with the order on filters, as seen in <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L147-L148</a> and <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472">https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L472</a>, generating things like <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542">https://github.com/leanprover-community/mathlib/blob/master/src/topology/uniform_space/basic.lean#L542</a> and generating a push-forward which is right-adjoint to pull-back<br>
 As far as I can see, real world never write <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_1 \leq t_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.63597em;"></span><span class="strut bottom" style="height:0.7859700000000001em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">≤</span><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> for topologies <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">t_1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">t_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.61508em;"></span><span class="strut bottom" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span> but write sentences randomly using either the "finer than" or "coarser than" relation.</p>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> <span class="user-mention" data-user-id="110032">@Reid Barton</span> <span class="user-mention" data-user-id="110050">@Sebastien Gouezel</span></p>

<a name="167571503"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167571503" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167571503">Sebastien Gouezel (Jun 07 2019 at 12:23)</a>:</h4>
<p>I would agree to switch the order. I don't have strong opinion either way, but coherence over the different concepts is a valuable goal.</p>

<a name="167571553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167571553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167571553">Chris Hughes (Jun 07 2019 at 12:24)</a>:</h4>
<p>That's because the order on filters is silly, not the order on topologies.</p>

<a name="167573035"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167573035" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167573035">Reid Barton (Jun 07 2019 at 12:45)</a>:</h4>
<p>If you believe the reasonable-looking statement<br>
(*) The identity map <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>T</mi><mn>1</mn></msub><mo>)</mo><mo>→</mo><mo>(</mo><mi>X</mi><mo separator="true">,</mo><msub><mi>T</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(X, T_1) \to (X, T_2)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base"><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span><span class="mrel">→</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mclose">)</span></span></span></span> is continuous iff <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo>≤</mo><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_1 \le T_2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span><span class="mrel">≤</span><span class="mord"><span class="mord mathit" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathrm mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"></span></span></span></span></span></span></span></span><br>
then you should use Patrick's order, with the discrete topology at the bottom and the indiscrete topology at the top.</p>

<a name="167573114"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167573114" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167573114">Reid Barton (Jun 07 2019 at 12:46)</a>:</h4>
<p>However in algebraic geometry there is an "op" inserted between the morphisms of schemes and the morphisms of their structure sheaves, so perhaps one should not believe (*), I'm not sure.</p>

<a name="167573815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167573815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167573815">Reid Barton (Jun 07 2019 at 12:56)</a>:</h4>
<p>I wouldn't be against reversing the order of topologies, though it looks like a fair amount of work</p>

<a name="167574022"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574022" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574022">Patrick Massot (Jun 07 2019 at 12:59)</a>:</h4>
<p>Chris, the order on filters is nice because it makes <code>principal</code> monotone <a href="https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358">https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358</a> and because it makes push forward left adjoint to pull back, and not the other way around.</p>

<a name="167574220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574220">Reid Barton (Jun 07 2019 at 13:01)</a>:</h4>
<p>What about</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">to_topological_space_mono</span> <span class="o">{</span><span class="n">u₁</span> <span class="n">u₂</span> <span class="o">:</span> <span class="n">uniform_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">u₁</span> <span class="bp">≤</span> <span class="n">u₂</span><span class="o">)</span> <span class="o">:</span>
<span class="bp">@</span><span class="n">uniform_space</span><span class="bp">.</span><span class="n">to_topological_space</span> <span class="bp">_</span> <span class="n">u₁</span> <span class="bp">≤</span> <span class="bp">@</span><span class="n">uniform_space</span><span class="bp">.</span><span class="n">to_topological_space</span> <span class="bp">_</span> <span class="n">u₂</span> <span class="o">:=</span>

<span class="kn">lemma</span> <span class="n">uniform_continuous_iff</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span><span class="o">}</span> <span class="o">[</span><span class="n">uα</span> <span class="o">:</span> <span class="n">uniform_space</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">uβ</span> <span class="o">:</span> <span class="n">uniform_space</span> <span class="n">β</span><span class="o">]</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span><span class="o">)</span> <span class="o">:</span>
<span class="n">uniform_continuous</span> <span class="n">f</span> <span class="bp">↔</span> <span class="n">uβ</span><span class="bp">.</span><span class="n">comap</span> <span class="n">f</span> <span class="bp">≤</span> <span class="n">uα</span> <span class="o">:=</span>
</pre></div>

<a name="167574389"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574389" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574389">Patrick Massot (Jun 07 2019 at 13:03)</a>:</h4>
<p>The first lemma means you can't change the order on topologies without changing the order on uniform structures.</p>

<a name="167574395"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574395" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574395">Reid Barton (Jun 07 2019 at 13:03)</a>:</h4>
<p>Or wait, were you going to reverse the order on <code>uniform_space</code> too?</p>

<a name="167574408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574408">Reid Barton (Jun 07 2019 at 13:03)</a>:</h4>
<p>Okay, I missed that <span aria-label="+1" class="emoji emoji-1f44d" role="img" title="+1">:+1:</span></p>

<a name="167574413"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574413" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574413">Patrick Massot (Jun 07 2019 at 13:03)</a>:</h4>
<p>Yes, see the first message</p>

<a name="167574521"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167574521" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167574521">Patrick Massot (Jun 07 2019 at 13:04)</a>:</h4>
<p>The second lemma means the order on uniform spaces currently doesn't play nicely with the order on filters</p>

<a name="167575692"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167575692" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167575692">Patrick Massot (Jun 07 2019 at 13:20)</a>:</h4>
<blockquote>
<p>Chris, the order on filters is nice because it makes <code>principal</code> monotone <a href="https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358">https://github.com/leanprover-community/mathlib/blob/master/src/order/filter/basic.lean#L358</a> and because it makes push forward left adjoint to pull back, and not the other way around.</p>
</blockquote>
<p>I guess this is only one argument. I like push-forward to be the left adjoint because this is what happens for functions acting on subsets. But of course sheaves are the other way around.</p>

<a name="167576054"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576054" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576054">Kevin Buzzard (Jun 07 2019 at 13:25)</a>:</h4>
<p>This is sort of like saying "wouldn't it be great if all -1's were +1's?". It's not so clear that there's a perfect answer here. I guess I mean that it is clear that there is not a perfect answer here.</p>

<a name="167576133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576133">Patrick Massot (Jun 07 2019 at 13:26)</a>:</h4>
<p>We don't want a perfect answer here. We want something consistent across filters, topology and uniform structures</p>

<a name="167576146"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576146" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576146">Patrick Massot (Jun 07 2019 at 13:26)</a>:</h4>
<p>Currently it is not consistent in mathlib</p>

<a name="167576199"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576199" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576199">Patrick Massot (Jun 07 2019 at 13:27)</a>:</h4>
<p>And if we add the constraint that <code>principal</code> is monotone then we get that the correct order is the one we currently have on filters (unless we want to reverse the orderings on subsets...)</p>

<a name="167576204"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576204" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576204">Kevin Buzzard (Jun 07 2019 at 13:27)</a>:</h4>
<p>Is it <em>possible</em> for everything to be consistent? Or are you just focussed on some small subset of inconsistent things, and if you change to make it consistent that then some other small subset will be inconsistent?</p>

<a name="167576231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576231">Patrick Massot (Jun 07 2019 at 13:27)</a>:</h4>
<p>What would be a bigger set here?</p>

<a name="167576336"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167576336" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167576336">Chris Hughes (Jun 07 2019 at 13:29)</a>:</h4>
<p><code>filter.sets</code> isn't monotone.</p>

<a name="167577532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167577532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167577532">Patrick Massot (Jun 07 2019 at 13:45)</a>:</h4>
<p>Who cares? The goal of the theory is to hide this function as much as possible</p>

<a name="167582788"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167582788" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167582788">Reid Barton (Jun 07 2019 at 14:43)</a>:</h4>
<p>We can't make everything consistent, but it doesn't mean that every possible convention is equally good</p>

<a name="167584317"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167584317" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167584317">Patrick Massot (Jun 07 2019 at 15:00)</a>:</h4>
<p>What should we do then?</p>

<a name="167584618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167584618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167584618">Reid Barton (Jun 07 2019 at 15:04)</a>:</h4>
<p>I'm happy with the change you suggested--as long as I don't have to be the one to implement it</p>

<a name="167787562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167787562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167787562">Patrick Massot (Jun 10 2019 at 19:15)</a>:</h4>
<p>I just discovered a flaw in this plan: <a href="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L110-L111" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L110-L111">https://github.com/leanprover-community/mathlib/blob/master/src/topology/order.lean#L110-L111</a></p>

<a name="167787639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167787639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167787639">Patrick Massot (Jun 10 2019 at 19:16)</a>:</h4>
<p>I'm afraid the Galois insertion involving the topology generated by a collection of subset is the motivation behind the weird order on topologies</p>

<a name="167788092"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167788092" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167788092">Johan Commelin (Jun 10 2019 at 19:22)</a>:</h4>
<p>I suppose you could use <code>order_dual</code> and <code>copy</code>, if you really want...</p>

<a name="167788118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167788118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167788118">Patrick Massot (Jun 10 2019 at 19:22)</a>:</h4>
<p>Maybe we should do antitone Galois connections as well</p>

<a name="167788147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167788147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167788147">Patrick Massot (Jun 10 2019 at 19:23)</a>:</h4>
<p>At some point we'll have to face the fact that fundamental theorem of Galois theory is not a Galois connection, as currently defined in mathlib</p>

<a name="167788612"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167788612" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167788612">Kevin Buzzard (Jun 10 2019 at 19:28)</a>:</h4>
<blockquote>
<p>At some point we'll have to face the fact that fundamental theorem of Galois theory is not a Galois connection, as currently defined in mathlib</p>
</blockquote>
<p>it's OK, we can just define the order on subgroups to be <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>H</mi><mo>≤</mo><mi>K</mi><mspace width="0.277778em"></mspace><mo>⟺</mo><mspace width="0.277778em"></mspace><mi>K</mi><mo>⊆</mo><mi>H</mi></mrow><annotation encoding="application/x-tex">H\leq K\iff K\subseteq H</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="base"><span class="mord mathit" style="margin-right:0.08125em;">H</span><span class="mrel">≤</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mrel"><span class="mspace thickspace"></span><span class="mrel">⟺</span></span><span class="mord mathit"><span class="mspace thickspace"></span><span class="mord mathit" style="margin-right:0.07153em;">K</span></span><span class="mrel">⊆</span><span class="mord mathit" style="margin-right:0.08125em;">H</span></span></span></span></p>

<a name="167788647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167788647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167788647">Kevin Buzzard (Jun 10 2019 at 19:29)</a>:</h4>
<p>Probably that's what the order is in mathlib anyway :P</p>

<a name="167789433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/167789433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#167789433">Kevin Buzzard (Jun 10 2019 at 19:39)</a>:</h4>
<p>But don't do it on the subfields as well ;-)</p>

<a name="168055681"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168055681" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168055681">Patrick Massot (Jun 13 2019 at 15:28)</a>:</h4>
<p>I tried using <code>order_dual</code> to change the partial order on topologies but still have a Galois insertion, so that I can list the complete lattice instance from <code>set (set a)</code>.  But then of course the <code>has_top</code> instance is still the wrong one. Is this the issue the <code>copy</code> is meant to solve? I don't understand at all this copy thing in <code>order.fiilter.basic</code>. The beginning of the story looks like:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">topology</span><span class="bp">.</span><span class="n">basic</span>

<span class="kn">open</span> <span class="n">set</span> <span class="n">filter</span> <span class="n">lattice</span> <span class="n">classical</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">prop_decidable</span>

<span class="n">universes</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span>

<span class="kn">namespace</span> <span class="n">topological_space</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span>

<span class="c">/-</span><span class="cm">- The least topology containing a collection of basic sets. -/</span>
<span class="kn">inductive</span> <span class="n">generate_open</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">set</span> <span class="n">α</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">basic</span>  <span class="o">:</span> <span class="bp">∀</span><span class="n">s</span><span class="err">∈</span><span class="n">g</span><span class="o">,</span> <span class="n">generate_open</span> <span class="n">s</span>
<span class="bp">|</span> <span class="n">univ</span>   <span class="o">:</span> <span class="n">generate_open</span> <span class="n">univ</span>
<span class="bp">|</span> <span class="n">inter</span>  <span class="o">:</span> <span class="bp">∀</span><span class="n">s</span> <span class="n">t</span><span class="o">,</span> <span class="n">generate_open</span> <span class="n">s</span> <span class="bp">→</span> <span class="n">generate_open</span> <span class="n">t</span> <span class="bp">→</span> <span class="n">generate_open</span> <span class="o">(</span><span class="n">s</span> <span class="err">∩</span> <span class="n">t</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">sUnion</span> <span class="o">:</span> <span class="bp">∀</span><span class="n">k</span><span class="o">,</span> <span class="o">(</span><span class="bp">∀</span><span class="n">s</span><span class="err">∈</span><span class="n">k</span><span class="o">,</span> <span class="n">generate_open</span> <span class="n">s</span><span class="o">)</span> <span class="bp">→</span> <span class="n">generate_open</span> <span class="o">(</span><span class="err">⋃₀</span> <span class="n">k</span><span class="o">)</span>

<span class="c">/-</span><span class="cm">- The smallest topological space containing the collection `g` of basic sets -/</span>
<span class="n">def</span> <span class="n">generate_from</span> <span class="o">(</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span>        <span class="o">:=</span> <span class="n">generate_open</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">is_open_univ</span>   <span class="o">:=</span> <span class="n">generate_open</span><span class="bp">.</span><span class="n">univ</span> <span class="n">g</span><span class="o">,</span>
  <span class="n">is_open_inter</span>  <span class="o">:=</span> <span class="n">generate_open</span><span class="bp">.</span><span class="n">inter</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="n">generate_open</span><span class="bp">.</span><span class="n">sUnion</span>  <span class="o">}</span>

<span class="kn">end</span> <span class="n">topological_space</span>

<span class="kn">section</span> <span class="n">lattice</span>

<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">β</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">v</span><span class="o">}</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">partial_order</span> <span class="o">(</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">le</span>          <span class="o">:=</span> <span class="bp">λ</span> <span class="n">t</span> <span class="n">s</span><span class="o">,</span> <span class="n">s</span><span class="bp">.</span><span class="n">is_open</span> <span class="bp">≤</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open</span><span class="o">,</span>
  <span class="n">le_antisymm</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">t</span> <span class="n">s</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">topological_space_eq</span> <span class="err">$</span> <span class="n">le_antisymm</span> <span class="n">h₂</span> <span class="n">h₁</span><span class="o">,</span>
  <span class="n">le_refl</span>     <span class="o">:=</span> <span class="k">assume</span> <span class="n">t</span><span class="o">,</span> <span class="n">le_refl</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open</span><span class="o">,</span>
  <span class="n">le_trans</span>    <span class="o">:=</span> <span class="k">assume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">h₁</span> <span class="n">h₂</span><span class="o">,</span> <span class="n">le_trans</span> <span class="n">h₂</span> <span class="n">h₁</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">le_generate_from_iff_subset_is_open</span> <span class="o">{</span><span class="n">g</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)}</span> <span class="o">{</span><span class="n">t</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">t</span> <span class="bp">≤</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="n">g</span> <span class="bp">↔</span> <span class="n">g</span> <span class="err">⊆</span> <span class="o">{</span><span class="n">s</span> <span class="bp">|</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open</span> <span class="n">s</span><span class="o">}</span> <span class="o">:=</span>
<span class="n">iff</span><span class="bp">.</span><span class="n">intro</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">ht</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">ht</span> <span class="bp">_</span> <span class="err">$</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_open</span><span class="bp">.</span><span class="n">basic</span> <span class="n">s</span> <span class="n">hs</span><span class="o">)</span>
  <span class="o">(</span><span class="k">assume</span> <span class="n">hg</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">hs</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="k">assume</span> <span class="n">v</span> <span class="n">hv</span><span class="o">,</span> <span class="n">hg</span> <span class="n">hv</span><span class="o">)</span>
    <span class="n">t</span><span class="bp">.</span><span class="n">is_open_univ</span> <span class="o">(</span><span class="k">assume</span> <span class="n">u</span> <span class="n">v</span> <span class="bp">_</span> <span class="bp">_</span><span class="o">,</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open_inter</span> <span class="n">u</span> <span class="n">v</span><span class="o">)</span> <span class="o">(</span><span class="k">assume</span> <span class="n">k</span> <span class="bp">_</span><span class="o">,</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open_sUnion</span> <span class="n">k</span><span class="o">))</span>

<span class="kn">protected</span> <span class="n">def</span> <span class="n">mk_of_closure</span> <span class="o">(</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">))</span>
  <span class="o">(</span><span class="n">hs</span> <span class="o">:</span> <span class="o">{</span><span class="n">u</span> <span class="bp">|</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">is_open</span> <span class="n">u</span><span class="o">}</span> <span class="bp">=</span> <span class="n">s</span><span class="o">)</span> <span class="o">:</span> <span class="n">topological_space</span> <span class="n">α</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">is_open</span>        <span class="o">:=</span> <span class="bp">λ</span><span class="n">u</span><span class="o">,</span> <span class="n">u</span> <span class="err">∈</span> <span class="n">s</span><span class="o">,</span>
  <span class="n">is_open_univ</span>   <span class="o">:=</span> <span class="n">hs</span> <span class="bp">▸</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_open</span><span class="bp">.</span><span class="n">univ</span> <span class="bp">_</span><span class="o">,</span>
  <span class="n">is_open_inter</span>  <span class="o">:=</span> <span class="n">hs</span> <span class="bp">▸</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_open</span><span class="bp">.</span><span class="n">inter</span><span class="o">,</span>
  <span class="n">is_open_sUnion</span> <span class="o">:=</span> <span class="n">hs</span> <span class="bp">▸</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_open</span><span class="bp">.</span><span class="n">sUnion</span> <span class="o">}</span>

<span class="kn">lemma</span> <span class="n">mk_of_closure_sets</span> <span class="o">{</span><span class="n">s</span> <span class="o">:</span> <span class="n">set</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)}</span>
  <span class="o">{</span><span class="n">hs</span> <span class="o">:</span> <span class="o">{</span><span class="n">u</span> <span class="bp">|</span> <span class="o">(</span><span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="n">s</span><span class="o">)</span><span class="bp">.</span><span class="n">is_open</span> <span class="n">u</span><span class="o">}</span> <span class="bp">=</span> <span class="n">s</span><span class="o">}</span> <span class="o">:</span>
  <span class="n">mk_of_closure</span> <span class="n">s</span> <span class="n">hs</span> <span class="bp">=</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="n">s</span> <span class="o">:=</span>
<span class="n">topological_space_eq</span> <span class="n">hs</span><span class="bp">.</span><span class="n">symm</span>

<span class="n">def</span> <span class="n">gi_generate_from</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">@</span><span class="n">galois_insertion</span> <span class="bp">_</span> <span class="o">(</span><span class="n">order_dual</span> <span class="err">$</span> <span class="n">topological_space</span> <span class="n">α</span><span class="o">)</span> <span class="bp">_</span> <span class="bp">_</span>
    <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_from</span> <span class="o">(</span><span class="bp">λ</span><span class="n">t</span><span class="o">:</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">,</span> <span class="o">{</span><span class="n">s</span> <span class="bp">|</span> <span class="n">t</span><span class="bp">.</span><span class="n">is_open</span> <span class="n">s</span><span class="o">}):=</span>
<span class="o">{</span> <span class="n">gc</span>        <span class="o">:=</span> <span class="k">assume</span> <span class="n">t</span> <span class="n">g</span><span class="o">,</span> <span class="n">le_generate_from_iff_subset_is_open</span><span class="o">,</span>
  <span class="n">le_l_u</span>    <span class="o">:=</span> <span class="k">assume</span> <span class="n">t</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">topological_space</span><span class="bp">.</span><span class="n">generate_open</span><span class="bp">.</span><span class="n">basic</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span>
  <span class="n">choice</span>    <span class="o">:=</span> <span class="bp">λ</span><span class="n">g</span> <span class="n">hg</span><span class="o">,</span> <span class="n">mk_of_closure</span> <span class="n">g</span>
    <span class="o">(</span><span class="n">subset</span><span class="bp">.</span><span class="n">antisymm</span> <span class="n">hg</span> <span class="err">$</span>  <span class="n">le_generate_from_iff_subset_is_open</span><span class="bp">.</span><span class="mi">1</span> <span class="err">$</span> <span class="n">le_refl</span> <span class="bp">_</span><span class="o">),</span>
  <span class="n">choice_eq</span> <span class="o">:=</span> <span class="k">assume</span> <span class="n">s</span> <span class="n">hs</span><span class="o">,</span> <span class="n">mk_of_closure_sets</span> <span class="o">}</span>

<span class="kn">instance</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">:</span> <span class="n">complete_lattice</span> <span class="o">(</span><span class="n">topological_space</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">gi_generate_from</span> <span class="n">α</span><span class="o">)</span><span class="bp">.</span><span class="n">lift_complete_lattice</span>
</pre></div>


<p>This is accepted by Lean, but then I still have the discrete topology at top. I'm sorry this conversation is very sparse, but I'm at a conference, with very little Lean time.</p>

<a name="168055999"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168055999" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168055999">Johan Commelin (Jun 13 2019 at 15:31)</a>:</h4>
<p>Maybe the definition of the lattice structure on <code>opens X</code> helps? It uses Galois insertions, dual, and copy.</p>

<a name="168056422"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168056422" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168056422">Patrick Massot (Jun 13 2019 at 15:35)</a>:</h4>
<p>Did you write that?</p>

<a name="168056428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168056428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168056428">Patrick Massot (Jun 13 2019 at 15:35)</a>:</h4>
<p>Do you understand what's going on?</p>

<a name="168056546"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168056546" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168056546">Patrick Massot (Jun 13 2019 at 15:36)</a>:</h4>
<p>I don't understand why it seems to involve additional proofs in <code>copy</code> on top of the Galois insertion. How can there be any mathematical content?</p>

<a name="168056555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168056555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168056555">Patrick Massot (Jun 13 2019 at 15:36)</a>:</h4>
<p>I only want to reverse the order</p>

<a name="168057911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168057911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168057911">Mario Carneiro (Jun 13 2019 at 15:51)</a>:</h4>
<p>I think the galois insertion should be between <code>(topological_space α)</code> and <code>(order_dual $ set α)</code>, not <code>(order_dual $ topological_space α)</code> and <code>(set α)</code></p>

<a name="168067490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Order%20on%20topologies/near/168067490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/116395maths/78527Orderontopologies.html#168067490">Johan Commelin (Jun 13 2019 at 17:41)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I wrote it with help of Johannes. I think <code>copy</code> allows you to redefine the data parts of the structure, for better defeqs. But then you get proof obligations that the data is provably equal to what you get out of the duality. (That's what my memory tells me.) Maybe <span class="user-mention" data-user-id="110294">@Johannes Hölzl</span> can enlighten us.</p>


{% endraw %}
