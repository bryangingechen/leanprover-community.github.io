---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html">Debug "mutually inductive types compiled to invalid ..."</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="167726011"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167726011" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167726011">Kevin Sullivan (Jun 10 2019 at 01:30)</a>:</h4>
<p>In a separate thread I'm discussing the design of an affine space library. That's the context for this question. I need a mutually inductive definition of several types. I'm getting the following error message:</p>
<div class="codehilite"><pre><span></span>mutually inductive types compiled to invalid basic inductive type
nested exception message:
universe level of type_of(arg #4) of &#39;apoint._mut_.mk_0&#39; is too big for the corresponding inductive datatypeLean
</pre></div>


<p>The question is a basic one: how to debug this problem? It looks like I need to look at the compiled definition. Is that right? In that case, how? Or if it's obvious what's going wrong, I'd be happy simply to know the solution to this blocking problem, at least for right now.  I'm not posting the code at this point, hoping for insights without doing that, until the code's in better shape.</p>

<a name="167726084"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167726084" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167726084">Kenny Lau (Jun 10 2019 at 01:32)</a>:</h4>
<p>use <code>Type*</code> instead of manually calculating the universe</p>

<a name="167726246"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167726246" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167726246">Mario Carneiro (Jun 10 2019 at 01:37)</a>:</h4>
<p>could you show the definition?</p>

<a name="167726299"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167726299" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167726299">Mario Carneiro (Jun 10 2019 at 01:38)</a>:</h4>
<p>or at least the inductive itself, MWE not required</p>

<a name="167727591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167727591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167727591">Kevin Sullivan (Jun 10 2019 at 02:14)</a>:</h4>
<blockquote>
<p>or at least the inductive itself, MWE not required</p>
</blockquote>
<div class="codehilite"><pre><span></span>mutual inductive apoint, avector, aframe

with apoint :
    Π (s : space), Type
| mk :                      -- any point
    Π {s : space}
      (d : ℕ) [has_zero (fin d)]
      (K: Type) [discrete_field K]
      (coords : { c : tuple (d+1) K // c.nth 0 = 1 }),
      apoint s
| mk_std :
    Π { s : space }         -- std point, (1, 0, 0, ..., 0)
      (d : ℕ) [has_zero (fin d)]
      (K: Type) [discrete_field K],
      apoint s

with avector :
    Π (s : space), Type
| mk :
    Π {s : space}
      (d : ℕ) [has_zero (fin d)]
      (K: Type) [discrete_field K]
      (coords : { c : tuple (d+1) K // c.nth 0 = 1 }),
      avector s     -- was: aframe s → scalar → avector s
| mk_std :
    Π { s : space }         -- std vector(0, 0, 0, ..., 0)
      (d : ℕ) [has_zero (fin d)]
      (K: Type) [discrete_field K],
      avector s

with aframe :
    Π (s : space), Type
| mk : Π { s : space }, apoint s → avector s → aframe s
| mk_std : Π { s : space }, aframe s -- not yet complete
</pre></div>


<p>If I use Type*, I get an error at the end about inductive types having to live in the same universe.</p>

<a name="167727972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167727972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167727972">Kevin Sullivan (Jun 10 2019 at 02:25)</a>:</h4>
<p>It has a few things that need fixing, but this should give the idea.</p>

<a name="167728689"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167728689" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167728689">Floris van Doorn (Jun 10 2019 at 02:44)</a>:</h4>
<p>Change the types of <code>apoint</code>, <code>avector</code> and <code>aframe</code> to <code>space → Type (u+1)</code>(this is the same as <code>Π (s : space), Type (u+1)</code>), and change the types of all <code>K</code>s to <code>Type u</code>. If you don't like to worry about universe levels, you can set <code>u</code> to <code>0</code> (so only use <code>Type</code> - which is <code>Type 0</code> - and <code>Type 1</code>).</p>

<a name="167728693"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167728693" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167728693">Floris van Doorn (Jun 10 2019 at 02:44)</a>:</h4>
<p>Here is a simplified version of your MWE:</p>
<div class="codehilite"><pre><span></span>universe variable u
constant space : Type

mutual inductive apoint, avector, aframe

with apoint :
    Π (s : space), Type (u+1)
| mk :                      -- any point
    Π {s : space}
      (d : ℕ) [has_zero (fin d)]
      (K: Type u) [discrete_field K],
      apoint s
| mk_std :
    Π { s : space }         -- std point, (1, 0, 0, ..., 0)
      (d : ℕ) [has_zero (fin d)]
      (K: Type u) [discrete_field K],
      apoint s

with avector :
    Π (s : space), Type (u+1)
| mk :
    Π {s : space}
      (d : ℕ) [has_zero (fin d)]
      (K: Type u) [discrete_field K],
      avector s     -- was: aframe s → scalar → avector s
| mk_std :
    Π { s : space }         -- std vector(0, 0, 0, ..., 0)
      (d : ℕ) [has_zero (fin d)]
      (K: Type u) [discrete_field K],
      avector s

with aframe :
    Π (s : space), Type (u+1)
| mk : Π { s : space }, apoint s → avector s → aframe s
| mk_std : Π { s : space }, aframe s -- not yet complete
</pre></div>

<a name="167728708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/167728708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#167728708">Kenny Lau (Jun 10 2019 at 02:45)</a>:</h4>
<p>here is a simplified simplified version:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>

<span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">apoint</span><span class="o">,</span> <span class="n">aframe</span>
<span class="k">with</span> <span class="n">apoint</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">apoint</span>
<span class="k">with</span> <span class="n">aframe</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">apoint</span> <span class="bp">→</span> <span class="n">aframe</span>
</pre></div>

<a name="168450627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168450627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168450627">Kevin Sullivan (Jun 18 2019 at 20:07)</a>:</h4>
<blockquote>
<p>here is a simplified simplified version:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>

<span class="n">mutual</span> <span class="kn">inductive</span> <span class="n">apoint</span><span class="o">,</span> <span class="n">aframe</span>
<span class="k">with</span> <span class="n">apoint</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">apoint</span>
<span class="k">with</span> <span class="n">aframe</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">(</span><span class="n">u</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">mk</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="n">apoint</span> <span class="bp">→</span> <span class="n">aframe</span>
</pre></div>


</blockquote>
<p>I'm coming back to this.  I'm having another problem knowing what an error message means around mutually defined types. The context is that I'm defining an affine space. An affine space has points, vectors, frames. A point or a vector have coordinates and a frame in terms of which  coordinates have meaning. A frame in turn comprises a point (origin) and a set of vectors (a basis for the vector space). The problem that I'm having is that if I change the signature of the frame constructor from taking a point and a single vector to taking a point and a list of vectors, I get the following error at the top of the inductive definition: </p>
<div class="codehilite"><pre><span></span>nested occurrence &#39;list.{1} (affine_vector s)&#39; contains variables that are not parameters
</pre></div>


<p>Here's the self-contained code (which I'll be putting in an open GitHub repo once it works).</p>
<div class="codehilite"><pre><span></span>import algebra.module
import data.vector

-- for testing
import data.real.basic
set_option pp.notation false


-- UNDERLYING REPRESENTATION

--universe u

/-
Background: the &quot;vector&quot; type in the Lean standard library
is a type whose values are really just tuples. We define
a &quot;tuple&quot; type polymorphic as the type of tuples of length
n over values of a type, K.
-/
def tuple
    (n : ℕ)
    (K : Type) :=
        vector K n

-- testing
def aTuple : tuple 3 ℝ := ⟨[2,1,-1], rfl⟩
def aTuple&#39; : tuple 1 ℝ := ⟨[2], rfl⟩

/-
With K a discrete field with zero and one values,
we define a function to return tuples of length n
over K with all elements equal to the field&#39;s zero
element.
-/
def mk_zero_tuple :
    ∀ (n : ℕ)
    (K : Type)
    [f : discrete_field K]
    [z : has_zero K],
        vector K n
| 0 K f z := vector.nil
| (nat.succ n&#39;) K f z := vector.cons (z.zero) (@mk_zero_tuple n&#39; K f z)

-- testing
def aReal3ZeroTuple : tuple 3 ℝ :=
    subtype.mk [0,0,0] rfl
def aReal4ZeroTuple : tuple 4 ℝ :=
    subtype.mk [0,0,0,0] rfl


structure space : Type 1 :=
mk ::
(name : string)
(dim : ℕ)
(field: Type)
[isField : discrete_field field]
[the_zero : has_zero field]
[the_one : has_one field]

-- testing

def time : space :=         -- non-computable
    space.mk &quot;time&quot; 1 ℝ

def geometry : space :=
    space.mk &quot;geometry&quot; 3 ℝ

/-
We define affine point, vector, and frame types.
The space to which each such object belongs is a
part of its type. The definitions are mutually
recursive, because point and a vector are defined
partly in terms of a frame (in terms of which its
coordinates are interpreted), and a frame in turn
is defined by a point (its origin) and a tuple of
vectors (comprising a basis for its vector space).
-/

mutual inductive affine_point, affine_vector, affine_frame
with affine_point : space → Type 1
    | mk :
        Π { s : space },
        affine_frame s →
        tuple s.dim s.field  → affine_point s
    | mk_std :
        Π { s : space },         -- std point, (1, 0, 0, ..., 0) wrt std_frame
        affine_point s
with affine_vector : space → Type 1
    | mk :
        Π {s : space},
        affine_frame s →
        tuple s.dim s.field →
        affine_vector s
    | mk_std :
        Π { s : space },        -- std vector(0, 0, 0, ..., 0) wrt std_frame
        affine_vector s
with affine_frame : space → Type 1
    | mk : Π { s : space }, affine_point s → list (affine_vector s) → affine_frame s -- stub
    | mk_std : Π { s : space },  affine_frame s  -- std frame
</pre></div>


<p>I've tried with a universe variable, u, substituting Type (u+1), and also Type (u+2), for Type 1 where it appears in the mutual definition, to no avail. Thanks, all, for your ongoing help with this stuff.</p>
<p>Kevin</p>

<a name="168492943"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168492943" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168492943">Kevin Buzzard (Jun 19 2019 at 09:59)</a>:</h4>
<p>I've done a bunch of maths in Lean and I have never once had to use a mutually inductive type. I know nothing about them and this is why I can't help. Is there any way of just taking things apart and defining some normal inductive types?</p>

<a name="168495636"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/Debug%20%22mutually%20inductive%20types%20compiled%20to%20invalid%20...%22/near/168495636" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/55370Debugmutuallyinductivetypescompiledtoinvalid.html#168495636">Scott Morrison (Jun 19 2019 at 10:52)</a>:</h4>
<p><span class="user-mention" data-user-id="209463">@Ben Leedom</span> and I were faced with a mutual inductive definition when trying to define the product of CW complexes. Lean couldn't cope, so we unrolled it into a single inductive definition of a complicated structure (something like "product of CW complexes along with inclusions of products of the k- and l- skeleta of the factors")</p>


{% endraw %}
