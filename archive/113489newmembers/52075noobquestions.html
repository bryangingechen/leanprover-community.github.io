---
layout: page
title: Lean Prover Zulip Chat Archive 
permalink: archive/113489newmembers/52075noobquestions.html
---

<h2>Stream: <a href="https://leanprover-community.github.io/archive/113489newmembers/index.html">new members</a>
<h3>Topic: <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html">noob question(s)</a></h3>

<hr>

<base href="https://leanprover.zulipchat.com">
{% raw %}
<a name="148007940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148007940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148007940">Wojciech Nawrocki (Nov 20 2018 at 00:46)</a>:</h4>
<p>What's the command to make Lean automatically derive <code>decidable_eq</code> for some custom inductive type?</p>

<a name="148007958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148007958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148007958">Chris Hughes (Nov 20 2018 at 00:47)</a>:</h4>
<p>@[derive decidable_eq]</p>

<a name="148007972"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148007972" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148007972">Wojciech Nawrocki (Nov 20 2018 at 00:47)</a>:</h4>
<p>ah I should've thought of that, thanks! :)</p>

<a name="148013728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148013728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148013728">Wojciech Nawrocki (Nov 20 2018 at 03:18)</a>:</h4>
<p>Hm, when I add</p>
<div class="codehilite"><pre><span></span><span class="kn">open</span> <span class="n">classical</span>
<span class="n">local</span> <span class="n">attribute</span> <span class="o">[</span><span class="kn">instance</span><span class="o">]</span> <span class="n">prop_decidable</span>
</pre></div>


<p>to a file, definitions below it which used to pass now fail with:</p>
<div class="codehilite"><pre><span></span><span class="n">equation</span> <span class="n">compiler</span> <span class="n">failed</span> <span class="n">to</span> <span class="n">generate</span> <span class="n">bytecode</span> <span class="n">for</span> <span class="err">&#39;</span><span class="n">subst</span><span class="bp">._</span><span class="n">main&#39;</span>
<span class="n">nested</span> <span class="n">exception</span> <span class="n">message</span><span class="o">:</span>
<span class="n">code</span> <span class="n">generation</span> <span class="n">failed</span><span class="o">,</span> <span class="n">VM</span> <span class="n">does</span> <span class="n">not</span> <span class="k">have</span> <span class="n">code</span> <span class="n">for</span> <span class="err">&#39;</span><span class="n">classical</span><span class="bp">.</span><span class="n">choice&#39;</span>
</pre></div>


<p>Why might this be?</p>
<p>Is it basically because <code>classical</code> makes things uncomputable? If so, maybe Lean should detect that <code>classical</code> is not used in a particular case and still compile the definition?</p>

<a name="148013848"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148013848" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148013848">Chris Hughes (Nov 20 2018 at 03:21)</a>:</h4>
<p>Try <code>[instance, priority 0]</code>. Otherwise it uses classical decidability even when there's proper decidability.</p>

<a name="148013915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148013915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148013915">Wojciech Nawrocki (Nov 20 2018 at 03:23)</a>:</h4>
<p>Ah indeed, thanks Chris!</p>

<a name="148024166"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024166" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024166">Kevin Buzzard (Nov 20 2018 at 08:22)</a>:</h4>
<p>This trips lots of people up! I wonder where people are learning this trick? Not putting priority 0 can trip you up later in quite a confusing way</p>

<a name="148024213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024213">Patrick Massot (Nov 20 2018 at 08:23)</a>:</h4>
<p><span class="user-mention" data-user-id="110865">@Jeremy Avigad</span>  needs to fix the very bottom of <a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html</a></p>

<a name="148024215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024215">Johan Commelin (Nov 20 2018 at 08:23)</a>:</h4>
<p>I think Lean shows an error message when it can't find an instance for <code>decidable</code>, and that error message does not include setting the priority. It would be very helpful if it did.</p>

<a name="148024219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148024219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148024219">Patrick Massot (Nov 20 2018 at 08:23)</a>:</h4>
<p>and <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html</a></p>

<a name="148044684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148044684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148044684">Jeremy Avigad (Nov 20 2018 at 15:03)</a>:</h4>
<p>I'm on it -- I'll do it tomorrow.</p>

<a name="148049459"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049459" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049459">Patrick Massot (Nov 20 2018 at 16:08)</a>:</h4>
<p>Thanks!</p>

<a name="148049511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049511">Kenny Lau (Nov 20 2018 at 16:09)</a>:</h4>
<p>how about <em>not</em> using <code>classical.dec</code></p>

<a name="148049651"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049651" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049651">Reid Barton (Nov 20 2018 at 16:10)</a>:</h4>
<p>Let's just agree to not not use it</p>

<a name="148049677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049677">Kenny Lau (Nov 20 2018 at 16:11)</a>:</h4>
<p>that doesn't mean we <em>use</em> it :P</p>

<a name="148049697"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049697" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049697">Patrick Massot (Nov 20 2018 at 16:11)</a>:</h4>
<p>You may have missed Reid's point</p>

<a name="148049698"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148049698" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148049698">Reid Barton (Nov 20 2018 at 16:11)</a>:</h4>
<p>It doesn't mean <em>you</em> use it</p>

<a name="148074938"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148074938" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148074938">Wojciech Nawrocki (Nov 20 2018 at 22:59)</a>:</h4>
<p>Is it possible to make Lean display the values of constant variables in the tactic state? E.g. if i have <code>lst: list nat</code> which is also empty, it would be nice to see that it's empty.</p>

<a name="148075021"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075021" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075021">Kenny Lau (Nov 20 2018 at 23:01)</a>:</h4>
<p>either this doesn't make sense, or <code>subst lst</code></p>

<a name="148075182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075182">Wojciech Nawrocki (Nov 20 2018 at 23:04)</a>:</h4>
<p>Hm I should elaborate, maybe I'm misunderstanding how <code>induction</code> works. Say I have a hypothesis <code>h: InductiveFoo list.nil</code>, where <code>InductiveFoo: list nat -&gt; Prop</code>. So then running <code>induction h</code> creates cases for all the constructors of <code>InductiveFoo</code>, which take the list as an input, say <code>lst</code>. But the <code>lst</code> is empty, so it'd be nice to see that in the state.</p>

<a name="148075295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075295">Kenny Lau (Nov 20 2018 at 23:06)</a>:</h4>
<p>you can't because it's forgotten</p>

<a name="148075309"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075309" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075309">Kenny Lau (Nov 20 2018 at 23:06)</a>:</h4>
<p>you might want to <code>generalize_hyp</code></p>

<a name="148075886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148075886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148075886">Wojciech Nawrocki (Nov 20 2018 at 23:16)</a>:</h4>
<p>Thanks!</p>

<a name="148115433"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115433" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115433">Wojciech Nawrocki (Nov 21 2018 at 15:03)</a>:</h4>
<p>Perhaps it would be useful to have a reference sheet for translating from Coq to Lean tactics?</p>

<a name="148115539"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115539" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115539">Mario Carneiro (Nov 21 2018 at 15:05)</a>:</h4>
<p>I recall such a thing being made at one point. Maybe it's in mathlib docs?</p>

<a name="148115560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115560">Rob Lewis (Nov 21 2018 at 15:05)</a>:</h4>
<p><a href="https://github.com/jldodds/coq-lean-cheatsheet" target="_blank" title="https://github.com/jldodds/coq-lean-cheatsheet">https://github.com/jldodds/coq-lean-cheatsheet</a></p>

<a name="148115566"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115566" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115566">Rob Lewis (Nov 21 2018 at 15:05)</a>:</h4>
<p>Note the date though, it'll need updating.</p>

<a name="148115644"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148115644" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148115644">Wojciech Nawrocki (Nov 21 2018 at 15:06)</a>:</h4>
<p>Oh, nice!</p>

<a name="148119720"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148119720" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148119720">Wojciech Nawrocki (Nov 21 2018 at 16:06)</a>:</h4>
<p>Is there a general tactic for showing <code>false</code> by "this term could not have been constructed"? E.g.</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">Foo</span><span class="o">:</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">FooT</span><span class="o">:</span> <span class="n">Foo</span> <span class="n">true</span> <span class="n">true</span>
<span class="bp">|</span> <span class="n">FooF</span><span class="o">:</span> <span class="n">Foo</span> <span class="n">false</span> <span class="n">false</span>

<span class="c1">-- This term could not have been constructed</span>
<span class="kn">lemma</span> <span class="n">impossible</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">Foo</span> <span class="n">true</span> <span class="n">false</span><span class="o">)</span>
  <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">sorry</span>
</pre></div>

<a name="148120085"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120085" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120085">Mario Carneiro (Nov 21 2018 at 16:11)</a>:</h4>
<p><code>cases</code></p>

<a name="148120091"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120091" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120091">Mario Carneiro (Nov 21 2018 at 16:11)</a>:</h4>
<p>also empty match</p>

<a name="148120098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120098">Mario Carneiro (Nov 21 2018 at 16:11)</a>:</h4>
<div class="codehilite"><pre><span></span>lemma impossible : Foo true false → false.
</pre></div>

<a name="148120175"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120175" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120175">Rob Lewis (Nov 21 2018 at 16:12)</a>:</h4>
<p>You have to make <code>Foo : bool -&gt; bool -&gt; Prop</code> for that.</p>

<a name="148120216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120216">Wojciech Nawrocki (Nov 21 2018 at 16:13)</a>:</h4>
<p>Yeah, for <code>Prop -&gt; Prop -&gt; Prop</code> both of these fail, but that wasn't actually my problem, so thanks!</p>

<a name="148120406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148120406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148120406">Patrick Massot (Nov 21 2018 at 16:16)</a>:</h4>
<p>It seems that variations on this topic comes up again and again. We should really find a way to document that</p>

<a name="148134832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148134832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148134832">Wojciech Nawrocki (Nov 21 2018 at 20:17)</a>:</h4>
<p>That would be nice :) I was also surprised to see that more often than not <code>contradiction</code> fails when <code>cases h</code> works. Description: <code>The contradiction tactic attempts to find in the current local context an hypothesis that is equivalent to an empty inductive type (e.g. false)</code>. I thought a hypothesis that cannot be constructed is exactly that, but maybe I'm misunderstanding it?</p>

<a name="148147233"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148147233" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148147233">Wojciech Nawrocki (Nov 22 2018 at 01:12)</a>:</h4>
<p>Is it possible to reserve some notation for an inductive type and then use it while defining the type, like in Coq? I tried this,  but the parser seems to fail:</p>
<div class="codehilite"><pre><span></span><span class="n">reserve</span> <span class="kn">infix</span> <span class="bp">`</span><span class="err">∋</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span>

<span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="n">Typeof</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="n">Typeof</span> <span class="err">Γ</span> <span class="n">A</span> <span class="bp">→</span> <span class="n">Typeof</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="n">A</span>

<span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span> <span class="c1">-- fails</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>

<span class="kn">infix</span> <span class="err">∋</span> <span class="o">:=</span> <span class="n">Typeof</span>
</pre></div>

<a name="148150619"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148150619" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148150619">Mario Carneiro (Nov 22 2018 at 03:00)</a>:</h4>
<p>Yes! You can just put a notation line between the inductive header and the first constructor</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">{</span><span class="n">Tp</span><span class="o">}:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">infix</span> <span class="bp">`</span><span class="err">∋</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">Typeof</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
</pre></div>

<a name="148238627"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148238627" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148238627">Jeremy Avigad (Nov 23 2018 at 16:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110031">@Patrick Massot</span> I added a discussion of the <code>priority 0</code> trick to Section 10.4 of TPIL (search on "priority 0"):<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#decidable-propositions</a><br>
I also added a back reference in Section 11:<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle">https://leanprover.github.io/theorem_proving_in_lean/axioms_and_computation.html#the-law-of-the-excluded-middle</a></p>
<p>Finally, I fixed an old issue raised by <span class="user-mention" data-user-id="122022">@Joseph Corneli</span> by changing all the examples in 6.4:<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#attributes" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#attributes">https://leanprover.github.io/theorem_proving_in_lean/interacting_with_lean.html#attributes</a><br>
<a href="https://github.com/leanprover/theorem_proving_in_lean/issues/62" target="_blank" title="https://github.com/leanprover/theorem_proving_in_lean/issues/62">https://github.com/leanprover/theorem_proving_in_lean/issues/62</a></p>
<p>Teaching my class next semester will give me a chance to review and expand TPIL. I am planning to add one more chapter on some of the fine points of dependent type theory, e.g. explaining how to work with equality and dependent types (the dark side of type theory), and explaining how Lean manages recursion on arbitrary well-founded relations. I'll also try to write a less ambitious but up-to-date version of Programming in Lean. But I am counting on the mathlib crew to continue documenting mathlib and all the new tactics, and to provide useful guidance on using the library and proving theorems.</p>

<a name="148238846"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148238846" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148238846">Kevin Buzzard (Nov 23 2018 at 16:33)</a>:</h4>
<p>I have not been using Lean seriously since term started; there are three weeks to go before it finishes. After that I fully intend to go back to the perfectoid project. But when I don't understand something, my instinct is to write docs about it, because if I work something out and don't write down what I learnt then I realise a month later that I've forgotten it all again!</p>

<a name="148247373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148247373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148247373">Patrick Massot (Nov 23 2018 at 20:02)</a>:</h4>
<p>Thank you very much Jeremy! Your documentation work is really crucial.</p>

<a name="148249579"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148249579" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148249579">Patrick Massot (Nov 23 2018 at 21:06)</a>:</h4>
<p>I'm now reading random pieces of TPIL, and I have a couple more suggestions about chapter 10:</p>
<ul>
<li>at several places, emacs is mentioned but not VScode. I guess this goes back to before the VScode extension was available, but it could be misleading</li>
<li>in 10.5. Managing Type Class Inference, I think it would be nice to add the standard tricks to see what's the name of an instance Lean is finding, and sometimes what's the actual definition, as in</li>
</ul>
<div class="codehilite"><pre><span></span><span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span><span class="o">)</span>
</pre></div>


<p>maybe find a better example for the second one since the answer is not super easy to read (every nice example coming to my mind are in mathlib...)</p>

<a name="148249664"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148249664" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148249664">Patrick Massot (Nov 23 2018 at 21:09)</a>:</h4>
<p>Oh, it seems <code>apply_instance</code> is never mentioned in TPIL <span class="emoji emoji-2639" title="sad">:sad:</span></p>

<a name="148249726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148249726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148249726">Patrick Massot (Nov 23 2018 at 21:10)</a>:</h4>
<p>Another thing that would be very helpful, both because it can be puzzling and because it can be very helpful would be to discuss</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">n</span> <span class="o">:</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="bp">ℕ</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>  <span class="c1">-- ok</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>  <span class="c1">-- fails</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">unfold</span> <span class="n">n</span> <span class="bp">;</span> <span class="n">apply_instance</span>  <span class="c1">-- ok</span>
</pre></div>

<a name="148277429"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/148277429" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#148277429">Jeremy Avigad (Nov 24 2018 at 13:23)</a>:</h4>
<p>Thanks for the input. Yes, TPIL evolved over time, and the last major rewrite was early in the days of Lean 3, before there was a VSCode extension. I'll do a global search and try to make the text less emacs-centric.</p>
<p>I'll discuss <code>apply_instance</code> and <code>infer_instance</code>. I am thinking of using these examples:</p>
<div class="codehilite"><pre><span></span><span class="c">/-</span><span class="cm"> example 1: using apply_instance -/</span>

<span class="n">def</span> <span class="n">foo</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">nat</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>
<span class="n">def</span> <span class="n">bar</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="n">apply_instance</span>

<span class="c">/-</span><span class="cm"> example 2: using infer_instance -/</span>

<span class="n">def</span> <span class="n">baz</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">nat</span> <span class="o">:=</span> <span class="n">infer_instance</span>
<span class="n">def</span> <span class="n">bla</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">nat</span> <span class="bp">→</span> <span class="n">nat</span><span class="o">)</span> <span class="o">:=</span> <span class="n">infer_instance</span>

<span class="c">/-</span><span class="cm"> example 3: seeing them -/</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">foo</span>    <span class="c1">-- nat.has_add</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">foo</span>   <span class="c1">-- (unreadable)</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">bar</span>    <span class="c1">-- pi.inhabited ℕ</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">bar</span>   <span class="c1">-- {default := λ (a : ℕ), 0}</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">baz</span>    <span class="c1">-- infer_instance</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">baz</span>   <span class="c1">-- (same as for #reduce foo)</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">bla</span>    <span class="c1">-- infer_instance</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">bla</span>   <span class="c1">-- {default := λ (a : ℕ), 0}</span>

<span class="c">/-</span><span class="cm"> example 4: tricks to be more concise -/</span>

<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="k">by</span> <span class="n">apply_instance</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">nat</span><span class="bp">.</span><span class="n">inhabited</span>

<span class="bp">#</span><span class="n">reduce</span> <span class="o">(</span><span class="n">infer_instance</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="bp">ℕ</span><span class="o">)</span>

<span class="c">/-</span><span class="cm"> examples 5: core Lean can&#39;t find an instance for inhabited set -/</span>

<span class="c1">-- fails</span>
<span class="c1">-- example {α : Type*} : inhabited (set α) := by apply_instance</span>

<span class="c">/-</span><span class="cm"> example 6: supplying one manually -/</span>

<span class="n">def</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span> <span class="bp">⟨</span><span class="err">∅</span><span class="bp">⟩</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span>     <span class="c1">-- λ {α : Type u}, {default := ∅}</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="bp">ℕ</span>  <span class="c1">-- {default := λ (a : ℕ), false}</span>

<span class="c">/-</span><span class="cm"> example 7: unfolding a definition so Lean can find it -/</span>

<span class="n">def</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">unfold</span> <span class="n">set</span><span class="bp">;</span> <span class="n">apply_instance</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span>     <span class="c1">-- λ (α : Type u), eq.mpr _ (pi.inhabited α)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="bp">ℕ</span>  <span class="c1">-- {default := λ (a : ℕ), true}</span>

<span class="c">/-</span><span class="cm"> example 8: using dunfold instead -/</span>

<span class="n">def</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:</span> <span class="n">inhabited</span> <span class="o">(</span><span class="n">set</span> <span class="n">α</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">by</span> <span class="n">dunfold</span> <span class="n">set</span><span class="bp">;</span> <span class="n">apply_instance</span>
<span class="bp">#</span><span class="kn">print</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span>     <span class="c1">-- λ (α : Type u), id (pi.inhabited α)</span>
<span class="bp">#</span><span class="n">reduce</span> <span class="n">inhabited</span><span class="bp">.</span><span class="n">set</span> <span class="bp">ℕ</span>  <span class="c1">-- {default := λ (a : ℕ), true}</span>
</pre></div>

<a name="151432316"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432316" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432316">Patrick Massot (Dec 11 2018 at 09:17)</a>:</h4>
<blockquote>
<p>Yes! You can just put a notation line between the inductive header and the first constructor</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">Typeof</span><span class="o">{</span><span class="n">Tp</span><span class="o">}:</span> <span class="n">list</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="kn">infix</span> <span class="bp">`</span><span class="err">∋</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">Typeof</span>
<span class="bp">|</span> <span class="n">Z</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span><span class="o">,</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">A</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
<span class="bp">|</span> <span class="n">S_</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="err">Γ</span><span class="o">:</span> <span class="n">list</span> <span class="n">Tp</span><span class="o">)</span> <span class="n">A</span> <span class="n">B</span><span class="o">,</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">A</span> <span class="bp">→</span> <span class="o">(</span><span class="err">Γ</span><span class="bp">.</span><span class="n">append</span> <span class="o">[</span><span class="n">B</span><span class="o">])</span> <span class="err">∋</span> <span class="n">A</span>
</pre></div>


</blockquote>
<p>Is there something similar for dependant <code>structure</code>? If one field of my structure is a binary operator, can I define an infix notation usable in the remaining fields declaration?</p>

<a name="151432380"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432380" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432380">Kevin Buzzard (Dec 11 2018 at 09:18)</a>:</h4>
<p>I usually make the <code>structure</code> extend the notation typeclass in this situation.</p>

<a name="151432403"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432403" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432403">Kevin Buzzard (Dec 11 2018 at 09:19)</a>:</h4>
<p>In fact I have been known to make new notation typeclasses called things like <code>group_notation</code> extending <code>has_mul</code>, <code>has_one</code> and <code>has_inv</code>, and then extending these too so I get a bunch of notation at once.</p>

<a name="151432470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432470">Patrick Massot (Dec 11 2018 at 09:21)</a>:</h4>
<p>Thanks Kevin. I know all this, but I'm still interested in an answer to my question.</p>

<a name="151432479"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151432479" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151432479">Kevin Buzzard (Dec 11 2018 at 09:21)</a>:</h4>
<p>Yes I understand. For example if the notation is not in the standard notation list then it would be nicer to add it directly in the definition of the structure.</p>

<a name="151440921"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151440921" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151440921">Rob Lewis (Dec 11 2018 at 12:05)</a>:</h4>
<p>You can define notation in structures that's used in the remaining fields. But I think it's just local to the structure declaration.</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">patrick</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="o">(</span><span class="kn">infix</span> <span class="bp">`</span><span class="err">^^^</span><span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">f</span><span class="o">)</span>
<span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">a</span> <span class="err">^^^</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">patrick</span><span class="bp">.</span><span class="n">h</span>
</pre></div>

<a name="151445285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/151445285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#151445285">Patrick Massot (Dec 11 2018 at 13:29)</a>:</h4>
<p>Thanks!</p>

<a name="154258172"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154258172" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154258172">Jeremy Avigad (Jan 03 2019 at 18:49)</a>:</h4>
<p>I just crossed this item off my to do list. <code>apply_inference</code> and such are now discussed here: <a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference</a>. And VS Code is now mentioned whenever Emacs is, with VS Code first.</p>

<a name="154258563"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154258563" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154258563">Patrick Massot (Jan 03 2019 at 18:54)</a>:</h4>
<blockquote>
<p>If you add this to your file in Emacs mode and use C-c C-x to run an independent Lean process on your file, the output buffer will show a trace every time the type class resolution procedure is subsequently triggered.</p>
</blockquote>
<p>This paragraph (in the section your referred to) is still Emacs centric</p>

<a name="154260198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260198">Jeremy Avigad (Jan 03 2019 at 19:20)</a>:</h4>
<p>Yes, that is the only one, because I don't know how to start an independent Lean process from within VS Code. I guess I'll remind people that they can run Lean from the VS Code terminal.</p>

<a name="154260213"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260213" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260213">Patrick Massot (Jan 03 2019 at 19:20)</a>:</h4>
<p>Why would you do that?</p>

<a name="154260222"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260222" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260222">Patrick Massot (Jan 03 2019 at 19:20)</a>:</h4>
<p>The trace is printed in the info view</p>

<a name="154260439"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260439" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260439">Jeremy Avigad (Jan 03 2019 at 19:23)</a>:</h4>
<p>Oh! I forgot. Good point. I'll fix that.</p>

<a name="154260510"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154260510" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154260510">Patrick Massot (Jan 03 2019 at 19:24)</a>:</h4>
<p>Great!</p>

<a name="154261167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/154261167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#154261167">Jeremy Avigad (Jan 03 2019 at 19:34)</a>:</h4>
<p>Fixed. Thanks for catching it.<br>
<a href="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference">https://leanprover.github.io/theorem_proving_in_lean/type_classes.html#managing-type-class-inference</a></p>

<a name="155250652"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155250652" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155250652">Wojciech Nawrocki (Jan 16 2019 at 12:50)</a>:</h4>
<p>Hello! Is there anything special I need to do to make Lean recognise my <code>instance : has_zero Foo</code> as being equivalent to <code>0</code>? I got this state while trying to use <code>rw [this]</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">rewrite</span> <span class="n">tactic</span> <span class="n">failed</span><span class="o">,</span> <span class="n">did</span> <span class="n">not</span> <span class="n">find</span> <span class="kn">instance</span> <span class="n">of</span> <span class="n">the</span> <span class="n">pattern</span> <span class="k">in</span> <span class="n">the</span> <span class="n">target</span> <span class="n">expression</span>
  <span class="mi">0</span> <span class="bp">+</span> <span class="n">π₂</span>
<span class="n">state</span><span class="o">:</span>
<span class="mi">3</span> <span class="n">goals</span>
<span class="n">π₂</span> <span class="o">:</span> <span class="n">mult</span><span class="o">,</span>
<span class="n">this</span> <span class="o">:</span> <span class="mi">0</span> <span class="bp">+</span> <span class="n">π₂</span> <span class="bp">=</span> <span class="n">π₂</span>
<span class="err">⊢</span> <span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span> <span class="bp">+</span> <span class="n">π₂</span> <span class="bp">=</span> <span class="n">π₂</span> <span class="bp">+</span> <span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span>
</pre></div>


<p>even though I have</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span><span class="bp">⟩</span>
</pre></div>


<p>above</p>

<a name="155250968"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155250968" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155250968">Kevin Buzzard (Jan 16 2019 at 12:55)</a>:</h4>
<p>rewrites don't recognise definitional equality, only syntactic equality.</p>

<a name="155250980"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155250980" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155250980">Kevin Buzzard (Jan 16 2019 at 12:55)</a>:</h4>
<p>So you could try "show 0 + pi2 = _" before the rewrite</p>

<a name="155251052"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251052" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251052">Kevin Buzzard (Jan 16 2019 at 12:56)</a>:</h4>
<p>or "change mult.Zero + _ = _ at this". Maybe it will work after one of these changes. But not after both ;-)</p>

<a name="155251072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251072">Reid Barton (Jan 16 2019 at 12:56)</a>:</h4>
<p><code>convert this</code> should also work</p>

<a name="155251096"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251096" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251096">Kevin Buzzard (Jan 16 2019 at 12:57)</a>:</h4>
<p>but <code>this</code> isn't the goal</p>

<a name="155251103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251103">Kevin Buzzard (Jan 16 2019 at 12:57)</a>:</h4>
<p>Oh!</p>

<a name="155251182"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251182" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251182">Kevin Buzzard (Jan 16 2019 at 12:58)</a>:</h4>
<p>This <code>convert</code> trick works when the thing you're rewriting is precisely one side of the equality I guess.</p>

<a name="155251188"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251188" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251188">Reid Barton (Jan 16 2019 at 12:58)</a>:</h4>
<p>or <code>erw this</code> would also work but it's not as nice</p>

<a name="155251370"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155251370" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155251370">Reid Barton (Jan 16 2019 at 13:01)</a>:</h4>
<p>In fact you can use <code>a' = b'</code> to prove <code>a = b</code> with neither side matching definitionally (you'll get two new goals <code>a = a'</code> and <code>b = b'</code>), but then you run the risk that the new goals are not actually true <span class="emoji emoji-263a" title="smile">:smile:</span></p>

<a name="155252212"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252212" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252212">Wojciech Nawrocki (Jan 16 2019 at 13:13)</a>:</h4>
<p>Ah, I see, thanks! And related, I'm proving that an object with three elements and custom add/mult tables is a semiring, how ugly is it to do all my proofs like this?</p>
<div class="codehilite"><pre><span></span>  <span class="kn">lemma</span> <span class="n">add_assoc</span> <span class="o">(</span><span class="n">π₁</span> <span class="n">π₂</span> <span class="n">π₃</span><span class="o">:</span> <span class="n">mult</span><span class="o">)</span>
    <span class="o">:</span> <span class="n">π₁</span> <span class="bp">+</span> <span class="n">π₂</span> <span class="bp">+</span> <span class="n">π₃</span> <span class="bp">=</span> <span class="n">π₁</span> <span class="bp">+</span> <span class="o">(</span><span class="n">π₂</span> <span class="bp">+</span> <span class="n">π₃</span><span class="o">)</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">cases</span> <span class="n">π₁</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">π₂</span><span class="bp">;</span> <span class="n">cases</span> <span class="n">π₃</span><span class="bp">;</span> <span class="n">refl</span> <span class="o">}</span>
</pre></div>

<a name="155252434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252434">Mario Carneiro (Jan 16 2019 at 13:17)</a>:</h4>
<p>it will work, although there are simpler proofs where you ony case on one of them, I think</p>

<a name="155252646"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252646" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252646">Wojciech Nawrocki (Jan 16 2019 at 13:20)</a>:</h4>
<p>Hm, I found that without expanding every case, I had to do a bit more work by using other lemmas and so on. The definition of <code>add</code> is:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">mult</span><span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Zero</span><span class="o">:</span> <span class="n">mult</span>
<span class="bp">|</span> <span class="n">One</span><span class="o">:</span> <span class="n">mult</span>
<span class="bp">|</span> <span class="n">Omega</span><span class="o">:</span> <span class="n">mult</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_zero</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">mult</span><span class="bp">.</span><span class="n">Zero</span><span class="bp">⟩</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_one</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">mult</span><span class="bp">.</span><span class="n">One</span><span class="bp">⟩</span>

<span class="kn">notation</span> <span class="bp">`</span><span class="n">ω</span><span class="bp">`</span> <span class="o">:=</span> <span class="n">mult</span><span class="bp">.</span><span class="n">Omega</span>

<span class="n">def</span> <span class="n">add</span><span class="o">:</span> <span class="n">mult</span> <span class="bp">→</span> <span class="n">mult</span> <span class="bp">→</span> <span class="n">mult</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="n">π</span> <span class="o">:=</span> <span class="n">π</span>
<span class="bp">|</span> <span class="n">π</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">π</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">ω</span>
<span class="bp">|</span> <span class="n">ω</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">ω</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="n">ω</span> <span class="o">:=</span> <span class="n">ω</span>

<span class="kn">instance</span> <span class="o">:</span> <span class="n">has_add</span> <span class="n">mult</span> <span class="o">:=</span>
  <span class="bp">⟨</span><span class="n">add</span><span class="bp">⟩</span>
</pre></div>

<a name="155252763"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252763" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252763">Mario Carneiro (Jan 16 2019 at 13:22)</a>:</h4>
<p>right</p>

<a name="155252890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252890">Mario Carneiro (Jan 16 2019 at 13:24)</a>:</h4>
<p>you should have lemmas like <code>x + ω = ω</code> as simp lemmas which should simplify most of the cases</p>

<a name="155252915"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155252915" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155252915">Mario Carneiro (Jan 16 2019 at 13:25)</a>:</h4>
<p>or you could just split into 27 cases if you want</p>

<a name="155253007"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155253007" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155253007">Wojciech Nawrocki (Jan 16 2019 at 13:26)</a>:</h4>
<p>Ah ok, i'll try it with simp as well, thanks!</p>

<a name="155254705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155254705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155254705">Johan Commelin (Jan 16 2019 at 13:55)</a>:</h4>
<p>Scott Morrison's case-bashing tactic would probably be useful here. But I don't know where that tactic lives at the moment...</p>

<a name="155255138"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155255138" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155255138">Mario Carneiro (Jan 16 2019 at 14:01)</a>:</h4>
<p>if you want to do a case bashing proof, another approach is to prove <code>fintype mult</code> and <code>decidable_eq mult</code> (you can <code>derive</code> this), and then you can just revert everything and use <code>dec_trivial</code></p>

<a name="155255210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155255210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155255210">Johan Commelin (Jan 16 2019 at 14:02)</a>:</h4>
<p>Should even be reasonably fast, I guess.</p>

<a name="155255232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155255232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155255232">Mario Carneiro (Jan 16 2019 at 14:02)</a>:</h4>
<p>as long as you don't have too many variables; it is still 27 cases</p>

<a name="155256347"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155256347" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155256347">Kevin Buzzard (Jan 16 2019 at 14:18)</a>:</h4>
<p>Kind of a stupid question, but when I'm using other computer algebra systems I would expect checking a million cases to be very quick. Mario's comments suggest that 27 is rather large for Lean. What is happening here?</p>

<a name="155257947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155257947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155257947">Mario Carneiro (Jan 16 2019 at 14:37)</a>:</h4>
<p>There is a large overhead of the expression that is generated, elaboration for it, and typechecking</p>

<a name="155258030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258030">Mario Carneiro (Jan 16 2019 at 14:38)</a>:</h4>
<p>I don't think 27 is that large in this context, I guess it's probably less than a second to check</p>

<a name="155258059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258059">Mario Carneiro (Jan 16 2019 at 14:38)</a>:</h4>
<p>I just think it's better to have more "human" proofs with fewer cases</p>

<a name="155258070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258070">Kevin Buzzard (Jan 16 2019 at 14:38)</a>:</h4>
<p>This is what I don't understand. We have to check that 27 things of the form add a (add b c) = add (add a b) c hold and in each case this is by refl.</p>

<a name="155258119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258119">Kevin Buzzard (Jan 16 2019 at 14:39)</a>:</h4>
<p>How long does it take Lean to prove (0 + 1) + 1 = 0 + (1 + 1) in this type?</p>

<a name="155258201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258201">Mario Carneiro (Jan 16 2019 at 14:40)</a>:</h4>
<p>there is also all the intermediate steps, the generation of motives, lots of abstraction and substitution going on, and large terms being built up behind the scenes before you even attack those 27 cases</p>

<a name="155258224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258224">Kevin Buzzard (Jan 16 2019 at 14:40)</a>:</h4>
<p>So the bottleneck is elsewhere?</p>

<a name="155258252"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258252" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258252">Mario Carneiro (Jan 16 2019 at 14:41)</a>:</h4>
<p>I have heard it repeatedly asserted that the kernel is not a bottleneck</p>

<a name="155258265"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258265" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258265">Kevin Buzzard (Jan 16 2019 at 14:41)</a>:</h4>
<p>Again the idea of a "large" term is confusing to me. In python I could happily manipulate a list with 1000 elements.</p>

<a name="155258275"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258275" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258275">Mario Carneiro (Jan 16 2019 at 14:41)</a>:</h4>
<p>this term has way more than 1000 subterms</p>

<a name="155258304"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258304" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258304">Kevin Buzzard (Jan 16 2019 at 14:41)</a>:</h4>
<p>One of my kids has been learning about algorithms over the last few months and I realise now that I am far more aware of these things than I used to be.</p>

<a name="155258379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258379">Mario Carneiro (Jan 16 2019 at 14:42)</a>:</h4>
<p>all in all it makes lean just look a lot slower to do "simple" things</p>

<a name="155258393"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258393" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258393">Mario Carneiro (Jan 16 2019 at 14:42)</a>:</h4>
<p>because there is a lot of bookkeeping in the background</p>

<a name="155258552"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155258552" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155258552">Mario Carneiro (Jan 16 2019 at 14:44)</a>:</h4>
<p>I would like to figure out ways to minimize the overhead, but that runs close to work on the lean compiler</p>

<a name="155261902"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155261902" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155261902">Kevin Buzzard (Jan 16 2019 at 15:28)</a>:</h4>
<blockquote>
<p>this term has way more than 1000 subterms</p>
</blockquote>
<p>In the same way that a set with 10 elements has more than 1000 subsets, or in a more serious "we really need to work with way more than 1000 things" way?</p>

<a name="155263745"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155263745" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155263745">Mario Carneiro (Jan 16 2019 at 15:50)</a>:</h4>
<p>in the more serious way. (It's tricky to count the "size" of an expression but number of subterms is a good proxy)</p>

<a name="155263817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/155263817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#155263817">Mario Carneiro (Jan 16 2019 at 15:51)</a>:</h4>
<p>there is no exponential growth because subterms can't overlap, they are either disjoint or in a containment relationship</p>

<a name="156331129"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156331129" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156331129">Wojciech Nawrocki (Jan 18 2019 at 00:04)</a>:</h4>
<p>Is it possible to define a custom synthesis strategy for an implicit argument? I would like to define a function which extracts concrete values from concrete lists, like so:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">get&#39;</span><span class="o">:</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">l</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">h</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span><span class="o">},</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="bp">::</span><span class="n">xs</span><span class="o">)</span> <span class="mi">0</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">x</span><span class="bp">::</span><span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="bp">@</span><span class="n">get&#39;</span> <span class="n">xs</span> <span class="n">n</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_succ_lt_succ</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">n</span> <span class="n">h</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">not_lt_zero</span> <span class="n">n</span><span class="o">)</span>
</pre></div>


<p>and for concrete args, <code>h</code> is always derivable with a custom tactic. I'd like Lean to use that tactic to synthesise it.<br>
OR am I doing this completely wrong and there is a much simpler way?</p>

<a name="156331279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156331279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156331279">Chris Hughes (Jan 18 2019 at 00:07)</a>:</h4>
<p>unification hints! I don't know much about them though.</p>

<a name="156334847"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156334847" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156334847">Mario Carneiro (Jan 18 2019 at 00:51)</a>:</h4>
<p>This function is <code>list.nth_le</code> btw</p>

<a name="156334971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156334971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156334971">Mario Carneiro (Jan 18 2019 at 00:53)</a>:</h4>
<p>you can synthesize the argument using typeclasses, but <code>exact_dec_trivial</code> is another easy way to do it</p>

<a name="156335048"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156335048" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156335048">Mario Carneiro (Jan 18 2019 at 00:54)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">get&#39;</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span> <span class="bp">.</span> <span class="n">exact_dec_trivial</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">l</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">h</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">get&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="156335623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156335623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156335623">Wojciech Nawrocki (Jan 18 2019 at 01:07)</a>:</h4>
<p>Ah indeed, thanks Mario! Can I use something like this in a Pi-type (to make the equation compiler work)? The <code>foo . tactic</code> syntax doesn't seem to work:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">debrujin_of_nat</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">:</span> <span class="n">Env</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">h</span><span class="o">:</span> <span class="n">n</span> <span class="bp">&lt;</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">length</span> <span class="bp">.</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span><span class="o">),</span> <span class="o">(</span><span class="err">Γ</span> <span class="err">∋</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">h</span><span class="o">)</span> <span class="c1">-- ill-formed declaration</span>
</pre></div>

<a name="156335911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156335911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156335911">Mario Carneiro (Jan 18 2019 at 01:14)</a>:</h4>
<p>If you can put it left of the colon, the dot notation should work. But if you can't write it that way, it's sugar for <code>auto_param</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">get&#39;</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">l</span> <span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="n">auto_param</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;</span> <span class="n">l</span><span class="bp">.</span><span class="n">length</span><span class="o">)</span> <span class="bp">``</span><span class="n">exact_dec_trivial</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="o">:=</span> <span class="n">list</span><span class="bp">.</span><span class="n">nth_le</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">get&#39;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">]</span> <span class="mi">1</span> <span class="bp">=</span> <span class="mi">2</span> <span class="o">:=</span> <span class="n">rfl</span>
</pre></div>

<a name="156336087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336087">Wojciech Nawrocki (Jan 18 2019 at 01:19)</a>:</h4>
<p>Can I have a _named_ <code>auto_param</code> <span class="emoji emoji-1f605" title="sweat smile">:sweat_smile:</span>? I need to use the hypothesis in the type signature itself, more specifically in the return type.</p>

<a name="156336185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336185">Mario Carneiro (Jan 18 2019 at 01:21)</a>:</h4>
<p>sure, just use a pi instead of an arrow</p>

<a name="156336193"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336193" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336193">Mario Carneiro (Jan 18 2019 at 01:21)</a>:</h4>
<p><code>auto_param T n</code> is defeq to <code>T</code> so it doesn't cause any problems</p>

<a name="156336460"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336460" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336460">Wojciech Nawrocki (Jan 18 2019 at 01:27)</a>:</h4>
<p>Oh, I was sure I'd tried that but apparently not, thanks! Doesn't seem to work under <code>#eval</code> unfortunately:</p>
<div class="codehilite"><pre><span></span><span class="n">don&#39;t</span> <span class="n">know</span> <span class="n">how</span> <span class="n">to</span> <span class="n">synthesize</span> <span class="n">placeholder</span>
<span class="kn">context</span><span class="o">:</span>
<span class="err">⊢</span> <span class="n">auto_param</span> <span class="o">(</span><span class="mi">0</span> <span class="bp">&lt;</span> <span class="n">list</span><span class="bp">.</span><span class="n">length</span> <span class="o">[</span><span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span><span class="o">])</span> <span class="o">(</span><span class="n">name</span><span class="bp">.</span><span class="n">mk_string</span> <span class="s2">&quot;exact_dec_trivial&quot;</span> <span class="o">(</span><span class="n">name</span><span class="bp">.</span><span class="n">mk_string</span> <span class="s2">&quot;tactic&quot;</span> <span class="n">name</span><span class="bp">.</span><span class="n">anonymous</span><span class="o">))</span>
</pre></div>

<a name="156336541"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336541" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336541">Mario Carneiro (Jan 18 2019 at 01:29)</a>:</h4>
<p>what did you write?</p>

<a name="156336637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336637">Mario Carneiro (Jan 18 2019 at 01:30)</a>:</h4>
<p>it's not really related to the context you write it in, but rather the expected type during elaboration</p>

<a name="156336845"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336845" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336845">Wojciech Nawrocki (Jan 18 2019 at 01:35)</a>:</h4>
<p>Apologies for the length, but this is the full context:</p>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">find</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">interactive</span>
<span class="kn">import</span> <span class="n">tactic</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">auto_cases</span>
<span class="kn">import</span> <span class="n">tactic</span><span class="bp">.</span><span class="n">tidy</span>

<span class="bp">@</span><span class="o">[</span><span class="n">derive</span> <span class="n">decidable_eq</span><span class="o">]</span>
<span class="kn">inductive</span> <span class="n">Tp</span>
<span class="bp">|</span> <span class="n">Nat</span><span class="o">:</span> <span class="n">Tp</span>
<span class="bp">|</span> <span class="n">Bool</span><span class="o">:</span> <span class="n">Tp</span>
<span class="bp">|</span> <span class="n">Fn</span><span class="o">:</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="n">Tp</span>

<span class="n">local</span> <span class="kn">infixr</span> <span class="bp">`</span> <span class="err">⇒</span> <span class="bp">`</span><span class="o">:</span><span class="mi">50</span> <span class="o">:=</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Fn</span>

<span class="n">def</span> <span class="n">Env</span> <span class="o">:=</span> <span class="n">list</span> <span class="n">Tp</span>

<span class="kn">inductive</span> <span class="n">TypeIn</span><span class="o">:</span> <span class="n">Env</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="kn">infix</span> <span class="bp">`</span> <span class="err">∋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">40</span> <span class="o">:=</span> <span class="n">TypeIn</span>
<span class="bp">|</span> <span class="n">ZVar</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span><span class="o">},</span> <span class="n">T</span><span class="bp">::</span><span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span>
<span class="bp">|</span> <span class="n">SVar</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span> <span class="n">U</span><span class="o">},</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">U</span><span class="bp">::</span><span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span>

<span class="n">local</span> <span class="kn">infix</span> <span class="bp">`</span> <span class="err">∋</span> <span class="bp">`</span><span class="o">:</span><span class="mi">40</span> <span class="o">:=</span> <span class="n">TypeIn</span>

<span class="kn">open</span> <span class="n">TypeIn</span>

<span class="kn">inductive</span> <span class="n">Term</span><span class="o">:</span> <span class="n">Env</span> <span class="bp">→</span> <span class="n">Tp</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Nat</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">},</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="c1">-- in all environments, nat literals have type Nat</span>
<span class="bp">|</span> <span class="n">Bool</span> <span class="o">(</span><span class="n">b</span><span class="o">:</span> <span class="n">bool</span><span class="o">):</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">},</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Bool</span> <span class="c1">-- and booleans have type Bool</span>
<span class="bp">|</span> <span class="n">Var</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span><span class="o">},</span> <span class="err">Γ</span> <span class="err">∋</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">T</span> <span class="c1">-- A variable has type T given its de Brujin index</span>
                                 <span class="c1">-- is in the environment.</span>
<span class="bp">|</span> <span class="n">Abs</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span> <span class="n">U</span><span class="o">},</span> <span class="n">Term</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="n">U</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">T</span> <span class="err">⇒</span> <span class="n">U</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">App</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span> <span class="n">T</span> <span class="n">U</span><span class="o">},</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="o">(</span><span class="n">T</span> <span class="err">⇒</span> <span class="n">U</span><span class="o">)</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">T</span> <span class="bp">→</span> <span class="n">Term</span> <span class="err">Γ</span> <span class="n">U</span>

<span class="kn">open</span> <span class="n">Term</span>

<span class="n">def</span> <span class="n">debrujin_of_nat</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="err">Γ</span><span class="o">:</span> <span class="n">Env</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">{</span><span class="n">h</span><span class="o">:</span> <span class="n">auto_param</span> <span class="o">(</span><span class="n">n</span> <span class="bp">&lt;</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">length</span><span class="o">)</span> <span class="bp">``</span><span class="n">tactic</span><span class="bp">.</span><span class="n">exact_dec_trivial</span><span class="o">},</span> <span class="o">(</span><span class="err">Γ</span> <span class="err">∋</span> <span class="err">Γ</span><span class="bp">.</span><span class="n">nth_le</span> <span class="n">n</span> <span class="n">h</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="mi">0</span> <span class="bp">_</span> <span class="o">:=</span> <span class="n">ZVar</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="err">Γ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="n">h</span> <span class="o">:=</span> <span class="n">SVar</span> <span class="o">(</span><span class="bp">@</span><span class="n">debrujin_of_nat</span> <span class="err">Γ</span> <span class="n">n</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">lt_of_succ_lt_succ</span> <span class="n">h</span><span class="o">))</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="n">n</span> <span class="n">h</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">exfalso</span><span class="o">,</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span> <span class="n">exact</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">not_lt_zero</span> <span class="n">n</span><span class="o">)</span> <span class="n">h</span> <span class="o">}</span>

<span class="n">local</span> <span class="kn">notation</span> <span class="bp">`#`</span> <span class="n">n</span> <span class="o">:=</span> <span class="n">Var</span> <span class="o">(</span><span class="n">debrujin_of_nat</span> <span class="n">n</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">eval</span> <span class="o">(</span><span class="bp">@</span><span class="n">App</span> <span class="o">[]</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">Abs</span> <span class="o">[]</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="o">(</span><span class="bp">@</span><span class="n">Var</span> <span class="o">[</span><span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span><span class="o">]</span> <span class="n">Tp</span><span class="bp">.</span><span class="n">Nat</span> <span class="o">(</span><span class="n">debrujin_of_nat</span> <span class="mi">0</span><span class="o">)))</span> <span class="o">(</span><span class="bp">@</span><span class="n">Nat</span> <span class="mi">3</span> <span class="o">[]))</span>
</pre></div>

<a name="156336955"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156336955" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156336955">Wojciech Nawrocki (Jan 18 2019 at 01:37)</a>:</h4>
<p>Basically given a concrete <code>list Tp</code> and a concrete <code>n</code>, I'd like it to figure out that <code>n</code> is within bounds and include the result of <code>lst.nth_le n _</code> in the return type.</p>

<a name="156337127"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156337127" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156337127">Wojciech Nawrocki (Jan 18 2019 at 01:41)</a>:</h4>
<p>This does work: <code>#eval (@App [] Tp.Nat Tp.Nat (@Abs [] Tp.Nat Tp.Nat (@Var [Tp.Nat] Tp.Nat (@debrujin_of_nat [Tp.Nat] 0 (by tactic.exact_dec_trivial)))) (@Nat 3 []))</code> (notice the explicit proof I put in)</p>

<a name="156338055"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338055" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338055">Mario Carneiro (Jan 18 2019 at 02:06)</a>:</h4>
<p>so what did you write?</p>

<a name="156338116"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338116" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338116">Wojciech Nawrocki (Jan 18 2019 at 02:07)</a>:</h4>
<p>Well, the <code>#eval</code> at the bottom of that long snippet is what fails synthesis. The <code>#eval</code> with an explicit proof works</p>

<a name="156338117"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338117" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338117">Mario Carneiro (Jan 18 2019 at 02:07)</a>:</h4>
<p>aha, you made the arg implicit</p>

<a name="156338118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338118">Mario Carneiro (Jan 18 2019 at 02:07)</a>:</h4>
<p>auto params should be explicit</p>

<a name="156338120"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338120" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338120">Mario Carneiro (Jan 18 2019 at 02:07)</a>:</h4>
<div class="codehilite"><pre><span></span>def debrujin_of_nat: Π {Γ: Env} (n: ℕ) (h: auto_param (n &lt; Γ.length) ``tactic.exact_dec_trivial), (Γ ∋ Γ.nth_le n h)
</pre></div>

<a name="156338198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156338198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156338198">Wojciech Nawrocki (Jan 18 2019 at 02:09)</a>:</h4>
<p>Oh thanks, now it does work, but still behaves as if it were implicit <span class="emoji emoji-1f914" title="thinking">:thinking:</span> is this currying at work, meaning I have to place <code>auto_param</code> last, s.t. given <code>foo: nat -&gt; auto_param blah -&gt; nat</code>, <code>(foo n): nat</code> (and <code>foo n _</code> still fails)?</p>

<a name="156408748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156408748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156408748">Wojciech Nawrocki (Jan 18 2019 at 23:39)</a>:</h4>
<p>(unrelated to above)<br>
I'm seeing a wierd error in an inductive type: <code>invalid occurrence of recursive arg#3 of 'context.cons', the body of the functional type depends on it.</code>. The type definition is below, and as far as I know it's a perfectly legit defn, so what's wrong?</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="kn">context</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="kn">context</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">cons</span> <span class="o">{</span><span class="n">ns</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="bp">_</span><span class="o">:</span> <span class="kn">context</span> <span class="n">ns</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="kn">context</span> <span class="o">(</span><span class="n">n</span><span class="bp">::</span><span class="n">ns</span><span class="o">)</span>
</pre></div>


<p>EDIT: swapping two arguments makes it compile, but why?</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="kn">context</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">nil</span><span class="o">:</span> <span class="kn">context</span> <span class="o">[]</span>
<span class="bp">|</span> <span class="n">cons</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">ns</span><span class="o">:</span> <span class="n">list</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="bp">_</span><span class="o">:</span> <span class="kn">context</span> <span class="n">ns</span><span class="o">)</span> <span class="o">(</span><span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">),</span> <span class="kn">context</span> <span class="o">(</span><span class="n">n</span><span class="bp">::</span><span class="n">ns</span><span class="o">)</span>
</pre></div>

<a name="156409198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156409198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156409198">Mario Carneiro (Jan 18 2019 at 23:48)</a>:</h4>
<p>I think Gabriel recently pointed out an example similar to this. You have a dependent pi (<code>n</code>) after a recursive arg (<code>_ : context ns</code>) and lean doesn't like this</p>

<a name="156411833"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156411833" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156411833">Wojciech Nawrocki (Jan 19 2019 at 00:37)</a>:</h4>
<p>Ah ok, maybe this could be fixed in Lean 4? :)</p>

<a name="156414862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156414862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156414862">Wojciech Nawrocki (Jan 19 2019 at 01:51)</a>:</h4>
<p>Do I need to do something special to make the semiring-ness of my custom type available to the <code>ring</code> tactic? I have a state like this:</p>
<div class="codehilite"><pre><span></span><span class="n">π</span> <span class="n">π&#39;</span> <span class="o">:</span> <span class="n">mult</span><span class="o">,</span>
<span class="n">π_1</span> <span class="o">:</span> <span class="n">mult</span><span class="o">,</span>
<span class="err">⊢</span> <span class="n">π</span> <span class="bp">*</span> <span class="n">π&#39;</span> <span class="bp">*</span> <span class="n">π_1</span> <span class="bp">=</span> <span class="n">π</span> <span class="bp">*</span> <span class="o">(</span><span class="n">π&#39;</span> <span class="bp">*</span> <span class="n">π_1</span><span class="o">)</span>
</pre></div>


<p>which is provable by <code>exact mult.monoid.mul_assoc π π' π_1</code>, but <code>ring</code> fails. I have <code>instance : semiring mult</code> shown a few lines above.</p>

<a name="156415302"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156415302" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156415302">Mario Carneiro (Jan 19 2019 at 02:01)</a>:</h4>
<p>you need to prove <code>comm_semiring mult</code></p>

<a name="156554174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554174">Wojciech Nawrocki (Jan 21 2019 at 18:36)</a>:</h4>
<p>Given <code>def add (a b: foo): foo := blah</code>, what's the difference between <code>infix </code> ++ <code> := add</code> and <code>instance : has_add foo := ⟨add⟩</code>? If i switch from the former to the latter and replace <code>++</code> with <code>+</code>, my proofs break at the simplification stage, namely addition seems to not be <code>unfold</code>able anymore</p>

<a name="156554210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554210">Kevin Buzzard (Jan 21 2019 at 18:37)</a>:</h4>
<p>They're very different in the sense that they're using different machinery to figure out what's going on.</p>

<a name="156554280"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554280" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554280">Kevin Buzzard (Jan 21 2019 at 18:38)</a>:</h4>
<p>I guess the <code>infix</code> trick is just syntax sugar, whereas the <code>instance</code> approach is using type class inference. Can you give an example of something which breaks?</p>

<a name="156554315"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554315" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554315">Kevin Buzzard (Jan 21 2019 at 18:39)</a>:</h4>
<p>I guess if you go via the instance approach then you have an extra layer of unfolding to do. <code>+</code> is <code>has_add.add</code>, which unfolds to your add.</p>

<a name="156554337"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554337" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554337">Kevin Buzzard (Jan 21 2019 at 18:39)</a>:</h4>
<p>Maybe that's the answer to your question. If you're trying to unfold things explicitly in the middle of a proof, maybe you have to insert some <code>unfold has_add.add</code>'s</p>

<a name="156554416"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554416" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554416">Kevin Buzzard (Jan 21 2019 at 18:40)</a>:</h4>
<p><code>++</code> unfolds directly to your <code>add</code>, whereas <code>+</code> unfolds to <code>has_add.add</code> which unfolds to your add.</p>

<a name="156554455"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554455" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554455">Kevin Buzzard (Jan 21 2019 at 18:42)</a>:</h4>
<p>[NB I'm a bit of a CS noob, I don't know if "unfolds" is the right terminology for notation turning into its underlying definition]</p>

<a name="156554512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156554512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156554512">Kevin Buzzard (Jan 21 2019 at 18:42)</a>:</h4>
<p>[they might well be syntactically equal rather than just definitionally equal]</p>

<a name="156556743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156556743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156556743">Wojciech Nawrocki (Jan 21 2019 at 19:29)</a>:</h4>
<p>Ah indeed, <code>unfold</code>ing twice does make it work - thanks!</p>

<a name="156571293"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156571293" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156571293">Wojciech Nawrocki (Jan 22 2019 at 01:12)</a>:</h4>
<p>Does there exist a general tactic for proving <code>f a0 .. an = f b0 .. bn</code> from <code>a0 = b0 .. an = bn</code>?</p>

<a name="156571984"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156571984" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156571984">Mario Carneiro (Jan 22 2019 at 01:33)</a>:</h4>
<p><code>congr</code></p>

<a name="156572109"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156572109" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156572109">Wojciech Nawrocki (Jan 22 2019 at 01:36)</a>:</h4>
<p>Hm, I tried <code>congr</code> but it seems to iterate the congruence, which gives me unprovable goals. Namely, I have a goal <code>f (g x) = f (g y)</code> and <code>congr</code> gives me <code>x = y</code> but I just want <code>g x = g y</code>. EDIT: <code>congr' 1</code> works, thx!</p>

<a name="156574364"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156574364" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156574364">Mario Carneiro (Jan 22 2019 at 02:37)</a>:</h4>
<p>use <code>congr' 1</code> and increase the number until you get a good result</p>

<a name="156647038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647038">Wojciech Nawrocki (Jan 22 2019 at 22:43)</a>:</h4>
<p>The issue of <code>has_add.add</code> and its actual value not being definitionally equal makes a lot of my proofs quite ugly - I have to expand definitions first so that the expressions can simplify and then fold them back into the <code>has_add.add</code> version (or <code>has_mul.mul</code>, etc), because all the ring/module/whatever laws only work on those. For example:</p>
<div class="codehilite"><pre><span></span>  <span class="o">{</span> <span class="c">/-</span><span class="cm"></span>
<span class="cm">    case context.cons</span>
<span class="cm">    δ γ γ₁ : precontext,</span>
<span class="cm">    π₁ : mult,</span>
<span class="cm">    T₁ : tp,</span>
<span class="cm">    Γ₁ : context γ₁,</span>
<span class="cm">    ih₁ : ∀ {Γ₂ : context γ₁} {Ξ : matrix γ₁ δ}, vmul (Γ₁ + Γ₂) Ξ = vmul Γ₁ Ξ + vmul Γ₂ Ξ,</span>
<span class="cm">    Γ₂ : context (T₁ :: γ₁),</span>
<span class="cm">    Ξ : matrix (T₁ :: γ₁) δ</span>
<span class="cm">    ⊢ vmul (cons π₁ T₁ Γ₁ + Γ₂) Ξ = vmul (cons π₁ T₁ Γ₁) Ξ + vmul Γ₂ Ξ</span>
<span class="cm">    -/</span>
    <span class="n">cases</span> <span class="err">Γ₂</span> <span class="k">with</span> <span class="bp">_</span> <span class="n">π₂</span> <span class="bp">_</span> <span class="err">Γ₂</span><span class="o">,</span>
    <span class="c1">-- unfold</span>
    <span class="n">unfold</span> <span class="n">vmul</span> <span class="n">has_add</span><span class="bp">.</span><span class="n">add</span> <span class="kn">context</span><span class="bp">.</span><span class="n">add</span> <span class="n">has_scalar</span><span class="bp">.</span><span class="n">smul</span> <span class="kn">context</span><span class="bp">.</span><span class="n">smul</span> <span class="n">at</span> <span class="bp">*</span><span class="o">,</span>
    <span class="n">simp</span> <span class="bp">*</span><span class="o">,</span>
    <span class="c1">-- fold back</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">:=</span> <span class="n">vmul</span> <span class="err">Γ₁</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">tp</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">γ₁</span> <span class="err">∋</span> <span class="n">U</span><span class="o">),</span> <span class="err">Ξ</span> <span class="n">U</span> <span class="o">(</span><span class="n">SVar</span> <span class="n">x</span><span class="o">)),</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">:=</span> <span class="n">vmul</span> <span class="err">Γ₂</span> <span class="o">(</span><span class="bp">λ</span> <span class="o">(</span><span class="n">U</span> <span class="o">:</span> <span class="n">tp</span><span class="o">)</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">γ₁</span> <span class="err">∋</span> <span class="n">U</span><span class="o">),</span> <span class="err">Ξ</span> <span class="n">U</span> <span class="o">(</span><span class="n">SVar</span> <span class="n">x</span><span class="o">)),</span>
    <span class="n">change</span>
      <span class="o">(</span><span class="n">π₁</span> <span class="bp">+</span> <span class="n">π₂</span><span class="o">)</span> <span class="err">•</span> <span class="o">(</span><span class="err">Ξ</span> <span class="n">T₁</span> <span class="n">ZVar</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">a</span> <span class="bp">+</span> <span class="n">b</span><span class="o">)</span>
      <span class="bp">=</span>
      <span class="o">(</span><span class="n">π₁</span><span class="err">•</span><span class="o">(</span><span class="err">Ξ</span> <span class="n">T₁</span> <span class="n">ZVar</span><span class="o">)</span> <span class="bp">+</span> <span class="n">a</span><span class="o">)</span> <span class="bp">+</span> <span class="o">(</span><span class="n">π₂</span><span class="err">•</span><span class="o">(</span><span class="err">Ξ</span> <span class="n">T₁</span> <span class="n">ZVar</span><span class="o">)</span> <span class="bp">+</span> <span class="n">b</span><span class="o">),</span>
    <span class="c1">-- simplify using monoid laws</span>
    <span class="n">simp</span> <span class="o">[</span><span class="kn">context</span><span class="bp">.</span><span class="n">add_smul</span><span class="o">,</span> <span class="kn">context</span><span class="bp">.</span><span class="n">add_assoc</span><span class="o">]</span> <span class="o">},</span>
</pre></div>


<p>is there some tactic or such that I could apply to do this automatically?</p>

<a name="156647545"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647545" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647545">Mario Carneiro (Jan 22 2019 at 22:51)</a>:</h4>
<p>This is what simp lemmas are for</p>

<a name="156647677"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647677" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647677">Mario Carneiro (Jan 22 2019 at 22:53)</a>:</h4>
<p>If you define <code>add x (y :: z) := y :: add x z</code>, for example, and then install <code>add</code> as a <code>has_add</code> instance, then you can prove <code>x + (y :: z) = y :: (x + z)</code> by rfl, and you should state this as a simp lemma</p>

<a name="156647754"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647754" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647754">Mario Carneiro (Jan 22 2019 at 22:54)</a>:</h4>
<p>You should not ever have to unfold <code>has_add.add</code></p>

<a name="156647865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156647865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156647865">Wojciech Nawrocki (Jan 22 2019 at 22:56)</a>:</h4>
<p>Hm okay, so basically I need to "lift" the behaviour of my functions from the custom definition to one using <code>has_op.op</code>? I'll try</p>

<a name="156648686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156648686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156648686">Wojciech Nawrocki (Jan 22 2019 at 23:09)</a>:</h4>
<p>Is it fine to unfold <code>has_zero.zero</code> though? My definition of <code>0</code> for this type is</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">zeros</span><span class="o">:</span> <span class="bp">Π</span> <span class="n">γ</span><span class="o">,</span> <span class="kn">context</span> <span class="n">γ</span>
<span class="bp">|</span> <span class="o">[]</span> <span class="o">:=</span> <span class="n">nil</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">T</span><span class="bp">::</span><span class="n">δ</span><span class="o">)</span> <span class="o">:=</span> <span class="n">cons</span> <span class="mi">0</span> <span class="n">T</span> <span class="o">(</span><span class="n">zeros</span> <span class="n">δ</span><span class="o">)</span>
</pre></div>


<p>and I need the <code>cons</code> to prove <code>0+Γ=Γ</code></p>

<a name="156649254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156649254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156649254">Wojciech Nawrocki (Jan 22 2019 at 23:21)</a>:</h4>
<p>In any case this is pretty awesome, all my proofs have shortened by half now without the unfolding, thanks a lot!</p>

<a name="156653719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/156653719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#156653719">Mario Carneiro (Jan 23 2019 at 00:37)</a>:</h4>
<p>For this, you should decide whether you prefer to write the empty context as <code>0</code> or <code>[]</code>, and write a simp lemma like <code>0 = []</code> if you want to get rid of the 0 everywhere. In this case you should also make sure that all your other simp lemmas use the "preferred form" of this element on the LHS</p>

<a name="159247553"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247553" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247553">Wojciech Nawrocki (Feb 23 2019 at 22:04)</a>:</h4>
<p>What's the closest thing to the <code>ring</code> tactic when what I have is not a commutative semiring, e.g. just a monoid? Say my theorems are provable simply by repeated application of monoid or group laws, what tactic could I use?</p>

<a name="159247675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247675">Kevin Buzzard (Feb 23 2019 at 22:08)</a>:</h4>
<p>If it's abelian then <code>abel</code> might work, and if it's not then you're best going with <code>simp</code> I think</p>

<a name="159247686"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247686" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247686">Kevin Buzzard (Feb 23 2019 at 22:09)</a>:</h4>
<p>You might have to write <code>simp [mul_assoc]</code> maybe, I can't remember if mul_assoc is a simp lemma</p>

<a name="159247850"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159247850" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159247850">Wojciech Nawrocki (Feb 23 2019 at 22:15)</a>:</h4>
<p><code>abel</code> worked :) thanks. And no, <code>mul_assoc</code> doesn't seem to be a simp lemma.</p>

<a name="159250591"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250591" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250591">Wojciech Nawrocki (Feb 23 2019 at 23:41)</a>:</h4>
<p>Say I would like to work with a particular module which uses a variable <code>v</code> instantiated over a concrete <code>v</code>. For example, a file <code>foo.lean</code> could first declare <code>variable {v: Type}</code> and then use <code>v</code> in all definitions/lemmas in the file. I would like to import everything in <code>foo</code> instantiated with e.g. <code>nat</code> for <code>v</code>. This would be equivalent to partially applying everything in the file to <code>nat</code>. Is such a thing possible without manually redefining everything?</p>

<a name="159250640"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250640" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250640">Andrew Ashworth (Feb 23 2019 at 23:42)</a>:</h4>
<p>You could write a tactic to do it</p>

<a name="159250642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250642">Andrew Ashworth (Feb 23 2019 at 23:43)</a>:</h4>
<p>But, why?</p>

<a name="159250779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159250779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159250779">Wojciech Nawrocki (Feb 23 2019 at 23:47)</a>:</h4>
<p>I would like to do this in order to:<br>
a) Avoid type class search by giving it the right instance from the start.<br>
b) Make inference work. I found that making one of my modules more generic (I changed it from using a particular semiring to being generic over arbitrary semirings) broke inference in a lot of places where I use this module because it no longer knows which semiring to pick and I don't want to specify it everywhere manually.<br>
For a more concrete example which is close to what I'm doing, say I define a list <code>inductive slist {α: Type} [semiring α]: Type</code> which is a list the elements of which are also elements of a semiring and then derive a bunch of theorems about the behaviour of such a list under some transformations. I would then like to use all of these theorems only with a particular choice of <code>α</code>, even though the <code>slist</code> file/module is generic.</p>

<a name="159251390"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251390" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251390">Kevin Buzzard (Feb 24 2019 at 00:06)</a>:</h4>
<p>But if you're using <code>{alpha  : Type}</code> correctly, then Lean should be able to infer what alpha is from subsequent terms, so you don't need to change it to nat, Lean will just guess it for you and do it itself. Have I missed the point?</p>

<a name="159251642"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251642" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251642">Andrew Ashworth (Feb 24 2019 at 00:15)</a>:</h4>
<p>"no longer knows which semiring to pick" this sounds fishy</p>

<a name="159251765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251765">Kevin Buzzard (Feb 24 2019 at 00:18)</a>:</h4>
<p>The <code>{}</code> brackets aren't type class search, they are dealt with using unification.</p>

<a name="159251957"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159251957" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159251957">Wojciech Nawrocki (Feb 24 2019 at 00:23)</a>:</h4>
<p>You're right, Lean can still unify it and find the class instance - I was perhaps a bit rash there when figuring out what's going on. However, tactic state updates that used to take about 300ms when I was working over a concrete object now take several seconds, making it somewhat painful to work interactively. I was hoping that reinstantiating all the lemmas over the concrete objects again would alleviate this.</p>

<a name="159252010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252010">Kevin Buzzard (Feb 24 2019 at 00:24)</a>:</h4>
<p>Again, if you're talking about <code>{}</code>s then this isn't to do with classes, it's something else.</p>

<a name="159252015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252015">Kevin Buzzard (Feb 24 2019 at 00:24)</a>:</h4>
<p>But I agree that sometimes things get slow, and it can sometimes be quite difficult to find out why.</p>

<a name="159252030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252030">Wojciech Nawrocki (Feb 24 2019 at 00:25)</a>:</h4>
<p>I'm talking about both - the <code>{alpha}</code> variable being unified and <code>[semiring alpha]</code> which needs a class instance.</p>

<a name="159252032"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252032" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252032">Kevin Buzzard (Feb 24 2019 at 00:25)</a>:</h4>
<p>Aah yes, that is a class instance. Sorry.</p>

<a name="159252038"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252038" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252038">Kevin Buzzard (Feb 24 2019 at 00:25)</a>:</h4>
<p>Does it help to actually put the type class instances explicitly into Lean at the top of the file?</p>

<a name="159252086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252086">Kevin Buzzard (Feb 24 2019 at 00:26)</a>:</h4>
<p>e.g. you were working with a random alpha assumed to be a semiring, and now you're working with nat, so you could put <code>instance : semiring nat := by apply_instance</code> at the top of the file. However that instance should already be there so I can't imagine it will help :-/</p>

<a name="159252098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252098">Kevin Buzzard (Feb 24 2019 at 00:27)</a>:</h4>
<p>oh this can't be the problem. Unless your actual instances are hard to find.</p>

<a name="159252205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252205">Wojciech Nawrocki (Feb 24 2019 at 00:30)</a>:</h4>
<p>I couldn't say for sure without benchmarking, but I would guess that the two implicit arguments I added to <em>everything</em> makes it appreciably more difficult to carry out elaboration.</p>

<a name="159252209"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252209" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252209">Kevin Buzzard (Feb 24 2019 at 00:30)</a>:</h4>
<p>I'm afraid you'll have to speak to a computer scientist about this one :-)</p>

<a name="159252211"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252211" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252211">Kevin Buzzard (Feb 24 2019 at 00:31)</a>:</h4>
<p>In maths, everything runs instantly.</p>

<a name="159252220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252220">Kevin Buzzard (Feb 24 2019 at 00:31)</a>:</h4>
<p>You should consider moving to the Platonic universe.</p>

<a name="159252221"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252221" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252221">Kevin Buzzard (Feb 24 2019 at 00:31)</a>:</h4>
<p>We don't have engineering troubles there.</p>

<a name="159252992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159252992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159252992">Wojciech Nawrocki (Feb 24 2019 at 00:55)</a>:</h4>
<p>Oh okay, I ran into the problem that made me think unification fails again. In fact, I believe it could eventually succeed, but currently <code>simp *</code> takes so long it times out, while it would work fine before I added the implicit parameters to one of my modules.</p>

<a name="159253178"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159253178" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159253178">Kevin Buzzard (Feb 24 2019 at 01:00)</a>:</h4>
<p>If you want to try to speed things up yourself, you could take a look at what simp was doing before and after by putting logging on.</p>

<a name="159253197"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159253197" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159253197">Kevin Buzzard (Feb 24 2019 at 01:01)</a>:</h4>
<p><code>set_option trace.simplify.rewrite true</code> is what you need to see what simp is doing.</p>

<a name="159302724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159302724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159302724">Wojciech Nawrocki (Feb 24 2019 at 23:55)</a>:</h4>
<p>Does Lean have an equivalent of Haskell's/Agda's <code>where</code>? E.g. <code>def abc := two where two := 2</code></p>

<a name="159303137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159303137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159303137">Mario Carneiro (Feb 25 2019 at 00:06)</a>:</h4>
<p>no</p>

<a name="159303140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159303140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159303140">Mario Carneiro (Feb 25 2019 at 00:06)</a>:</h4>
<p>it messes with elaboration order</p>

<a name="159303855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159303855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159303855">Wojciech Nawrocki (Feb 25 2019 at 00:27)</a>:</h4>
<p>Could you <em>elaborate</em> on what the issue is?</p>

<a name="159304378"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159304378" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159304378">Mario Carneiro (Feb 25 2019 at 00:43)</a>:</h4>
<p>Lean does pretty much all elaboration from left to right. If you use a postfix <code>let</code>, then the type and value of the defined variable will not be known when it is needed</p>

<a name="159304384"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159304384" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159304384">Mario Carneiro (Feb 25 2019 at 00:43)</a>:</h4>
<p>Is this stupid? Yes. I think lean 4 will relax the elaboration order a bit to allow stuff like this to work</p>

<a name="159645662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159645662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159645662">Wojciech Nawrocki (Feb 28 2019 at 19:47)</a>:</h4>
<p>Does anyone know where the extra argument comes from (I do know <code>(n = 0)</code> is probably not valid syntax for a hypothesis)?</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo_fn</span> <span class="o">:=</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="bp">=</span> <span class="mi">0</span><span class="o">),</span> <span class="n">string</span>

<span class="bp">#</span><span class="kn">print</span> <span class="n">foo_fn</span>
<span class="c">/-</span><span class="cm"> def foo_fn : Type :=</span>
<span class="cm">   ℕ → Π (n : ℕ), n = 0 → string -/</span>
<span class="c1">-- ^ what is this?</span>
</pre></div>

<a name="159645923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159645923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159645923">Chris Hughes (Feb 28 2019 at 19:51)</a>:</h4>
<p>Do you have a <code>variable</code> somewhere in your file?</p>

<a name="159646059"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159646059" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159646059">Chris Hughes (Feb 28 2019 at 19:52)</a>:</h4>
<p>Oh no actually. <code>Π (n = 0), _</code> is shorthand for <code>Π n, n = 0 -&gt; _</code></p>

<a name="159646200"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159646200" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159646200">Wojciech Nawrocki (Feb 28 2019 at 19:54)</a>:</h4>
<p>Ah so it <em>is</em> valid syntax. Thanks!</p>

<a name="159657235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159657235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159657235">Wojciech Nawrocki (Feb 28 2019 at 22:08)</a>:</h4>
<p>I would like to define a subtype of Lean functions like so:</p>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">reducible</span><span class="o">]</span>
<span class="n">def</span> <span class="n">foo_fn</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">is_foo</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Id</span><span class="o">:</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Rec</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">},</span> <span class="n">is_foo</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">)</span>
<span class="o">(</span><span class="n">hf</span><span class="o">:</span> <span class="n">is_foo</span> <span class="n">f</span><span class="o">)</span>
</pre></div>


<p>Where a <code>foo</code> is a <code>ℕ → ℕ</code> together with a proof that it's a valid kind of <code>foo_fn</code>, i.e. either the identity or some other <code>foo</code> plus 1. Then, I would also like to carry out transformations on the <code>foo</code> structure by modifying the <code>foo_fn</code> and adjusting its proof. Unfortunately the <code>foo_fn</code> is opaque as just a Lean function, so to actually do this it seems I need the following:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">foo&#39;</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">Id</span><span class="o">:</span> <span class="n">foo&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Rec</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">},</span> <span class="n">foo&#39;</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">foo&#39;</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>
</pre></div>


<p>My question is, can <code>foo'</code> be considered equivalent to <code>foo</code> in the sense that I can extract <code>f: foo_fn</code> out of <code>foo' f</code> and use it as I would use the <code>f</code> member of the structure <code>foo</code>?</p>

<a name="159663701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159663701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159663701">Kevin Buzzard (Feb 28 2019 at 23:42)</a>:</h4>
<p>I don't understand the question. Are you not happy with this sort of thing:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">foo_fn</span> <span class="o">:=</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span>

<span class="kn">inductive</span> <span class="n">is_foo</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="bp">→</span> <span class="kt">Prop</span>
<span class="bp">|</span> <span class="n">Id</span><span class="o">:</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">Rec</span><span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">},</span> <span class="n">is_foo</span> <span class="n">f</span> <span class="bp">→</span> <span class="n">is_foo</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">x</span><span class="o">,</span> <span class="o">(</span><span class="n">f</span> <span class="n">x</span><span class="o">)</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">)</span>

<span class="kn">structure</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span><span class="o">)</span>
<span class="o">(</span><span class="n">hf</span><span class="o">:</span> <span class="n">is_foo</span> <span class="n">f</span><span class="o">)</span>

<span class="n">def</span> <span class="n">add_one</span> <span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">hf</span><span class="bp">⟩</span><span class="o">,</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf</span><span class="bp">⟩</span>
</pre></div>


<p>?</p>

<a name="159798929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159798929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159798929">Wojciech Nawrocki (Mar 02 2019 at 14:09)</a>:</h4>
<p>The problem is that I couldn't redefine <code>add_one</code> like this:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add_one&#39;</span><span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span>
<span class="c">/-</span><span class="cm"> induction tactic failed, recursor &#39;is_foo.dcases_on&#39; can only eliminate into Prop -/</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="bp">⟩</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="o">)</span><span class="bp">⟩</span>
</pre></div>


<p>And in general any definition which tries to extract an inner <code>foo_fn</code> out of an <code>is_foo</code> constructor will fail, but I need to do that sometimes in order to transform the <code>foo_fn</code>. So far the <code>inductive foo': foo_fn -&gt; Type</code> definition seems to work well though.</p>

<a name="159799119"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799119" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799119">Kevin Buzzard (Mar 02 2019 at 14:15)</a>:</h4>
<p>Aah I see; the recursor for <code>is_foo</code> only eliminates into <code>Prop</code>. Yeah you need an expert, not a mathematician :-)</p>

<a name="159799673"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799673" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799673">Chris Hughes (Mar 02 2019 at 14:26)</a>:</h4>
<p>The reason this isn't possible in general, is that by proof irrelevance <code>is_foo.Id = is_foo.rec _</code> if the proofs have the same type, so I cannot define functions that treat these two cases differently.</p>
<p>Since both cases are equal in your function, you can write</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add_one&#39;</span><span class="o">:</span> <span class="n">foo</span> <span class="bp">→</span> <span class="n">foo</span>
<span class="bp">|</span> <span class="bp">⟨</span><span class="n">f</span><span class="o">,</span> <span class="n">h</span><span class="bp">⟩</span> <span class="o">:=</span> <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hf&#39;</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="o">))</span><span class="bp">⟩</span>
</pre></div>

<a name="159799742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799742">Chris Hughes (Mar 02 2019 at 14:28)</a>:</h4>
<p>Usually this form is preferred however</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">add_one&#39;</span> <span class="o">(</span><span class="n">f</span> <span class="o">:</span> <span class="n">foo</span><span class="o">)</span> <span class="o">:</span> <span class="n">foo</span> <span class="o">:=</span>
 <span class="bp">⟨λ</span> <span class="n">x</span><span class="o">,</span> <span class="n">f</span><span class="bp">.</span><span class="mi">1</span> <span class="n">x</span> <span class="bp">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">f</span><span class="bp">.</span><span class="mi">2</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Id</span><span class="o">)</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">hf&#39;</span><span class="o">,</span> <span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="o">(</span><span class="n">is_foo</span><span class="bp">.</span><span class="n">Rec</span> <span class="n">hf&#39;</span><span class="o">))</span><span class="bp">⟩</span>
</pre></div>

<a name="159799766"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159799766" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159799766">Chris Hughes (Mar 02 2019 at 14:30)</a>:</h4>
<p>The second <code>add_one'</code> will definitionally reduce in a nice way when applied to an argument <code>f : foo</code>, wherease the first definition will only reduce when applied to an argument of the form <code>⟨f, h⟩ : foo</code>. This makes the first definition harder to work with in proofs.</p>

<a name="159801343"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159801343" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159801343">Wojciech Nawrocki (Mar 02 2019 at 15:12)</a>:</h4>
<p>Thanks!</p>

<a name="159866654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159866654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159866654">drocta (Mar 03 2019 at 21:57)</a>:</h4>
<p>I am trying to say something about free objects, using an existing definition of concrete categories in mathlib.<br>
I couldn't find an existing definition in mathlib for free objects, so I was going to define them myself.<br>
I have mathlib installed using leanpkg, and it looks like because I have lean version 3.4.1 installed, leanpkg used the branch with that name from the mathlib repository.<br>
However, I notice that the master branch and the 3.4.1 branch have the definition of concrete categories in different places.<br>
Should I go ahead and use the version which is defined in the 3.4.1 branch, and is in the category.lean file, or ought I somehow use the version in the concrete_category.lean version currently in the master branch?</p>

<a name="159868739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159868739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159868739">Kevin Buzzard (Mar 03 2019 at 22:56)</a>:</h4>
<p>The master branch of mathlib doesn't work with Lean 3.4.1.</p>

<a name="159868775"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159868775" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159868775">Kevin Buzzard (Mar 03 2019 at 22:58)</a>:</h4>
<p>If I were you I'd use 3.4.2 (probably the last release of Lean 3) and mathlib master. If you install elan then it will all work by magic and you won't have to worry.</p>

<a name="159870797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159870797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159870797">drocta (Mar 03 2019 at 23:56)</a>:</h4>
<p>thank you</p>

<a name="159876903"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159876903" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159876903">drocta (Mar 04 2019 at 02:48)</a>:</h4>
<p>I'm not sure where to find the documentation on out_param . Could you point me towards it?<br>
the definition in core.lean looks like it is just an identity function, but I assume I'm missing something, seeing as I think the lack of it just caused me to get a type error.</p>

<a name="159884489"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159884489" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159884489">drocta (Mar 04 2019 at 03:50)</a>:</h4>
<p>found a way to do what I was trying to do which didn't require that, so nvm I guess?</p>

<a name="159891658"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159891658" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159891658">Kevin Buzzard (Mar 04 2019 at 07:03)</a>:</h4>
<p><code>out_param</code> is something to do with telling Lean's elaborator what order to do type inference, or something like that. I'm afraid the only documentation that I know of is when I asked for details about it on either this chat or at the old chat, and Mario Carneiro explained it.</p>

<a name="159893666"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159893666" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159893666">Kevin Buzzard (Mar 04 2019 at 07:52)</a>:</h4>
<p><a href="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351" target="_blank" title="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351">https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351</a></p>

<a name="159971264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/159971264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#159971264">drocta (Mar 05 2019 at 02:35)</a>:</h4>
<blockquote>
<p><code>out_param</code> is something to do with telling Lean's elaborator what order to do type inference, or something like that. I'm afraid the only documentation that I know of is when I asked for details about it on either this chat or at the old chat, and Mario Carneiro explained it.<br>
<a href="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351" target="_blank" title="https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351">https://gitter.im/leanprover_public/Lobby?at=5a6e31685a9ebe4f75e77351</a></p>
</blockquote>
<p>Ah! Thank you!</p>

<a name="160008880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160008880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160008880">Wojciech Nawrocki (Mar 05 2019 at 14:51)</a>:</h4>
<p>What is the meaning of this error: <code>rewrite tactic failed, motive is not type correct</code>?<br>
I get it when trying to apply <code>rw [sesh_tp.dual_end_recv]</code> where <code>sesh_tp.dual_end_recv : sesh_tp.dual End? = End!</code> to the following state:</p>
<div class="codehilite"><pre><span></span><span class="err">⊢</span> <span class="err">⟦</span><span class="mi">1</span><span class="bp">⬝</span><span class="err">↑</span><span class="o">(</span><span class="n">sesh_tp</span><span class="bp">.</span><span class="n">dual</span> <span class="n">End</span><span class="err">?</span><span class="o">)</span><span class="err">⟧</span><span class="bp">::</span><span class="err">?</span><span class="n">m_1</span> <span class="bp">=</span> <span class="n">matrix</span><span class="bp">.</span><span class="n">identity</span> <span class="o">(</span><span class="err">↑</span><span class="o">(</span><span class="n">sesh_tp</span><span class="bp">.</span><span class="n">dual</span> <span class="n">End</span><span class="err">?</span><span class="o">)</span> <span class="bp">::</span> <span class="n">γ</span><span class="o">)</span> <span class="err">↑</span><span class="n">End</span><span class="bp">!</span> <span class="o">(</span><span class="n">ZVar</span> <span class="n">γ</span> <span class="err">↑</span><span class="n">End</span><span class="bp">!</span><span class="o">)</span>
</pre></div>


<p>I thought that <code>rw</code> should be able to simply replace the instances of <code>sesh_tp.dual End?</code>.<br>
(<code>End?</code> and <code>End!</code> are constructors for the <code>sesh_tp</code> inductive type.)</p>

<a name="160012954"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160012954" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160012954">Patrick Massot (Mar 05 2019 at 15:39)</a>:</h4>
<p>We need an emoji for this error</p>

<a name="160013094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160013094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160013094">Patrick Massot (Mar 05 2019 at 15:41)</a>:</h4>
<p>It means that doing the rewrite will give you an expression which doesn't type check, presumably because you had a dependent type and rewrote the parameter. The classical example is:</p>
<div class="codehilite"><pre><span></span><span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="kn">notation</span> <span class="n">false</span>
<span class="kn">set_option</span> <span class="n">pp</span><span class="bp">.</span><span class="n">implicit</span> <span class="n">true</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">b</span> <span class="o">:</span> <span class="n">fin</span> <span class="o">(</span><span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">))</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">b</span><span class="o">)</span> <span class="o">:</span> <span class="n">true</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">add_comm</span> <span class="n">at</span> <span class="n">h</span><span class="o">,</span>

  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="160013133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160013133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160013133">Patrick Massot (Mar 05 2019 at 15:41)</a>:</h4>
<p>Try understanding this simple example and then your complicated one</p>

<a name="160015041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160015041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160015041">Wojciech Nawrocki (Mar 05 2019 at 16:04)</a>:</h4>
<p>Oh right, I get the issue, thanks! But if you <code>rw add_comm</code> both sides of the equation, it should still type check, no? I managed to solve my problem by explicitly stating the type of the goal with both instances of <code>sesh_tp.dual End?</code> rewritten to <code>End!</code>. Could <code>rw</code> not check the type after doing <em>both</em> rewrites?</p>

<a name="160024039"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160024039" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160024039">Kevin Buzzard (Mar 05 2019 at 17:52)</a>:</h4>
<p><code>rw</code> is what it is. If you want more you can try lots of tricks, e.g. <code>erw</code> or <code>simp only</code> or using <code>conv</code> mode -- we have lots of workarounds :-)  But this is dependent type theory, random rewriting can create terms which are not type correct and Lean pulls the plug when this happens.</p>

<a name="160029879"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/160029879" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#160029879">Plam (Mar 05 2019 at 18:58)</a>:</h4>
<p>Is there a way to make use of the fact that pattern matches in a theorem have the same structure as in a definition? In particular, that given a catchall pattern match later in the theorem, it can't be the case that the thing being matched against matches one of the earlier pattern matches?</p>
<p>Concretely, when proving <code>simp_const_eq</code> below, I want to match on <code>plus (const a) (const b)</code>, <code>times (const a) (const b)</code> and then a catchall. Is this possible, or do I just need some extra cases that I can rfl my way through? </p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">aexpr</span> <span class="o">:</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">const</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="n">var</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="n">plus</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="n">times</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span>

<span class="kn">open</span> <span class="n">aexpr</span>

<span class="n">def</span> <span class="n">aeval</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="bp">ℕ</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">const</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">var</span> <span class="n">n</span><span class="o">)</span> <span class="o">:=</span> <span class="n">v</span> <span class="n">n</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="o">(</span><span class="n">aeval</span> <span class="n">e₁</span> <span class="bp">+</span> <span class="n">aeval</span> <span class="n">e₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">times</span> <span class="n">e₁</span> <span class="n">e₂</span><span class="o">)</span> <span class="o">:=</span> <span class="n">aeval</span> <span class="n">e₁</span> <span class="bp">*</span> <span class="n">aeval</span> <span class="n">e₂</span>

<span class="n">def</span> <span class="n">simp_const</span> <span class="o">:</span> <span class="n">aexpr</span> <span class="bp">→</span> <span class="n">aexpr</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">plus</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₂</span><span class="o">))</span> <span class="o">:=</span> <span class="n">const</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">+</span> <span class="n">n₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">times</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₁</span><span class="o">)</span> <span class="o">(</span><span class="n">const</span> <span class="n">n₂</span><span class="o">))</span> <span class="o">:=</span> <span class="n">const</span> <span class="o">(</span><span class="n">n₁</span> <span class="bp">*</span> <span class="n">n₂</span><span class="o">)</span>
<span class="bp">|</span> <span class="n">e</span> <span class="o">:=</span> <span class="n">e</span>

<span class="kn">theorem</span> <span class="n">simp_const_eq</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span>
  <span class="bp">∀</span> <span class="n">e</span> <span class="o">:</span> <span class="n">aexpr</span><span class="o">,</span> <span class="n">aeval</span> <span class="n">v</span> <span class="o">(</span><span class="n">simp_const</span> <span class="n">e</span><span class="o">)</span> <span class="bp">=</span> <span class="n">aeval</span> <span class="n">v</span> <span class="n">e</span> <span class="o">:=</span>
<span class="n">sorry</span>
</pre></div>

<a name="161024741"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161024741" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161024741">Wojciech Nawrocki (Mar 18 2019 at 01:48)</a>:</h4>
<p>While I don't think this is possible right now (correct me if I'm wrong), would it in principle be possible to extend Lean with support for custom type unification procedures? The way I defined some inductive families requires me to do <em>a lot</em> of conversions from terms of type <code>T a</code> to a type <code>T b</code> that Lean expects, where <code>a = b</code>. All of these are resolvable more or less with a single tactic, and it would be awesome if I could just teach Lean a heuristic like "If type U is expected and a term of type T is given, see if T or U (or both) contain a specific expression. If so, try to use this tactic to convert T to U".</p>

<a name="161036029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161036029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161036029">Johan Commelin (Mar 18 2019 at 07:15)</a>:</h4>
<p>Search the chat for "unification hints"</p>

<a name="161036030"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161036030" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161036030">Johan Commelin (Mar 18 2019 at 07:15)</a>:</h4>
<p>I'm hoping that might be exactly the thing you want. Note however that we don't have much experience with them. Unification hints haven't been used outside of a demo, as far as I am aware.</p>

<a name="161036875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161036875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161036875">Mario Carneiro (Mar 18 2019 at 07:34)</a>:</h4>
<p>If by <code>a = b</code> you mean you have a proof that they are equal, not that they are defeq, then unification hints won't help, and a lot of things will get more complicated</p>

<a name="161053399"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161053399" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161053399">Wojciech Nawrocki (Mar 18 2019 at 12:38)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> indeed by <code>a = b</code> I mean <code>eq a b</code>. What I end up having in the actual terms is a bunch of <code>eq.mpr</code>s which do the conversions from <code>T a</code> to <code>T b</code>. My idea here was, could I not just tell Lean to try to insert those conversions automatically when it fails to unify types?</p>

<a name="161053547"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161053547" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161053547">Wojciech Nawrocki (Mar 18 2019 at 12:41)</a>:</h4>
<p><span class="user-mention" data-user-id="112680">@Johan Commelin</span> I was looking into those but it seems they are not powerful enough to modify the term in question which is what seems to be needed when the types are not algorithmically definitonally equal according to Lean. Moreover, some of the problems that Coq resolves using Canonical Structures, which seem to be a type of unification hint, Lean resolves using type class inference.</p>

<a name="161055174"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161055174" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161055174">Kevin Buzzard (Mar 18 2019 at 13:04)</a>:</h4>
<p>There was some discussion about these issues at Lean Together in January. Note that Lean 4 will apparently be removing unification hints, perhaps because nobody uses them in Lean.</p>

<a name="161055192"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161055192" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161055192">Kevin Buzzard (Mar 18 2019 at 13:04)</a>:</h4>
<p>The speakers who talked about it were Assia Mahboubi and Cyril Cohen, and I am pretty sure their slides are online and linked to here somewhere.</p>

<a name="161055258"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161055258" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161055258">Johan Commelin (Mar 18 2019 at 13:05)</a>:</h4>
<p>See: <br>
<a href="#narrow/stream/113488-general/topic/unification.20hints/near/158613068" title="#narrow/stream/113488-general/topic/unification.20hints/near/158613068">https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/unification.20hints/near/158613068</a></p>

<a name="161059451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161059451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161059451">Jesse Michael Han (Mar 18 2019 at 14:01)</a>:</h4>
<p>We also ran into this issue in Flypitch. I found it helpful to have a library of <code>simp</code> lemmas to normalize the location of the casts. I also had the occasional odd experience of being unable to prove an instance of a cast lemma by <code>refl</code> inside a larger proof, but was able to prove that lemma by <code>refl</code> separately, mark it as <code>simp</code>, and then <code>simp</code> would work...</p>

<a name="161072189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161072189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161072189">Patrick Massot (Mar 18 2019 at 16:18)</a>:</h4>
<blockquote>
<p>Note that Lean 4 will apparently be removing unification hints, perhaps because nobody uses them in Lean.</p>
</blockquote>
<p>Is this really clear? I thought that Assia and Cyril provided ample proofs that this would be a tragic mistake. I understand they were removed at the beginning of Lean 4, but many things were removed, and some of them will return at some point. Is there any update on this <span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span>?</p>

<a name="161072430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161072430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161072430">Sebastian Ullrich (Mar 18 2019 at 16:21)</a>:</h4>
<p>no</p>

<a name="161537406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161537406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161537406">Wojciech Nawrocki (Mar 23 2019 at 18:30)</a>:</h4>
<p>Why does <code>auto_param</code> seem to not work as an implicit argument? I'd like to have a constructor like <code>foo {h: auto_param some_prop ``mytac}: Foo</code> and match on it like <code>| foo</code> rather than <code>| (foo _)</code>, but if I put the <code>auto_param</code> in curly brackets, it seems to not actually run the tactic when using <code>def abc := foo</code> - it fails with "failed to synthesize placeholder" rather than trying to run <code>mytac</code>.</p>

<a name="161612010"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161612010" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161612010">drocta (Mar 25 2019 at 03:36)</a>:</h4>
<p>I want the unique function from the type <code>empty</code> to another type. I thought I might be able to do that with <code>empty.rec</code> or <code>empty.rec_on</code> , (going off of the tutorial's use of that with days of the week), but it looks like those both expect to be given a function from empty as an argument, when that is what I'm trying to get.<br>
What am I missing?</p>

<a name="161616137"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161616137" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161616137">Johan Commelin (Mar 25 2019 at 05:38)</a>:</h4>
<p>I think this is what you want:</p>
<div class="codehilite"><pre><span></span><span class="n">src</span><span class="bp">/</span><span class="n">logic</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="n">def</span> <span class="n">empty</span><span class="bp">.</span><span class="n">elim</span> <span class="o">{</span><span class="n">C</span> <span class="o">:</span> <span class="n">Sort</span><span class="bp">*</span><span class="o">}</span> <span class="o">:</span> <span class="n">empty</span> <span class="bp">→</span> <span class="n">C</span><span class="bp">.</span>
</pre></div>

<a name="161817781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161817781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161817781">Wojciech Nawrocki (Mar 27 2019 at 00:51)</a>:</h4>
<p><code>congr</code> gave me the following goal:</p>
<div class="codehilite"><pre><span></span><span class="n">γ</span> <span class="o">:</span> <span class="n">precontext</span><span class="o">,</span>
<span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span> <span class="n">γ</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="bp">@</span><span class="n">term</span> <span class="n">γ</span> <span class="err">Γ</span> <span class="err">↑</span><span class="n">End</span><span class="err">?</span>
<span class="err">⊢</span> <span class="bp">@</span><span class="n">Wait</span> <span class="n">γ</span> <span class="err">Γ</span> <span class="n">M</span> <span class="bp">==</span> <span class="bp">@</span><span class="n">eq</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">(</span><span class="bp">@</span><span class="n">term</span> <span class="n">γ</span> <span class="o">(</span><span class="err">Γ</span> <span class="bp">+</span> <span class="mi">0</span><span class="o">)</span> <span class="n">tp</span><span class="bp">.</span><span class="n">unit</span><span class="o">)</span> <span class="o">(</span><span class="bp">@</span><span class="n">term</span> <span class="n">γ</span> <span class="err">Γ</span> <span class="n">tp</span><span class="bp">.</span><span class="n">unit</span><span class="o">)</span> <span class="bp">_</span> <span class="o">(</span><span class="bp">@</span><span class="n">Wait</span> <span class="n">γ</span> <span class="err">Γ</span> <span class="n">M</span><span class="o">)</span>
</pre></div>


<p>Having never worked with <code>heq</code>, I'm not sure if this is provable? Clearly both sides are the same expression, but one has been passed through <code>eq.mpr</code> to cast its type. If it's provable, what would be a good tactic/term to solve it? <em>EDIT</em>: It's probably worth noting that it has been casted to the wrong type, i.e. RHS has the same type as LHS before the cast, but a different one after. Can I undo <code>eq.mpr</code> in here somehow?</p>

<a name="161819590"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161819590" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161819590">Wojciech Nawrocki (Mar 27 2019 at 01:25)</a>:</h4>
<p>Ah <code>h_generalize</code> did it. I would still be interested in hearing if there's a more automated way of doing it.</p>

<a name="161819890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161819890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161819890">Jesse Michael Han (Mar 27 2019 at 01:30)</a>:</h4>
<p><code>cc</code> can sometimes handle heqs of casts which are close to being definitional equalities</p>

<a name="161819901"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161819901" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161819901">Jesse Michael Han (Mar 27 2019 at 01:30)</a>:</h4>
<p>however, it works better when <code>eq.mpr</code>s are hidden beneath <code>cast</code>s</p>

<a name="161820139"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161820139" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161820139">Wojciech Nawrocki (Mar 27 2019 at 01:35)</a>:</h4>
<p>What's the difference between <code>cast</code> and <code>eq.mpr</code>?</p>

<a name="161820220"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161820220" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161820220">Kenny Lau (Mar 27 2019 at 01:37)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">inline</span><span class="o">]</span>
<span class="n">def</span> <span class="n">cast</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec</span> <span class="n">a</span> <span class="n">h</span>

<span class="bp">@</span><span class="o">[</span><span class="kn">inline</span><span class="o">]</span>
<span class="n">def</span> <span class="n">eq</span><span class="bp">.</span><span class="n">mpr</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">β</span><span class="o">),</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="bp">_</span> <span class="n">h₂</span>
</pre></div>

<a name="161820396"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161820396" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161820396">Wojciech Nawrocki (Mar 27 2019 at 01:40)</a>:</h4>
<p>Oh, it's just reversed? Okay then :)</p>

<a name="161820412"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161820412" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161820412">Kenny Lau (Mar 27 2019 at 01:41)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="bp">@</span><span class="o">[</span><span class="kn">inline</span><span class="o">]</span>
<span class="n">def</span> <span class="n">eq</span><span class="bp">.</span><span class="n">mp</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">β</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">β</span> <span class="o">:=</span>
<span class="bp">λ</span> <span class="o">{</span><span class="n">α</span> <span class="n">β</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">},</span> <span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span>
</pre></div>

<a name="161835910"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835910" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835910">Kevin Buzzard (Mar 27 2019 at 07:40)</a>:</h4>
<p>There are people here who would say that if you're dealing with heqs, you're doing it wrong</p>

<a name="161835917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835917">Kevin Buzzard (Mar 27 2019 at 07:40)</a>:</h4>
<p>Equality of types is evil in type theory</p>

<a name="161835932"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835932" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835932">Kevin Buzzard (Mar 27 2019 at 07:41)</a>:</h4>
<p>And maybe you'd be better off making an equiv if you have two types which you have identified in your mind</p>

<a name="161835946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835946">Kevin Buzzard (Mar 27 2019 at 07:41)</a>:</h4>
<p>Many of the key facts about equality are also proved for equivs</p>

<a name="161835947"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835947" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835947">Kevin Buzzard (Mar 27 2019 at 07:41)</a>:</h4>
<p>The key missing one is <code>rw</code></p>

<a name="161835992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161835992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161835992">Kevin Buzzard (Mar 27 2019 at 07:42)</a>:</h4>
<p>But we're working on it</p>

<a name="161858773"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161858773" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161858773">Wojciech Nawrocki (Mar 27 2019 at 13:30)</a>:</h4>
<p>Yeah, I (ab)use dependent types in a way that makes it necessary to prove type equality quite often. I try to give my functions built-in &amp; semi-automated support for this by adding arguments like <code>(h: auto_param (expected_T = actual_T) ``some_tac)</code>, but it's not always possible</p>

<a name="161866241"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161866241" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161866241">Wojciech Nawrocki (Mar 27 2019 at 14:48)</a>:</h4>
<p>While I'm at it, how can I <code>rw</code> using a <code>heq</code>? Given <code>Hx: M == x</code>, <code>rw [Hx]</code> tells me that <code>lemma is not an equality nor an iff</code>.</p>

<a name="161866351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161866351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161866351">Chris Hughes (Mar 27 2019 at 14:49)</a>:</h4>
<p>With great difficulty. You can try using <code>heq.rec_on</code>, but I think this is usually quite hard, because the resulting expression often won't type check.</p>

<a name="161870735"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161870735" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161870735">Simon Hudon (Mar 27 2019 at 15:28)</a>:</h4>
<p>This is a lesson you have to learn eventually: just because you can write it this way and that it is type correct doesn't mean it's a good idea. Keep the type of your definitions as simple as possible. Move your added logic to separate lemmas or separate definitions.</p>

<a name="161872490"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161872490" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161872490">Jesse Michael Han (Mar 27 2019 at 15:47)</a>:</h4>
<p><code>heq.subst</code> will let you simulate some rewriting, but as Chris said, it is very painful</p>

<a name="161896451"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161896451" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161896451">Kevin Buzzard (Mar 27 2019 at 20:15)</a>:</h4>
<p>If you know you are abusing dependent types then maybe you are bringing the pain on yourself. I had a maths repo where I used equality of types, because I was learning type theory and didn't understand the difference between equality and definitional equality; I ran into real trouble, which was only fixed by a refactor. What I am pushing for now is a tactic which will rewrite appropriate terms along equivs (or however you say it: if P is a predicate on rings which is mathematically reasonable then for two isomorphic rings R and S, P R will be true iff P S is, and I want a tactic which will show this -- this is something mathematicians do all the time but which seems to be painful in type theory).</p>

<a name="161905929"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161905929" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161905929">Wojciech Nawrocki (Mar 27 2019 at 22:27)</a>:</h4>
<p><span class="user-mention" data-user-id="110038">@Kevin Buzzard</span> Well, kind of, but not necessarily. I'm still a newcomer to type theory/theorem proving, but from what I read and some discussions I've had, my understanding is that currently Coq can handle these kinds of things much better than Lean. Adding good support for working with dependent types which are only propositionally equal could be well worth the effort. In particular, Coq has a <a href="https://coq.inria.fr/refman/addendum/program.html" target="_blank" title="https://coq.inria.fr/refman/addendum/program.html">Program</a> framework (which I think I've mentioned here at some point) which is able to find which <code>eq</code>s need to be proven while constructing an expression and generate them as external goals. This way we get a clean expression and all the nasty details are resolved externally. After the goals are proven, <code>Program</code> seems to automatically insert <code>casts</code>, more or less. Moreover, Coq can be told which tactics to use in order to automatically resolve most of such side equality goals. In PVS, I believe these things are called "Type Correctness Conditions" and are also dealt with outside the expression. HoTT also seems to provide an interesting answer to this in the form of paths, but I've only started looking into that.</p>

<a name="161926249"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/161926249" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#161926249">Andrew Ashworth (Mar 28 2019 at 05:56)</a>:</h4>
<p>Is <code>Program</code> ready for prime time? I only read about it in CPDT, Chlipala is not big on it. <a href="http://adam.chlipala.net/cpdt/html/Subset.html" target="_blank" title="http://adam.chlipala.net/cpdt/html/Subset.html">http://adam.chlipala.net/cpdt/html/Subset.html</a></p>

<a name="162060279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162060279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162060279">Wojciech Nawrocki (Mar 29 2019 at 16:21)</a>:</h4>
<p>In Coq, <a href="https://coq.inria.fr/library/Coq.Logic.JMeq.html" target="_blank" title="https://coq.inria.fr/library/Coq.Logic.JMeq.html"><code>JMeq_eq</code></a> is an axiom, but in Lean <a href="https://github.com/leanprover/lean/blob/master/library/init/core.lean#L205" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/init/core.lean#L205"><code>eq_of_heq</code></a> seems to be a lemma with no non-core axioms below it. Does that mean it follows from proof irrelevance or another axiom that Lean has built-in?</p>

<a name="162069155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162069155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162069155">Mario Carneiro (Mar 29 2019 at 17:56)</a>:</h4>
<p><span class="user-mention" data-user-id="128280">@Wojciech Nawrocki</span> Yes, it relies on proof irrelevance.</p>
<div class="codehilite"><pre><span></span><span class="kn">lemma</span> <span class="n">eq_of_heq</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">}</span> <span class="o">{</span><span class="n">a</span> <span class="n">a&#39;</span> <span class="o">:</span> <span class="n">α</span><span class="o">}</span> <span class="o">(</span><span class="n">h</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">==</span> <span class="n">a&#39;</span><span class="o">)</span> <span class="o">:</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a&#39;</span> <span class="o">:=</span>
<span class="k">have</span> <span class="bp">∀</span> <span class="o">(</span><span class="n">α&#39;</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">@</span><span class="n">heq</span> <span class="n">α</span> <span class="n">a</span> <span class="n">α&#39;</span> <span class="n">a&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h₂</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">α&#39;</span><span class="o">),</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h₂</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a&#39;</span><span class="o">,</span> <span class="k">from</span>
  <span class="bp">λ</span> <span class="o">(</span><span class="n">α&#39;</span> <span class="o">:</span> <span class="n">Sort</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">a&#39;</span> <span class="o">:</span> <span class="n">α&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">h₁</span> <span class="o">:</span> <span class="bp">@</span><span class="n">heq</span> <span class="n">α</span> <span class="n">a</span> <span class="n">α&#39;</span> <span class="n">a&#39;</span><span class="o">),</span> <span class="n">heq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="n">h₁</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">h₂</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">=</span> <span class="n">α</span><span class="o">,</span> <span class="n">rfl</span><span class="o">),</span>
<span class="k">show</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">rec_on</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span> <span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="bp">=</span> <span class="n">a&#39;</span><span class="o">,</span> <span class="k">from</span>
  <span class="n">this</span> <span class="n">α</span> <span class="n">a&#39;</span> <span class="n">h</span> <span class="o">(</span><span class="n">eq</span><span class="bp">.</span><span class="n">refl</span> <span class="n">α</span><span class="o">)</span>
</pre></div>


<p>the <code>rfl</code> on line 3 has type <code>eq.rec_on h₂ a = a</code>, which only makes sense because <code>h₂  : α = α</code> is defeq to <code>rfl</code> by proof irrelevance</p>

<a name="162070989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162070989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162070989">Wojciech Nawrocki (Mar 29 2019 at 18:16)</a>:</h4>
<p>Gotcha, thanks!</p>

<a name="162185922"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162185922" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162185922">Wojciech Nawrocki (Mar 31 2019 at 18:16)</a>:</h4>
<p>How can I introduce a new constant into all goals using <code>;</code>? <code>sometac; have a := 2,</code> doesn't seem to work. <em>EDIT</em>: <code>all_goals { have a := 2 }</code> worked. Unsure why <code>;</code> doesn't.</p>

<a name="162186078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186078">Chris Hughes (Mar 31 2019 at 18:20)</a>:</h4>
<p>This worked for me</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">false</span> <span class="bp">∧</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="bp">;</span> <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>However, this didn't work</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">false</span> <span class="bp">∧</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">begin</span>
  <span class="n">split</span><span class="o">,</span> <span class="n">skip</span><span class="bp">;</span> <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>


<p>Maybe the semicolon only works for the goals generated by the last tactic.</p>

<a name="162186080"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186080" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186080">Rob Lewis (Mar 31 2019 at 18:20)</a>:</h4>
<p><code>sometac; have a := 2</code> works. Remember <code>have</code> is different from <code>let</code>. You'll get <code>a : ℕ</code> in the context, but won't see that it's 2.<br>
Edit: oh, I see the confusion. <code>;</code> doesn't mean "do the second tactic to all goals." I think <code>t; s</code> means "do <code>t</code> to the first goal, and then do <code>s</code> to all remaining goals."<br>
Edit 2: I'm thinking about too many things at once and writing unclearly, sorry. Chris phrased what I meant better. <code>t; s</code> focuses on the first goal, applies t, and then applies <code>s</code> to all goals generated from that. "Remaining goals" meaning remaining in the focus.</p>

<a name="162186223"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186223" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186223">Wojciech Nawrocki (Mar 31 2019 at 18:24)</a>:</h4>
<p>Double-checked, it acts wierdly:</p>
<div class="codehilite"><pre><span></span><span class="n">cases</span> <span class="n">h</span><span class="o">:</span> <span class="n">H</span><span class="bp">;</span> <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span> <span class="c1">-- works</span>
<span class="n">cases</span> <span class="n">h</span><span class="o">:</span> <span class="n">H</span><span class="o">,</span> <span class="n">skip</span><span class="bp">;</span> <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span> <span class="c1">-- doesn&#39;t work</span>
<span class="n">cases</span> <span class="n">h</span><span class="o">:</span> <span class="n">H</span><span class="o">,</span> <span class="n">case</span> <span class="n">Foo</span> <span class="o">{</span> <span class="bp">..</span> <span class="o">}</span><span class="bp">;</span> <span class="k">have</span> <span class="n">a</span> <span class="o">:=</span> <span class="mi">2</span><span class="o">,</span> <span class="c1">-- doesn&#39;t work</span>
</pre></div>

<a name="162186513"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186513" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186513">Reid Barton (Mar 31 2019 at 18:33)</a>:</h4>
<p>What Chris said. <code>x; y</code> applies <code>y</code> to each goal produced by <code>x</code>.</p>

<a name="162186557"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186557" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186557">Wojciech Nawrocki (Mar 31 2019 at 18:34)</a>:</h4>
<p>Oooh, ok! Thanks</p>

<a name="162186774"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162186774" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162186774">Wojciech Nawrocki (Mar 31 2019 at 18:41)</a>:</h4>
<p>Different question - in every goal I have a hypothesis of the form <code>h : hE' = Foo Γₑ' hΓ_1 N E_1 a</code>, where <code>Foo</code> is that goal's case. I would like to solve each goal by applying that goal/case's constructor, but with different arguments. Can I somehow "extract" which constructor was used for the case and reuse it to solve the goal without quoting expressions and all that?</p>

<a name="162242088"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162242088" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162242088">Wojciech Nawrocki (Apr 01 2019 at 14:09)</a>:</h4>
<p>How can I debug a <code>(deterministic) timeout</code> when Lean tries to prove well-foundedness of a recursion given my custom tactic?</p>

<a name="162242434"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162242434" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162242434">Wojciech Nawrocki (Apr 01 2019 at 14:13)</a>:</h4>
<p>Oh actually I also get a "failed to prove well-foundedness" with the state:</p>
<div class="codehilite"><pre><span></span><span class="n">h</span> <span class="o">:</span> <span class="n">hE&#39;</span> <span class="bp">=</span> <span class="n">EAppLeft</span> <span class="err">Γₑ&#39;</span> <span class="n">h</span><span class="err">Γ</span><span class="bp">_</span><span class="mi">1</span> <span class="n">N</span> <span class="n">E_1</span> <span class="n">a</span><span class="o">,</span>
<span class="err">Γ</span> <span class="o">:</span> <span class="kn">context</span> <span class="n">γ</span><span class="o">,</span>
<span class="n">M</span> <span class="o">:</span> <span class="n">term</span> <span class="err">Γ</span> <span class="n">A&#39;&#39;</span>
<span class="err">⊢</span> <span class="n">eval_ctx</span><span class="bp">.</span><span class="n">sizeof</span>
      <span class="o">(((</span><span class="bp">⟨</span><span class="n">γ</span><span class="o">,</span>
          <span class="bp">⟨</span><span class="err">Γₑ</span><span class="o">,</span>
           <span class="bp">⟨</span><span class="err">Γ₁</span><span class="o">,</span>
            <span class="bp">⟨</span><span class="n">A&#39;&#39;</span><span class="o">,</span>
             <span class="bp">⟨</span><span class="n">A&#39;</span><span class="o">,</span>
              <span class="bp">⟨</span><span class="n">A_1</span><span class="err">⊸</span><span class="n">A</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">E</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hE</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">E_1</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span> <span class="bp">⟨</span><span class="err">Γₑ</span> <span class="bp">+</span> <span class="err">Γ₁</span><span class="o">,</span> <span class="bp">_⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span>
      <span class="o">(((((((((</span><span class="bp">⟨</span><span class="n">γ</span><span class="o">,</span>
                <span class="bp">⟨</span><span class="err">Γₑ</span><span class="o">,</span>
                 <span class="bp">⟨</span><span class="err">Γ₁</span><span class="o">,</span>
                  <span class="bp">⟨</span><span class="n">A&#39;&#39;</span><span class="o">,</span>
                   <span class="bp">⟨</span><span class="n">A&#39;</span><span class="o">,</span>
                    <span class="bp">⟨</span><span class="n">A_1</span><span class="err">⊸</span><span class="n">A</span><span class="o">,</span>
                     <span class="bp">⟨</span><span class="n">E</span><span class="o">,</span>
                      <span class="bp">⟨</span><span class="n">hE</span><span class="o">,</span>
                       <span class="bp">⟨</span><span class="n">E_1</span><span class="o">,</span>
                        <span class="bp">⟨</span><span class="n">a</span><span class="o">,</span>
                         <span class="bp">⟨</span><span class="err">Γₑ</span> <span class="bp">+</span> <span class="err">Γ₁</span><span class="o">,</span>
                          <span class="bp">_⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span>
      <span class="n">a</span> <span class="bp">&lt;</span>
    <span class="n">eval_ctx</span><span class="bp">.</span><span class="n">sizeof</span>
      <span class="o">(((</span><span class="bp">⟨</span><span class="n">γ</span><span class="o">,</span>
          <span class="bp">⟨</span><span class="err">Γₑ</span><span class="o">,</span>
           <span class="bp">⟨</span><span class="err">Γₑ&#39;</span><span class="o">,</span>
            <span class="bp">⟨</span><span class="n">A&#39;&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">A&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">A</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">E</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hE</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">E&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="n">hE&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="err">Γ</span><span class="o">,</span> <span class="n">h</span><span class="err">Γ</span><span class="bp">⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span>
      <span class="o">(((((((((</span><span class="bp">⟨</span><span class="n">γ</span><span class="o">,</span>
                <span class="bp">⟨</span><span class="err">Γₑ</span><span class="o">,</span>
                 <span class="bp">⟨</span><span class="err">Γₑ&#39;</span><span class="o">,</span>
                  <span class="bp">⟨</span><span class="n">A&#39;&#39;</span><span class="o">,</span>
                   <span class="bp">⟨</span><span class="n">A&#39;</span><span class="o">,</span>
                    <span class="bp">⟨</span><span class="n">A</span><span class="o">,</span>
                     <span class="bp">⟨</span><span class="n">E</span><span class="o">,</span>
                      <span class="bp">⟨</span><span class="n">hE</span><span class="o">,</span>
                       <span class="bp">⟨</span><span class="n">E&#39;</span><span class="o">,</span>
                        <span class="bp">⟨</span><span class="n">hE&#39;</span><span class="o">,</span> <span class="bp">⟨</span><span class="err">Γ</span><span class="o">,</span> <span class="n">h</span><span class="err">Γ</span><span class="bp">⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩⟩.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="o">)</span><span class="bp">.</span><span class="n">fst</span><span class="o">)</span>
      <span class="n">hE&#39;</span>
</pre></div>


<p>Since <code>h: hE' = EAppLeft ... a</code> is in the context, why can't Lean just rewrite it using that and then show that <code>sizeof a &lt; sizeof EAppLeft .. a</code>?</p>

<a name="162245368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162245368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162245368">Andrew Ashworth (Apr 01 2019 at 14:47)</a>:</h4>
<p>this error log is pretty hard to understand just by looking at it</p>

<a name="162245470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162245470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162245470">Andrew Ashworth (Apr 01 2019 at 14:48)</a>:</h4>
<p>what always gets linked when these things come up: TPIL and <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/well_founded_recursion.md</a></p>

<a name="162246128"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162246128" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162246128">Andrew Ashworth (Apr 01 2019 at 14:55)</a>:</h4>
<p>what is not mentioned in the mathlib doc is what I usually do when I don't want to stare at a bunch of errors: prove my relation is well-founded by hand <code>well_founded r</code> and directly use <code>well_founded.fix</code></p>

<a name="162246653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162246653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162246653">Wojciech Nawrocki (Apr 01 2019 at 15:01)</a>:</h4>
<p>Oh yeah I'd read that, but was hoping Lean could employ a bit of automation when trying to prove the inequality. I'll try <code>fix</code> as I don't think I can use <code>have</code>( the fn definition is entirely in tactic mode), thanks.</p>

<a name="162247008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162247008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162247008">Andrew Ashworth (Apr 01 2019 at 15:04)</a>:</h4>
<p>oh, don't forget <a href="http://adam.chlipala.net/cpdt/html/GeneralRec.html" target="_blank" title="http://adam.chlipala.net/cpdt/html/GeneralRec.html">http://adam.chlipala.net/cpdt/html/GeneralRec.html</a></p>

<a name="162247040"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162247040" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162247040">Andrew Ashworth (Apr 01 2019 at 15:04)</a>:</h4>
<p>the definitions are sorta almost the same if you squint</p>

<a name="162316155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316155">snowbunting (Apr 02 2019 at 09:12)</a>:</h4>
<p>What would be the correct way to define a function from ℤ to (abelian) groups? (i.e. having indexed groups G_1, G_2, ...)</p>
<p>I don't think that this here is working as it should.  This would be a constant function, wouldn't it?</p>
<div class="codehilite"><pre><span></span>universes u
variables {α: Type u}
def my_indexes_groups (i:ℤ) := add_group α
#check my_indexes_groups 3
</pre></div>


<p>Thx :)</p>

<a name="162316216"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316216" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316216">Johan Commelin (Apr 02 2019 at 09:12)</a>:</h4>
<p>No, because then all groups have the same cardinality</p>

<a name="162316224"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316224" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316224">Kevin Buzzard (Apr 02 2019 at 09:12)</a>:</h4>
<p>You define a function from Z to <code>Type</code></p>

<a name="162316234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316234">Johan Commelin (Apr 02 2019 at 09:12)</a>:</h4>
<p>What you do is <code>G : Z → Type</code></p>

<a name="162316254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316254">Johan Commelin (Apr 02 2019 at 09:13)</a>:</h4>
<p>And then <code>[\for i, add_group G i]</code></p>

<a name="162316274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316274">Kevin Buzzard (Apr 02 2019 at 09:13)</a>:</h4>
<p>And then you define another function from Z to the structure of a group on the image of the first function :-)</p>

<a name="162316367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316367">Kevin Buzzard (Apr 02 2019 at 09:14)</a>:</h4>
<p>And you also note that Lean's definition of <code>add_group</code> doesn't require commutativity so if you're doing exact sequences you might want to use add_comm_group</p>

<a name="162316397"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316397" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316397">Kevin Buzzard (Apr 02 2019 at 09:15)</a>:</h4>
<p>Johan and I are both interested in seeing exact sequences in Lean by the way, we're both mathematicians</p>

<a name="162316483"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316483" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316483">Kevin Buzzard (Apr 02 2019 at 09:16)</a>:</h4>
<p>The way to think about groups in Lean is that they are two things. First you have G, a <em>type</em></p>

<a name="162316499"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316499" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316499">Kevin Buzzard (Apr 02 2019 at 09:16)</a>:</h4>
<p>And then you have another thing h, a term of type [group G]</p>

<a name="162316522"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316522" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316522">Kevin Buzzard (Apr 02 2019 at 09:17)</a>:</h4>
<p>And it's h that has all the data of the multiplication and the axioms</p>

<a name="162316532"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316532" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316532">Kevin Buzzard (Apr 02 2019 at 09:17)</a>:</h4>
<p>But amazingly you never have to mention h at all when you're working with groups</p>

<a name="162316589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316589">Kevin Buzzard (Apr 02 2019 at 09:18)</a>:</h4>
<p>Because whenever Lean needs this data it gets it from G using something called type class inference</p>

<a name="162316617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316617">Kevin Buzzard (Apr 02 2019 at 09:18)</a>:</h4>
<p>You try to do a group thing on G like multiplying two elements together</p>

<a name="162316655"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316655" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316655">snowbunting (Apr 02 2019 at 09:19)</a>:</h4>
<p>ok that works indeed! Maybe it would be actually ask to ask what the difference between <code>Type</code> and <code>Type u</code> is, although it feels super dumb...</p>

<a name="162316675"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316675" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316675">Kevin Buzzard (Apr 02 2019 at 09:19)</a>:</h4>
<p>And Lean says "what's this multiplication they're talking about? Does my big list of type class stuff contain anything which mentions a multiplication on G? And then it looks and it finds h and says "ok I'll just use that stuff"</p>

<a name="162316719"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316719" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316719">Kevin Buzzard (Apr 02 2019 at 09:20)</a>:</h4>
<p>Type is Type 0</p>

<a name="162316729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316729">Kevin Buzzard (Apr 02 2019 at 09:20)</a>:</h4>
<p>In type theory everything has to have a type</p>

<a name="162316736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316736">Kevin Buzzard (Apr 02 2019 at 09:20)</a>:</h4>
<p>So unfortunately Type has to have a type</p>

<a name="162316742"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316742" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316742">Kevin Buzzard (Apr 02 2019 at 09:20)</a>:</h4>
<p>Which is Type 1</p>

<a name="162316743"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316743" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316743">Kevin Buzzard (Apr 02 2019 at 09:20)</a>:</h4>
<p>You get the picture</p>

<a name="162316760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316760">Kevin Buzzard (Apr 02 2019 at 09:21)</a>:</h4>
<p>Type u is a random universe somewhere up in the hierarchy</p>

<a name="162316792"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316792" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316792">Kevin Buzzard (Apr 02 2019 at 09:21)</a>:</h4>
<p>It's best practice to make functions and constructions take inputs from arbitrary universes in type theory</p>

<a name="162316875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316875">Kevin Buzzard (Apr 02 2019 at 09:22)</a>:</h4>
<p>You should do a map from Z to <code>Type u</code> really</p>

<a name="162316906"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162316906" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162316906">Kevin Buzzard (Apr 02 2019 at 09:23)</a>:</h4>
<p>People might also write <code>Type*</code> -- this is the same thing, it just saves you having to name u</p>

<a name="162317141"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162317141" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162317141">snowbunting (Apr 02 2019 at 09:28)</a>:</h4>
<p>ok so <code>u</code> really is just a number, like <code>Type u</code> one of <code>Type 0</code>, <code>Type 1</code>,  ...<br>
And if I don't want to force two variables to be both for example <code>Type 2</code> simultaneously, then I should use <code>Type u</code> and <code>Type v</code> in the definition, right?</p>
<p>And if I would write <code>def xxx (a: Type*) (b: Type*): Type* := sorry</code> then there is no constrains if they have the same type or not, is there?</p>
<p>Thx :)</p>

<a name="162317205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162317205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162317205">Kevin Buzzard (Apr 02 2019 at 09:28)</a>:</h4>
<p>That's right.</p>

<a name="162317229"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162317229" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162317229">Kevin Buzzard (Apr 02 2019 at 09:29)</a>:</h4>
<p>u is a natural number, but it's not a Lean natural number, it's a universe variable, which is treated differently; it's part of the core language or something.</p>

<a name="162342248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162342248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162342248">snowbunting (Apr 02 2019 at 14:53)</a>:</h4>
<blockquote>
<p>And then <code>[\for i, add_group G]</code></p>
</blockquote>
<p>This works great together with <code>variable</code>, but how would I now include that into a class? This does not seem to be working:</p>
<div class="codehilite"><pre><span></span><span class="kn">universe</span> <span class="n">u</span>
<span class="n">class</span> <span class="n">chain</span> <span class="o">(</span><span class="n">α</span><span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
    <span class="o">(</span><span class="n">group</span> <span class="o">(</span><span class="n">i</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">):</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span>
    <span class="o">(</span><span class="n">diff</span> <span class="o">{</span><span class="n">i</span><span class="o">:</span><span class="bp">ℤ</span><span class="o">}:</span> <span class="o">(</span><span class="n">group</span> <span class="n">i</span><span class="o">)</span> <span class="bp">→</span> <span class="o">(</span><span class="n">group</span> <span class="o">(</span><span class="n">i</span><span class="bp">-</span><span class="mi">1</span><span class="o">)))</span>
    <span class="o">[</span><span class="n">x</span><span class="o">:</span> <span class="bp">∀</span><span class="n">i</span><span class="o">,</span> <span class="n">add_comm_group</span> <span class="o">(</span><span class="n">group</span> <span class="n">i</span><span class="o">)]</span>

<span class="kn">variable</span> <span class="o">(</span><span class="n">C</span><span class="o">:</span> <span class="kt">Type</span><span class="o">)</span>
<span class="kn">variable</span> <span class="o">[</span><span class="n">chain</span> <span class="n">C</span><span class="o">]</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">g</span> <span class="n">h</span><span class="o">:</span> <span class="n">chain</span><span class="bp">.</span><span class="n">group</span> <span class="n">C</span> <span class="mi">1</span><span class="o">)</span>

<span class="bp">#</span><span class="kn">check</span> <span class="n">g</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">chain</span><span class="bp">.</span><span class="n">group</span> <span class="n">C</span> <span class="mi">1</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">chain</span><span class="bp">.</span><span class="n">diff</span> <span class="n">g</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">g</span> <span class="bp">+</span> <span class="n">h</span>    <span class="c1">-- has_add (chain.group C 1)</span>
</pre></div>

<a name="162342427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162342427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162342427">Johan Commelin (Apr 02 2019 at 14:54)</a>:</h4>
<p>Put it with <code>()</code> in the class. Then aftwerwards state:</p>
<div class="codehilite"><pre><span></span><span class="kn">instance</span> <span class="n">foo</span> <span class="o">(</span><span class="n">i</span> <span class="o">:</span> <span class="bp">ℤ</span><span class="o">)</span> <span class="o">:</span> <span class="n">add_group</span> <span class="n">C</span> <span class="n">i</span> <span class="o">:=</span> <span class="n">C</span><span class="bp">.</span><span class="n">x</span> <span class="n">i</span>
</pre></div>

<a name="162342450"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162342450" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162342450">Johan Commelin (Apr 02 2019 at 14:54)</a>:</h4>
<p>Modulo mistakes</p>

<a name="162342638"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162342638" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162342638">Johan Commelin (Apr 02 2019 at 14:56)</a>:</h4>
<p>Also, you might be interested in <code>category_theory/</code></p>

<a name="162342654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162342654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162342654">snowbunting (Apr 02 2019 at 14:56)</a>:</h4>
<p>Of course, I should have remembered <code>instance</code>, used that before, thank you!</p>

<a name="162358531"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162358531" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162358531">Kevin Buzzard (Apr 02 2019 at 17:59)</a>:</h4>
<p>Your alpha doesn't do anything</p>

<a name="162358571"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162358571" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162358571">Kevin Buzzard (Apr 02 2019 at 17:59)</a>:</h4>
<p>You could just remove it, and you could change class to structure</p>

<a name="162358765"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162358765" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162358765">Kevin Buzzard (Apr 02 2019 at 18:01)</a>:</h4>
<p>Then a term of type <code>chain</code> would be a bunch of abelian groups and homs</p>

<a name="162358791"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162358791" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162358791">Kevin Buzzard (Apr 02 2019 at 18:01)</a>:</h4>
<p>You use <code>class</code> when there's only expected to be one term of that type</p>

<a name="162378298"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162378298" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162378298">Scott Morrison (Apr 02 2019 at 22:05)</a>:</h4>
<blockquote>
<p>Also, you might be interested in <code>category_theory/</code></p>
</blockquote>
<p>Regarding initial experiments, this isn't meant at all as discouragement --- but eventually we'd like the definition of <code>chain_complex</code> to be as generic as possible (e.g. any category enriched in a category with_zero).</p>

<a name="162659075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162659075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162659075">Wojciech Nawrocki (Apr 05 2019 at 20:42)</a>:</h4>
<p>Is there anything I can do to debug "equation compiler failed to prove equation lemma (workaround: disable lemma generation using <code>set_option eqn_compiler.lemmas false</code>)"?</p>

<a name="162661482"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162661482" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162661482">Kevin Buzzard (Apr 05 2019 at 21:10)</a>:</h4>
<p>Wow that's some error! How did you get that?</p>

<a name="162661525"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162661525" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162661525">Patrick Massot (Apr 05 2019 at 21:11)</a>:</h4>
<p>Kevin is so jalous...</p>

<a name="162666797"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162666797" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162666797">Wojciech Nawrocki (Apr 05 2019 at 22:24)</a>:</h4>
<p>:) It happens in <a href="https://github.com/Vtec234/lean-sesh/blob/master/src/sesh/eval.lean#L194" target="_blank" title="https://github.com/Vtec234/lean-sesh/blob/master/src/sesh/eval.lean#L194">this definition (link)</a></p>

<a name="162667290"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162667290" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162667290">Kevin Buzzard (Apr 05 2019 at 22:31)</a>:</h4>
<p>it doesn't compile for me because it needs imports I don't have :-/</p>

<a name="162667295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162667295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162667295">Kevin Buzzard (Apr 05 2019 at 22:31)</a>:</h4>
<p>but even if it did compile for me I think I wouldn't be able to help.</p>

<a name="162669637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162669637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162669637">Wojciech Nawrocki (Apr 05 2019 at 23:04)</a>:</h4>
<p>Oh, it's self-contained modulo downloading mathlib, but for some reason leanpkg.path was in my .gitignore and it's needed for import paths to resolve - fixed that</p>

<a name="162671215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162671215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162671215">Reid Barton (Apr 05 2019 at 23:31)</a>:</h4>
<p>leanpkg.path should indeed be in .gitignore (assuming you are actually using leanpkg)</p>

<a name="162678219"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162678219" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162678219">Mario Carneiro (Apr 06 2019 at 02:15)</a>:</h4>
<p>Is it related to the use of <code>let</code> in the type of the function you are defining by pattern matching?</p>

<a name="162720668"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162720668" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162720668">Wojciech Nawrocki (Apr 06 2019 at 21:09)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> it doesn't seem like it, I can inline the <code>let</code>, same error</p>

<a name="162720727"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162720727" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162720727">Mario Carneiro (Apr 06 2019 at 21:10)</a>:</h4>
<p>do you have a self contained MWE?</p>

<a name="162720738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162720738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162720738">Mario Carneiro (Apr 06 2019 at 21:10)</a>:</h4>
<p>(Try putting everything needed in one file, then start deleting things that don't matter for the error)</p>

<a name="162944584"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162944584" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162944584">Wojciech Nawrocki (Apr 09 2019 at 19:57)</a>:</h4>
<p><span class="user-mention" data-user-id="110049">@Mario Carneiro</span> thanks, that was good idea! It took a while but I was able to simplify it to this:</p>
<div class="codehilite"><pre><span></span><span class="kn">inductive</span> <span class="n">foo</span><span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="n">def</span> <span class="n">foo_fn</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">):</span> <span class="kt">Type</span> <span class="o">:=</span> <span class="n">foo</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">→</span> <span class="n">foo</span> <span class="n">n</span> <span class="n">m</span>

<span class="kn">inductive</span> <span class="n">is_foo_fn</span>
  <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">},</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span> <span class="bp">→</span> <span class="kt">Type</span>
<span class="bp">|</span> <span class="n">IsFooEta</span><span class="o">:</span>
  <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span> <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span><span class="o">},</span>
  <span class="n">is_foo_fn</span> <span class="n">f</span>
<span class="bp">→</span> <span class="n">is_foo_fn</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">M</span><span class="o">,</span> <span class="n">f</span> <span class="n">M</span><span class="o">)</span>
<span class="kn">open</span> <span class="n">is_foo_fn</span>

<span class="n">def</span> <span class="n">ext</span><span class="o">:</span> <span class="c1">-- equation compiler failed to prove equation lemma (workaround: disable lemma generation using `set_option eqn_compiler.lemmas false`)</span>
    <span class="bp">Π</span> <span class="o">{</span><span class="n">m</span> <span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>
      <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span><span class="o">},</span>
    <span class="n">is_foo_fn</span> <span class="n">f</span>
  <span class="bp">→</span> <span class="err">Σ</span> <span class="n">f&#39;</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">is_foo_fn</span> <span class="n">f&#39;</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">IsFooEta</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">⟨_</span><span class="o">,</span> <span class="n">IsFooEta</span> <span class="o">(</span><span class="n">ext</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="bp">⟩</span>
</pre></div>


<p>which still fails, while making the following change makes the eqn compiler work:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">ext</span><span class="o">:</span> <span class="c1">-- good</span>
    <span class="bp">Π</span> <span class="o">{</span><span class="n">n</span> <span class="n">m</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">}</span>
      <span class="o">{</span><span class="n">f</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span><span class="o">},</span>
    <span class="n">is_foo_fn</span> <span class="n">f</span>
  <span class="bp">→</span> <span class="err">Σ</span> <span class="n">f&#39;</span><span class="o">:</span> <span class="n">foo_fn</span> <span class="n">n</span> <span class="n">m</span><span class="o">,</span> <span class="n">is_foo_fn</span> <span class="n">f&#39;</span>
<span class="bp">|</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="o">(</span><span class="n">IsFooEta</span> <span class="n">f</span><span class="o">)</span> <span class="o">:=</span>
  <span class="bp">⟨_</span><span class="o">,</span> <span class="n">IsFooEta</span> <span class="o">(</span><span class="n">ext</span> <span class="n">f</span><span class="o">)</span><span class="bp">.</span><span class="n">snd</span><span class="bp">⟩</span>
</pre></div>


<p>Can you spot the difference? :) (it's the order of arguments). To me this seems like an eqn_compiler bug</p>

<a name="162947094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947094">Wojciech Nawrocki (Apr 09 2019 at 20:30)</a>:</h4>
<p><span class="user-mention" data-user-id="110024">@Sebastian Ullrich</span> What do you think? Is this a bug or am I missing something obvious?</p>

<a name="162947160"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947160" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947160">Kevin Buzzard (Apr 09 2019 at 20:31)</a>:</h4>
<p>Thanks for putting in the effort. I've never seen this error before.</p>

<a name="162947406"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947406" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947406">Sebastian Ullrich (Apr 09 2019 at 20:34)</a>:</h4>
<p>Me neither</p>

<a name="162947461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947461">Patrick Massot (Apr 09 2019 at 20:34)</a>:</h4>
<p>Can you reproduce it in Lean 4?</p>

<a name="162947480"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947480" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947480">Patrick Massot (Apr 09 2019 at 20:35)</a>:</h4>
<p>If not, then who cares about this error?</p>

<a name="162947821"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947821" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947821">Kevin Buzzard (Apr 09 2019 at 20:39)</a>:</h4>
<p>those of us who are stuck with Lean 3?</p>

<a name="162947830"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162947830" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162947830">Kevin Buzzard (Apr 09 2019 at 20:39)</a>:</h4>
<p>;-)</p>

<a name="162956880"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162956880" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162956880">Andrew Ashworth (Apr 09 2019 at 22:42)</a>:</h4>
<p>I don't have time to look into this deeply, but just remarking that I have seen 'equation compiler failed to prove equation lemma' before</p>

<a name="162956912"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162956912" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162956912">Andrew Ashworth (Apr 09 2019 at 22:42)</a>:</h4>
<p>a very long time ago, I think the last time I saw it there was some problem with eta reduction</p>

<a name="162956941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/162956941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#162956941">Andrew Ashworth (Apr 09 2019 at 22:43)</a>:</h4>
<p>but i could be hallucinating how I fixed it, since it was awhile ago</p>

<a name="163636511"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636511" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636511">Kevin Kappelmann (Apr 18 2019 at 09:51)</a>:</h4>
<p>Given</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
<span class="n">unfold</span> <span class="n">P</span><span class="o">,</span> <span class="c1">-- this unfolds both occurrences</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>


<p>how can I unfold <code>P</code> just at the right-hand side?</p>

<a name="163636605"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636605" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636605">Kevin Buzzard (Apr 18 2019 at 09:52)</a>:</h4>
<p>you can just use <code>change</code> or <code>show</code></p>

<a name="163636661"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636661" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636661">Kevin Buzzard (Apr 18 2019 at 09:53)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
  <span class="k">show</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">((</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">&gt;</span> <span class="mi">42</span><span class="o">),</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163636738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636738">Kevin Buzzard (Apr 18 2019 at 09:54)</a>:</h4>
<p>If you're planning on using the <code>rw</code> tactic, then Lean might be very fussy about exactly which form a term is in</p>

<a name="163636776"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636776" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636776">Kevin Buzzard (Apr 18 2019 at 09:55)</a>:</h4>
<p>but conversely Lean is happy to switch between definitionally equal forms of the same term, using the <code>change</code> and <code>show</code> tactics (which do the same thing, <code>change</code> having the advantage that it also works for hypotheses in your context with <code>change ... at H</code>)</p>

<a name="163636784"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636784" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636784">Kevin Kappelmann (Apr 18 2019 at 09:55)</a>:</h4>
<p>Ah okay, thanks. If my goal statement is very long though, I end up copy-pasting a lot of text.</p>

<a name="163636823"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636823" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636823">Kevin Buzzard (Apr 18 2019 at 09:56)</a>:</h4>
<p>there are other ways</p>

<a name="163636873"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636873" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636873">Kevin Buzzard (Apr 18 2019 at 09:57)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
  <span class="n">conv</span> <span class="k">begin</span>
    <span class="n">to_rhs</span><span class="o">,</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">P</span><span class="o">],</span>
  <span class="kn">end</span><span class="o">,</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163636890"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636890" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636890">Kevin Buzzard (Apr 18 2019 at 09:57)</a>:</h4>
<p><code>conv</code> mode is a mode which isn't mentioned at all in the official docs</p>

<a name="163636893"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636893" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636893">Kevin Buzzard (Apr 18 2019 at 09:57)</a>:</h4>
<p>It enables you to zoom into parts of terms</p>

<a name="163636946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636946">Kevin Buzzard (Apr 18 2019 at 09:58)</a>:</h4>
<p>Unfortunately, when you're in conv mode, the tools available to you are completely different, and it doesn't look like <code>unfold</code> is available yet.</p>

<a name="163636948"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636948" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636948">Kevin Buzzard (Apr 18 2019 at 09:58)</a>:</h4>
<p>So I had to use <code>simp only</code></p>

<a name="163636952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636952">Kevin Buzzard (Apr 18 2019 at 09:58)</a>:</h4>
<p>which is close to the same thing</p>

<a name="163636953"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636953" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636953">Kevin Kappelmann (Apr 18 2019 at 09:58)</a>:</h4>
<p>uuh, the hidden secrets. that does not seem very elegant to me though :')</p>

<a name="163636958"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636958" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636958">Kevin Buzzard (Apr 18 2019 at 09:58)</a>:</h4>
<p>The community documented <code>conv</code> mode.</p>

<a name="163636975"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636975" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636975">Kevin Kappelmann (Apr 18 2019 at 09:58)</a>:</h4>
<p>I though I could make use of some pattern matching or occurrence counting when I was reading <a href="https://leanprover.github.io/tutorial/A1_Quick_Reference.html" target="_blank" title="https://leanprover.github.io/tutorial/A1_Quick_Reference.html">https://leanprover.github.io/tutorial/A1_Quick_Reference.html</a> A1.6.2.1</p>

<a name="163636989"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636989" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636989">Kevin Kappelmann (Apr 18 2019 at 09:59)</a>:</h4>
<p>But I am either to silly or misinterpreting what is written there.</p>

<a name="163636992"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163636992" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163636992">Kevin Buzzard (Apr 18 2019 at 09:59)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/conv.md</a></p>

<a name="163637060"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637060" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637060">Kevin Buzzard (Apr 18 2019 at 10:00)</a>:</h4>
<p>Your link there is to an out of date file :-/ That's Lean 2 you're looking at</p>

<a name="163637073"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637073" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637073">Kevin Buzzard (Apr 18 2019 at 10:00)</a>:</h4>
<p>You can use <code>conv</code> to zoom directly into the right hand side with <code>conv in</code> or <code>conv at</code> or something, I can never remember the details, but they're clearly documented in Patrick's conv.md write-up</p>

<a name="163637094"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637094" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637094">Kevin Kappelmann (Apr 18 2019 at 10:01)</a>:</h4>
<p>Oh damn, google fooled me</p>

<a name="163637097"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637097" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637097">Kevin Buzzard (Apr 18 2019 at 10:01)</a>:</h4>
<p>That way you avoid the <code>to_rhs</code> conv-mode tactic</p>

<a name="163637103"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637103" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637103">Kevin Buzzard (Apr 18 2019 at 10:01)</a>:</h4>
<blockquote>
<p>Oh damn, google fooled me</p>
</blockquote>
<p>call them up and complain</p>

<a name="163637176"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637176" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637176">Kevin Buzzard (Apr 18 2019 at 10:02)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
  <span class="n">conv</span> <span class="k">in</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="k">begin</span>
    <span class="n">simp</span> <span class="n">only</span> <span class="o">[</span><span class="n">P</span><span class="o">],</span>
  <span class="kn">end</span><span class="o">,</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163637250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637250">Kevin Buzzard (Apr 18 2019 at 10:03)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="o">(</span><span class="k">show</span> <span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">)</span> <span class="bp">=</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span><span class="o">),</span> <span class="k">from</span> <span class="n">rfl</span><span class="o">),</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163637270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637270">Kevin Buzzard (Apr 18 2019 at 10:03)</a>:</h4>
<p>This way avoids conv mode and is more precise about what you want done</p>

<a name="163637329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637329">Kevin Buzzard (Apr 18 2019 at 10:04)</a>:</h4>
<p>What exactly are you looking for? Tactic-writers here are very good.</p>

<a name="163637360"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637360" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637360">Kevin Buzzard (Apr 18 2019 at 10:04)</a>:</h4>
<p>People can just make new stuff. Lean tactics are written in Lean and some people (not me though! I'm a mathematician) can just knock them off before breakfast.</p>

<a name="163637832"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637832" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637832">Kevin Kappelmann (Apr 18 2019 at 10:11)</a>:</h4>
<p>Basically, I had a rather long equation of the form <code>l=r</code> and I wanted to unfold an expression in <code>r</code> by its definition, which again, is a rather long term. Hence, I neither want to re-state the whole goal nor the result of the unfolded definition. What I want to do is something like</p>
<div class="codehilite"><pre><span></span><span class="k">begin</span>
<span class="n">unfold</span> <span class="n">P</span> <span class="o">{</span><span class="mi">2</span><span class="o">}</span> <span class="c1">-- this should unfold the second occurrence of P in the goal (or the third if you count from zero)</span>
<span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163637905"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637905" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637905">Kevin Buzzard (Apr 18 2019 at 10:12)</a>:</h4>
<p><span class="user-mention" data-user-id="110043">@Gabriel Ebner</span> is that already a tactic, do you know?</p>

<a name="163637917"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163637917" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163637917">Kevin Buzzard (Apr 18 2019 at 10:12)</a>:</h4>
<p>Is there any obstruction to making it?</p>

<a name="163638014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638014">Kevin Buzzard (Apr 18 2019 at 10:14)</a>:</h4>
<p><span class="user-mention" data-user-id="198376">@Kevin Kappelmann</span> you could just do all the unfolds manually, ignore what happens to <code>l</code>, and then once you've got <code>r</code> into the form you want you can just delet everything and write <code>show _ = [what you want r to be]</code></p>

<a name="163638029"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638029" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638029">Kevin Buzzard (Apr 18 2019 at 10:14)</a>:</h4>
<p>(the point being that <code>show</code> will take <code>_</code> for the left hand side)</p>

<a name="163638165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638165">Kevin Buzzard (Apr 18 2019 at 10:16)</a>:</h4>
<p>I think I've now told you all the tricks I know -- but I can see that your proposed idea is nicer. It might be a pain though -- if you want to unfold a bunch of stuff in <code>r</code> but not in <code>l</code> you might have to keep changing the numbers, depending on which things you want to unfold in <code>r</code> also show up in <code>l</code>. I think that if you're adamant that you want to change <code>r</code> and leave <code>l</code> untouched, just use <code>conv</code> mode and <code>to_rhs</code>. That's only a couple of lines and I think it's better than your idea because of the issue with numbers perhaps changing depending on exactly you want to unfold.</p>

<a name="163638189"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638189" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638189">Gabriel Ebner (Apr 18 2019 at 10:17)</a>:</h4>
<p>Yes, you can do this with <code>conv</code>.  Unfortunately, <code>unfold</code> isn't wrapped so you need to use <code>simp</code>.</p>
<div class="codehilite"><pre><span></span><span class="n">conv</span> <span class="o">{</span> <span class="n">for</span> <span class="o">(</span><span class="n">P</span> <span class="bp">_</span><span class="o">)</span> <span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">{</span> <span class="n">simp</span> <span class="o">[</span><span class="n">P</span><span class="o">]</span> <span class="o">}</span> <span class="o">},</span>
</pre></div>

<a name="163638194"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638194" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638194">Kevin Buzzard (Apr 18 2019 at 10:17)</a>:</h4>
<p>OTOH I guess your idea has its merits when there is more than one occurrence of P in the RHS.</p>

<a name="163638210"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638210" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638210">Kevin Buzzard (Apr 18 2019 at 10:17)</a>:</h4>
<p>Aah, I'd forgotten <code>conv</code> could take numbers!</p>

<a name="163638215"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638215" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638215">Kevin Buzzard (Apr 18 2019 at 10:17)</a>:</h4>
<p>Thanks Gabriel</p>

<a name="163638303"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638303" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638303">Kevin Buzzard (Apr 18 2019 at 10:18)</a>:</h4>
<p>hey what is this voodoo? <code>for</code>? I thought functional languages didn't have <code>for</code> loops!</p>

<a name="163638383"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638383" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638383">Kevin Buzzard (Apr 18 2019 at 10:20)</a>:</h4>
<p>Aah yes, I see now that <code>for</code> is documented in the <code>conv</code> document I linked to earlier.</p>

<a name="163638461"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638461" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638461">Kevin Buzzard (Apr 18 2019 at 10:20)</a>:</h4>
<p>It's about time I re-read it :D</p>

<a name="163638592"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638592" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638592">Kevin Buzzard (Apr 18 2019 at 10:22)</a>:</h4>
<p>I'll show you a Lean trick Kevin. </p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="bp">#</span><span class="kn">print</span> <span class="kn">prefix</span> <span class="n">P</span>

<span class="c1">-- P.equations._eqn_1 : ∀ (n : ℕ), P n = (n &gt; 42)</span>
</pre></div>


<p>When you define <code>P</code>, Lean makes one or more "equation lemmas" for it. <code>unfold P</code> is basically the same as <code>simp only [P.equations._eqn_1]</code> or <code>simp only [P]</code> for short. It's a shame there's no <code>unfold</code> in <code>conv</code> mode, but these are the tricks you can use to emulate it.</p>

<a name="163638639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638639">Kevin Buzzard (Apr 18 2019 at 10:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">P</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="kt">Prop</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">&gt;</span> <span class="mi">42</span>

<span class="kn">example</span> <span class="o">(</span><span class="n">n</span><span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">P</span> <span class="n">n</span> <span class="bp">=</span> <span class="o">(</span><span class="n">P</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">))</span> <span class="o">:=</span> <span class="c1">-- this is obviously false</span>
<span class="k">begin</span>
  <span class="n">rw</span> <span class="n">P</span><span class="bp">.</span><span class="n">equations</span><span class="bp">._</span><span class="n">eqn_1</span> <span class="o">(</span><span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="n">n</span><span class="o">),</span>
  <span class="n">sorry</span>
<span class="kn">end</span>
</pre></div>

<a name="163638662"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638662" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638662">Kevin Kappelmann (Apr 18 2019 at 10:23)</a>:</h4>
<p>Okay, I summarise: <code>conv</code> is pretty useful, I should read about it, and I guess it should also be included in the official docs at some point to avoid noobs like me wondering how to rewrite subterms :p</p>

<a name="163638723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638723">Kevin Buzzard (Apr 18 2019 at 10:24)</a>:</h4>
<p>The Lean team is currently working on Lean 4, I don't think they're interested in documentation-writing at the minute.</p>

<a name="163638734"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638734" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638734">Kevin Buzzard (Apr 18 2019 at 10:24)</a>:</h4>
<p>If Lean 4 is a success then we'll all be porting the docs over to there</p>

<a name="163638750"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638750" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638750">Kevin Buzzard (Apr 18 2019 at 10:25)</a>:</h4>
<p>The community-written docs are really helpful for technical questions not covered by Theorem Proving In Lean.</p>

<a name="163638771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638771">Kevin Buzzard (Apr 18 2019 at 10:25)</a>:</h4>
<p>They all live in the mathlib repo but they're not really anything to do with mathlib, they're just where these community-generated docs ended up.</p>

<a name="163638971"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163638971" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163638971">Kevin Kappelmann (Apr 18 2019 at 10:29)</a>:</h4>
<p>I see. I think rewriting subterms is quite common though, so I would mention it at least in the official doc. Anyway, thanks Kevin &amp; Gabriel :)</p>

<a name="163648072"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163648072" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163648072">Jesse Michael Han (Apr 18 2019 at 12:52)</a>:</h4>
<p>you can use underscores with <code>change</code> and Lean will try to infer what should be there from the current goal. that way <code>change _ = new_rhs</code> lets you avoid copy-pasting the entire left hand side</p>

<a name="163860118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860118">Greg Conneen (Apr 21 2019 at 17:24)</a>:</h4>
<p>How would I go about proving ∀ x : ℤ, even x ∨ odd x? I have even and odd as<br>
def even : ℤ → Prop := λ n, ∃ m : ℤ, 2*m = n<br>
def odd : ℤ → Prop := λ n, ∃ m : ℤ, 2*m + 1 = n<br>
I assume that I would first have to show that odd is equivalent to not even, then apply classical.em. However, I'm having trouble proving odd x ↔ ¬(even x)</p>

<a name="163860254"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860254" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860254">Kevin Buzzard (Apr 21 2019 at 17:28)</a>:</h4>
<p>My instinct would be to prove even n -&gt; odd (n+1) etc, and then prove by induction that every integer was odd or even.</p>

<a name="163860266"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860266" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860266">Kevin Buzzard (Apr 21 2019 at 17:28)</a>:</h4>
<p>There are induction hypotheses of the form (P 0 and (forall n, P n -&gt; P(n+1)) and (forall N, P(n)-&gt;P(n-1))) implies P(n) for all n</p>

<a name="163860279"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860279" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860279">Greg Conneen (Apr 21 2019 at 17:29)</a>:</h4>
<p>Ah, I see. That makes sense. I'm not familiar enough with induction in Lean yet, but I'll try it out</p>

<a name="163860281"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860281" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860281">Greg Conneen (Apr 21 2019 at 17:29)</a>:</h4>
<p>thank you, I'll respond again if I'm stuck on the inductive bit</p>

<a name="163860285"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860285" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860285">Kevin Buzzard (Apr 21 2019 at 17:29)</a>:</h4>
<p>If you just apply the induction tactic out of the box, you'll get an unpleasant surprise</p>

<a name="163860338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860338">Kevin Buzzard (Apr 21 2019 at 17:30)</a>:</h4>
<p>You'll end up with some question about natural numbers instead, and it will be pain converting from naturals to integers.</p>

<a name="163860351"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860351" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860351">Kevin Buzzard (Apr 21 2019 at 17:30)</a>:</h4>
<p>You'll need to find an appropriate custom induction term in the library.</p>

<a name="163860369"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860369" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860369">Greg Conneen (Apr 21 2019 at 17:31)</a>:</h4>
<p>Oh, okay. I'm not familiar enough with the library to get started with that. Where would I go to look for something like that?</p>

<a name="163860373"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860373" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860373">Kevin Buzzard (Apr 21 2019 at 17:31)</a>:</h4>
<p><code>int.induction_on</code> should be fine for you.</p>

<a name="163860436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860436">Kevin Buzzard (Apr 21 2019 at 17:33)</a>:</h4>
<p><code>import data.int.basic</code> at the top of your file (you'll need the maths library mathlib) and then apply that function, and you'll be left with goals of the form "n even or n odd -&gt; n+1 even or n+1 odd" which you should be able to cope with. Prove n even -&gt; n+1 odd and the other three results (e.g. n odd -&gt; n-1 even) first and then use them all to prove the result.</p>

<a name="163860497"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860497" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860497">Greg Conneen (Apr 21 2019 at 17:34)</a>:</h4>
<p>Neat. I have mathlib, but I find most of the algebra/analysis files unreadable despite being highly competent with the material on paper. Are there any other packages you would recommend before diving into that level of material?</p>

<a name="163860556"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860556" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860556">Kevin Buzzard (Apr 21 2019 at 17:36)</a>:</h4>
<p>I would recommend doing just what you're doing -- writing material yourself. I agree that the library is impenetrable for a beginner. Proofs are specifically shortened for efficiency reasons, they are not written to be readable. We are still lacking a bunch of good teaching material for mathematicians; I intend to make some this summer, however I also said that last summer.</p>

<a name="163860618"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860618" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860618">Kevin Buzzard (Apr 21 2019 at 17:38)</a>:</h4>
<p>Here's me trying to do some problem sheets which we give to 1st year mathematicians at Imperial: <a href="https://github.com/ImperialCollegeLondon/M1F_example_sheets" target="_blank" title="https://github.com/ImperialCollegeLondon/M1F_example_sheets">https://github.com/ImperialCollegeLondon/M1F_example_sheets</a></p>

<a name="163860637"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860637" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860637">Greg Conneen (Apr 21 2019 at 17:39)</a>:</h4>
<p>Oh wow, that's a substantial amount of material. Thank you so much!</p>

<a name="163860684"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860684" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860684">Kevin Buzzard (Apr 21 2019 at 17:40)</a>:</h4>
<p>The proofs are written in a far more longwinded way, they might be more instructional but there are still not many comments.</p>

<a name="163860685"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860685" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860685">Kevin Buzzard (Apr 21 2019 at 17:40)</a>:</h4>
<p>You can step through them in tactic mode and watch the state change, of course.</p>

<a name="163860739"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860739" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860739">Greg Conneen (Apr 21 2019 at 17:42)</a>:</h4>
<p>Right, I think that as long as I can just run through the tactic state I should be fine. Are there solutions for every single exercise?</p>

<a name="163860801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860801">Greg Conneen (Apr 21 2019 at 17:44)</a>:</h4>
<p>Also, despite there being a real numbers package in mathlib, I've never seen it before. That's super useful!</p>

<a name="163860817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860817">Greg Conneen (Apr 21 2019 at 17:45)</a>:</h4>
<p>oh wow, there's also complex numbers defined. That's amazing</p>

<a name="163860818"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860818" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860818">Kevin Buzzard (Apr 21 2019 at 17:45)</a>:</h4>
<p>I don't think I managed every single exercise. There were some which were hard to formalise.</p>

<a name="163860865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860865">Kevin Buzzard (Apr 21 2019 at 17:46)</a>:</h4>
<p>Those answers are really just a big work in progress. They were just me trying to figure out if Lean was ready for a beginning undergraduate level maths course. It was.</p>

<a name="163860866"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860866" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860866">Greg Conneen (Apr 21 2019 at 17:46)</a>:</h4>
<p>Are you a professor at Imperial?</p>

<a name="163860867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860867">Kevin Buzzard (Apr 21 2019 at 17:46)</a>:</h4>
<p>Yes</p>

<a name="163860881"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860881" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860881">Greg Conneen (Apr 21 2019 at 17:47)</a>:</h4>
<p>Oh, that's awesome. I'm just an undergrad math student</p>

<a name="163860882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860882">Kevin Buzzard (Apr 21 2019 at 17:48)</a>:</h4>
<p>I felt like that when I was trying to get Lean to do my own problem sheets.</p>

<a name="163860993"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163860993" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163860993">Greg Conneen (Apr 21 2019 at 17:50)</a>:</h4>
<p>Haha yeah, the professor here at UVA has a tough time teaching Lean. It seems like it's one of those things where many trivial proofs on paper are just very difficult to formalise, despite familiarity</p>

<a name="163861008"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861008" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861008">Kevin Buzzard (Apr 21 2019 at 17:51)</a>:</h4>
<p>Yes. I spent about a year being very frustrated with not being able to make Lean do obvious things. I'm now finally over that initial learning hump and I can write even research level maths in Lean now, although it can take a long time.</p>

<a name="163861071"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861071" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861071">Greg Conneen (Apr 21 2019 at 17:53)</a>:</h4>
<p>Well congrats. I hope to get to that point someday. What maths research have you been able to formalise in Lean?</p>

<a name="163861075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861075">Kevin Buzzard (Apr 21 2019 at 17:53)</a>:</h4>
<p><a href="https://github.com/leanprover-community/lean-perfectoid-spaces" target="_blank" title="https://github.com/leanprover-community/lean-perfectoid-spaces">https://github.com/leanprover-community/lean-perfectoid-spaces</a></p>

<a name="163861076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861076">Kevin Buzzard (Apr 21 2019 at 17:53)</a>:</h4>
<p>It's not finished yet but we're getting there.</p>

<a name="163861121"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861121" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861121">Kevin Buzzard (Apr 21 2019 at 17:54)</a>:</h4>
<p>I've just spent the last 30 minutes staring at <a href="#narrow/stream/116395-maths/topic/Cute.20lemma/near/163135381" title="#narrow/stream/116395-maths/topic/Cute.20lemma/near/163135381">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Cute.20lemma/near/163135381</a></p>

<a name="163861130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861130">Kevin Buzzard (Apr 21 2019 at 17:54)</a>:</h4>
<p>some technical lemma about topological spaces which we need.</p>

<a name="163861147"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861147" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861147">Greg Conneen (Apr 21 2019 at 17:55)</a>:</h4>
<p>that's... absolutely amazing. I never imagined we could do something like this in Lean so soon.</p>

<a name="163861149"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861149" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861149">Kevin Buzzard (Apr 21 2019 at 17:55)</a>:</h4>
<p>Yeah me neither</p>

<a name="163861150"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861150" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861150">Kevin Buzzard (Apr 21 2019 at 17:55)</a>:</h4>
<p>I've had a huge amount of support from other people here</p>

<a name="163861156"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861156" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861156">Kevin Buzzard (Apr 21 2019 at 17:56)</a>:</h4>
<p>18 months ago there weren't even complex numbers</p>

<a name="163861201"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861201" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861201">Kevin Buzzard (Apr 21 2019 at 17:56)</a>:</h4>
<p>Now we have schemes <a href="https://github.com/ramonfmir/lean-scheme" target="_blank" title="https://github.com/ramonfmir/lean-scheme">https://github.com/ramonfmir/lean-scheme</a> and they work</p>

<a name="163861203"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861203" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861203">Greg Conneen (Apr 21 2019 at 17:56)</a>:</h4>
<p>Wow. Yeah, I'm now very happy that I've been introduced to this chat by Dr. Hölzl</p>

<a name="163861205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861205">Greg Conneen (Apr 21 2019 at 17:56)</a>:</h4>
<p>Oh wow, algebraic geometry? I'll have to tell my advisor about this</p>

<a name="163861218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861218">Kevin Buzzard (Apr 21 2019 at 17:57)</a>:</h4>
<p>we have stuff which reflects the interests of the people involved, I guess.</p>

<a name="163861264"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861264" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861264">Greg Conneen (Apr 21 2019 at 17:58)</a>:</h4>
<p>Thank you so much for all this info. I really appreciate it. I look forward to participating more in the future, when I get a little bit more acquainted with Lean.</p>

<a name="163861269"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861269" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861269">Kevin Buzzard (Apr 21 2019 at 17:58)</a>:</h4>
<p><a href="#narrow/stream/116395-maths/topic/Taking.20the.20Stacks.20Project.20formalisation.20forward" title="#narrow/stream/116395-maths/topic/Taking.20the.20Stacks.20Project.20formalisation.20forward">https://leanprover.zulipchat.com/#narrow/stream/116395-maths/topic/Taking.20the.20Stacks.20Project.20formalisation.20forward</a></p>

<a name="163861270"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861270" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861270">Kevin Buzzard (Apr 21 2019 at 17:58)</a>:</h4>
<p>That's the schemes thread</p>

<a name="163861273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861273">Kevin Buzzard (Apr 21 2019 at 17:58)</a>:</h4>
<p>we're going to re-write it using the category theory library; at the minute we make all the categories by hand.</p>

<a name="163861283"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861283" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861283">Kevin Buzzard (Apr 21 2019 at 17:59)</a>:</h4>
<p>There are universe issues, as ever in category theory, so it gets a bit hairy because you have to do it all properly in a system like this</p>

<a name="163861354"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861354" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861354">Greg Conneen (Apr 21 2019 at 18:00)</a>:</h4>
<p>That makes sense. Cat theory makes for the introduction of some interesting nuances</p>

<a name="163861817"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163861817" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163861817">Greg Conneen (Apr 21 2019 at 18:14)</a>:</h4>
<p>How do I apply one direction of an iff? Like, if I wanted to only apply the left implication in a proof.</p>

<a name="163862508"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163862508" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163862508">Mario Carneiro (Apr 21 2019 at 18:36)</a>:</h4>
<p><code>bla.1</code> or <code>bla.mp</code></p>

<a name="163862512"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163862512" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163862512">Mario Carneiro (Apr 21 2019 at 18:36)</a>:</h4>
<p>which is short for <code>iff.mp bla</code></p>

<a name="163862527"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163862527" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163862527">Greg Conneen (Apr 21 2019 at 18:37)</a>:</h4>
<p>oh okay, so if my iff statement was titled bla, bla.1 would be the left implication, and bla.2 would be the right?</p>

<a name="163862878"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163862878" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163862878">Greg Conneen (Apr 21 2019 at 18:48)</a>:</h4>
<p>Also, where can I find the xenalib package?</p>

<a name="163862942"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163862942" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163862942">Greg Conneen (Apr 21 2019 at 18:50)</a>:</h4>
<p>nvm, found it</p>

<a name="163902237"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163902237" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163902237">Greg Conneen (Apr 22 2019 at 13:02)</a>:</h4>
<p>Okay, I've got a Lean file I've tinkered around with in the past, which includes some simple proofs about integers. Some propositions I've failed to prove in Lean, and the rest I'm sure are anything but efficient. I was wondering if anyone would be willing to look over this file for me and give me some pointers on how to improve my proving techniques. <a href="/user_uploads/3121/oDrGTH44Zfg48XIg3ZaoHSYE/int_props.lean" target="_blank" title="int_props.lean">int_props.lean</a></p>

<a name="163902261"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163902261" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163902261">Greg Conneen (Apr 22 2019 at 13:03)</a>:</h4>
<p>It's sort of a long file, and not very organised, but any help at all would be really appreciated. Sorry in advance.</p>

<a name="163965002"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163965002" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163965002">Greg Conneen (Apr 23 2019 at 06:12)</a>:</h4>
<p>I'm having trouble defining structure fields. The generic construction of structures is fine, I just don't understand fields. How would I go about appending them to a given structure?</p>

<a name="163965231"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163965231" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163965231">Johan Commelin (Apr 23 2019 at 06:16)</a>:</h4>
<p>Do you mean extending a structure?</p>

<a name="163965232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163965232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163965232">Johan Commelin (Apr 23 2019 at 06:16)</a>:</h4>
<p>Search for "extend" in mathlib and you will find lots of examples</p>

<a name="163966248"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163966248" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163966248">Greg Conneen (Apr 23 2019 at 06:41)</a>:</h4>
<p>oh, cool. Thank you. I didn't even know what I was looking for until you showed me</p>

<a name="163967041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163967041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163967041">Kevin Buzzard (Apr 23 2019 at 06:58)</a>:</h4>
<p>You might want to read the chapters on inductive types and structures in TPIL.</p>

<a name="163968134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163968134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163968134">Patrick Massot (Apr 23 2019 at 07:22)</a>:</h4>
<p><span class="user-mention" data-user-id="218940">@Greg Conneen</span> what Kevin really means is: if you have any interest in learning Lean, you want to read all of TPIL. The modern way of doing that is to launch VScode, open any Lean file, type Ctrl-shift-p type lean, select "Open documentation view", click "Theorem proving in Lean". This way you can click "Try it!" links on code snippets to open them right in VScode and play with them.</p>

<a name="163968575"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163968575" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163968575">Patrick Massot (Apr 23 2019 at 07:32)</a>:</h4>
<p>Trying to figure out the community map: Greg, are you a student of the Kevin Sullivan?</p>

<a name="163985682"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163985682" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163985682">Greg Conneen (Apr 23 2019 at 12:47)</a>:</h4>
<p>I was Prof. Sullivan's student last year, yes.</p>

<a name="163985995"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163985995" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163985995">Greg Conneen (Apr 23 2019 at 12:49)</a>:</h4>
<p>I've read the entirety of TPIL. I'm just still having trouble with implementation. I guess I'll tinker around with it a bit more</p>

<a name="163988098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988098">Greg Conneen (Apr 23 2019 at 13:09)</a>:</h4>
<p>Okay, so if a group is defined like this</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="n">group</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span> <span class="bp">→</span> <span class="kt">Type</span> <span class="n">u</span>
<span class="n">fields</span><span class="o">:</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul_assoc</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c_1</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span> <span class="bp">=</span> <span class="n">a</span> <span class="bp">*</span> <span class="o">(</span><span class="n">b</span> <span class="bp">*</span> <span class="n">c_1</span><span class="o">)</span>
<span class="n">group</span><span class="bp">.</span><span class="n">one</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span>
<span class="n">group</span><span class="bp">.</span><span class="n">one_mul</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="mi">1</span> <span class="bp">*</span> <span class="n">a</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul_one</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span> <span class="bp">*</span> <span class="mi">1</span> <span class="bp">=</span> <span class="n">a</span>
<span class="n">group</span><span class="bp">.</span><span class="n">inv</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span>
<span class="n">group</span><span class="bp">.</span><span class="n">mul_left_inv</span> <span class="o">:</span> <span class="bp">∀</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="n">α</span><span class="o">),</span> <span class="n">a</span><span class="bp">⁻¹</span> <span class="bp">*</span> <span class="n">a</span>
</pre></div>


<p>the way I would make something like this would be</p>
<div class="codehilite"><pre><span></span><span class="kn">structure</span> <span class="o">{</span><span class="n">u</span><span class="o">}</span> <span class="n">fake_group</span> <span class="o">(</span><span class="n">a</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">mul</span> <span class="o">:</span> <span class="bp">Π</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">c</span> <span class="o">:</span> <span class="n">group</span> <span class="n">α</span><span class="o">],</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">...</span>
</pre></div>


<p>except, I want to change group α to fake_group α and I don't understand how to do that. I also in general don't understand the bracket notation or what pi does.</p>

<a name="163988588"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988588" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988588">Johan Commelin (Apr 23 2019 at 13:14)</a>:</h4>
<p>Note, you can use</p>
<div class="codehilite"><pre><span></span>```lean
foobar
```
</pre></div>


<p>to get code blocks with syntax highlighting</p>

<a name="163988616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988616">Greg Conneen (Apr 23 2019 at 13:15)</a>:</h4>
<p>oh okay, thanks</p>

<a name="163988667"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988667" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988667">Johan Commelin (Apr 23 2019 at 13:16)</a>:</h4>
<p>Note that a group is not defined the way you did. (Internally that is what Lean sees, maybe. But it isn't how it's written in the Lean source files.)</p>

<a name="163988729"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988729" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988729">Johan Commelin (Apr 23 2019 at 13:16)</a>:</h4>
<p>Tip: write <code>#print group</code> in VScode, and <code>Ctrl</code>-click on <code>group</code>.</p>

<a name="163988749"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988749" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988749">Johan Commelin (Apr 23 2019 at 13:16)</a>:</h4>
<p>Or put your cursor on <code>group</code> and hit <code>Ctrl - Shift - F10</code></p>

<a name="163988801"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988801" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988801">Greg Conneen (Apr 23 2019 at 13:17)</a>:</h4>
<p>ohhhh I see. So a group is simply an extension of a monoid, which I assume is an extension of a semigroup.</p>

<a name="163988875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163988875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163988875">Greg Conneen (Apr 23 2019 at 13:18)</a>:</h4>
<p>...which it is, 4 lines above. Thank you so much.</p>

<a name="163989273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989273">Greg Conneen (Apr 23 2019 at 13:22)</a>:</h4>
<p>So, in general, classes are used in the backend, but Lean interprets them as structures. What's the difference?</p>

<a name="163989367"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989367" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989367">Greg Conneen (Apr 23 2019 at 13:23)</a>:</h4>
<p>Also, is there any way to formalise has_mul and has_one without extending those classes?</p>

<a name="163989436"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989436" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989436">Johan Commelin (Apr 23 2019 at 13:24)</a>:</h4>
<p>No the difference between classes and structures is type class inference</p>

<a name="163989470"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989470" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989470">Johan Commelin (Apr 23 2019 at 13:24)</a>:</h4>
<blockquote>
<p>Also, is there any way to formalise has_mul and has_one without extending those classes?</p>
</blockquote>
<p>Just copy paste their definitions.</p>

<a name="163989477"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989477" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989477">Greg Conneen (Apr 23 2019 at 13:24)</a>:</h4>
<p>I don't know what you mean by that</p>

<a name="163989478"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989478" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989478">Johan Commelin (Apr 23 2019 at 13:24)</a>:</h4>
<p>The word <code>class</code> is a red herring in this discussion</p>

<a name="163989495"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989495" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989495">Johan Commelin (Apr 23 2019 at 13:24)</a>:</h4>
<p>You could write <code>structure</code> everywhere</p>

<a name="163989589"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989589" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989589">Greg Conneen (Apr 23 2019 at 13:25)</a>:</h4>
<p>gotcha. So the only difference is that structures are't able to inherit the properties of other structures. So when would you use a structure over a class?</p>

<a name="163989676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989676">Johan Commelin (Apr 23 2019 at 13:26)</a>:</h4>
<p>No, structures can inherit</p>

<a name="163989696"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989696" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989696">Johan Commelin (Apr 23 2019 at 13:26)</a>:</h4>
<p>The difference is "type class instance". Search for that in TPIL.</p>

<a name="163989699"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989699" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989699">Greg Conneen (Apr 23 2019 at 13:26)</a>:</h4>
<p>oh. Then what do you mean by "type class inference?"</p>

<a name="163989710"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989710" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989710">Greg Conneen (Apr 23 2019 at 13:27)</a>:</h4>
<p>oh okay, gotcha</p>

<a name="163989725"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989725" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989725">Greg Conneen (Apr 23 2019 at 13:27)</a>:</h4>
<p>must've skimmed over that section</p>

<a name="163989731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989731">Johan Commelin (Apr 23 2019 at 13:27)</a>:</h4>
<p>inference, not inheritance <span aria-label="wink" class="emoji emoji-1f609" role="img" title="wink">:wink:</span></p>

<a name="163989753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989753">Johan Commelin (Apr 23 2019 at 13:27)</a>:</h4>
<p>/me never read TPIL in detail. I'm a cargo cult Leaner.</p>

<a name="163989760"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989760" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989760">Kevin Buzzard (Apr 23 2019 at 13:27)</a>:</h4>
<p>The difference between a structure and a class is that classes are structures with extra magical sauce.</p>

<a name="163989767"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989767" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989767">Greg Conneen (Apr 23 2019 at 13:27)</a>:</h4>
<p>Ah, that's my confusion. Thank you for being patient with me</p>

<a name="163989772"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989772" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989772">Kevin Buzzard (Apr 23 2019 at 13:27)</a>:</h4>
<p>I was trying to write some advanced notes on type class inference</p>

<a name="163989828"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989828" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989828">Kevin Buzzard (Apr 23 2019 at 13:28)</a>:</h4>
<p>but before I wrote them I wrote some basic notes on type class inference for mathematicians</p>

<a name="163989843"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989843" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989843">Kevin Buzzard (Apr 23 2019 at 13:28)</a>:</h4>
<p>These might help. They present the same material as in TPIL but in a way far more suited to mathematicians.</p>

<a name="163989867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163989867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163989867">Kevin Buzzard (Apr 23 2019 at 13:28)</a>:</h4>
<p>They're in a branch of mathlib, hang on, I'll dig it out. I'm actually on an aeroplane at this point</p>

<a name="163990167"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163990167" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163990167">Kevin Buzzard (Apr 23 2019 at 13:32)</a>:</h4>
<p><a href="https://github.com/leanprover-community/mathlib/blob/kbuzzard_typeclass_inference_doc/docs/extras/typeclass_inference.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/kbuzzard_typeclass_inference_doc/docs/extras/typeclass_inference.md">https://github.com/leanprover-community/mathlib/blob/kbuzzard_typeclass_inference_doc/docs/extras/typeclass_inference.md</a></p>

<a name="163990228"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163990228" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163990228">Kevin Buzzard (Apr 23 2019 at 13:33)</a>:</h4>
<p>I found typeclass inference really hard to learn. It was only when I began to try to do normal maths in Lean that I began to see the point of it and understand it properly.</p>

<a name="163990426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163990426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163990426">Kevin Buzzard (Apr 23 2019 at 13:36)</a>:</h4>
<p>For reasons that you don't need to worry about and which might change, Lean keeps a ring in two packages not one. The first is a type called something like R. The second is a whole bunch of data which might be called something like <code>_inst_1 : ring R</code> and which you should never need to look at, but it's here that all the multiplication and the addition and the zero and the axioms are all stored. You will probably not need to dig out the axioms, you should just be applying lemmas, if you're doing mathematics -- but sometimes it's important to know where Lean magics up e.g. the proof of the distributivity law for the integers, and if you want to know this then you need to know about typeclass inference.</p>

<a name="163993041"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993041" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993041">Greg Conneen (Apr 23 2019 at 14:10)</a>:</h4>
<p>What if I wanted to talk about a ternary operator instead of a binary one (I want to define an algebraic heap)? I can't use has_mul, since it's strictly binary...</p>

<a name="163993235"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993235" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993235">Andrew Ashworth (Apr 23 2019 at 14:12)</a>:</h4>
<p>yup</p>

<a name="163993287"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993287" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993287">Andrew Ashworth (Apr 23 2019 at 14:13)</a>:</h4>
<p>what exactly is your question about ternary operators?</p>

<a name="163993708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993708">Greg Conneen (Apr 23 2019 at 14:17)</a>:</h4>
<p>I want to define a class, let's start with semiheap. I only need it to have the following property, called para-associativity:</p>
<div class="codehilite"><pre><span></span><span class="k">forall</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">alpha</span><span class="o">,</span> <span class="o">[[</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">]</span> <span class="n">d</span> <span class="n">e</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span> <span class="o">[</span><span class="n">d</span> <span class="n">c</span> <span class="n">b</span><span class="o">]</span> <span class="n">e</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span> <span class="n">b</span> <span class="o">[</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">]]</span>
</pre></div>


<p>where [a b c] is a ternary operator. Although, If I have to use different notation given Lean's use of square brackets, that's fine</p>

<a name="163993810"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993810" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993810">Greg Conneen (Apr 23 2019 at 14:19)</a>:</h4>
<p>I assume I have to define some sort of infix for a ternary operator, but I don't know how to implement that</p>

<a name="163993844"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993844" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993844">Johan Commelin (Apr 23 2019 at 14:19)</a>:</h4>
<p>Does the operator have a "canonical" name in the literature?</p>

<a name="163993867"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993867" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993867">Andrew Ashworth (Apr 23 2019 at 14:19)</a>:</h4>
<p>section 10.3 in TPIL describes notation</p>

<a name="163993868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993868">Johan Commelin (Apr 23 2019 at 14:19)</a>:</h4>
<p>You will first want to define it without the ternary notation.</p>

<a name="163993885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163993885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163993885">Johan Commelin (Apr 23 2019 at 14:19)</a>:</h4>
<p>Afterward, you can define the notation, and start using it.</p>

<a name="163994014"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994014" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994014">Greg Conneen (Apr 23 2019 at 14:20)</a>:</h4>
<p>Okay. I assume that I need to give it an operation on 3 elements, then state the rule</p>

<a name="163994076"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994076" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994076">Greg Conneen (Apr 23 2019 at 14:21)</a>:</h4>
<p>And no, unfortunately there's not really a canonical name for the operator. It's just a ternary operation, in the same way that the standard operation a group deals with is just a binary one</p>

<a name="163994086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994086">Johan Commelin (Apr 23 2019 at 14:22)</a>:</h4>
<p>Yup. So you want fields</p>
<div class="codehilite"><pre><span></span><span class="o">(</span><span class="n">tern_op</span> <span class="o">:</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span> <span class="bp">→</span> <span class="n">X</span><span class="o">)</span>
<span class="o">(</span><span class="n">semi_assoc</span> <span class="o">:</span> <span class="err">\</span><span class="n">for</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">,</span> <span class="n">blabla</span><span class="o">)</span>
</pre></div>

<a name="163994154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994154">Johan Commelin (Apr 23 2019 at 14:22)</a>:</h4>
<blockquote>
<p>And no, unfortunately there's not really a canonical name for the operator. It's just a ternary operation, in the same way that the standard operation a group deals with is just a binary one</p>
</blockquote>
<p>We "canonically" call it <em>multiplication</em>.</p>

<a name="163994218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994218">Greg Conneen (Apr 23 2019 at 14:23)</a>:</h4>
<p>Ah, I see. That makes sense. Although, most mathematicians I know don't like to be so restrictive in terminology :P</p>

<a name="163994232"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994232" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994232">Johan Commelin (Apr 23 2019 at 14:23)</a>:</h4>
<p>I was just wondering whether there was a good alternative to <code>tern_op</code>.</p>

<a name="163994355"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994355" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994355">Greg Conneen (Apr 23 2019 at 14:24)</a>:</h4>
<p>Yeah, I figured that's what you were after. Heaps aren't really a common algebraic structure, I'm really just trying to implement this so I have a better understanding of how Lean deals with structures/classes</p>

<a name="163994731"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994731" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994731">Greg Conneen (Apr 23 2019 at 14:29)</a>:</h4>
<p>Also, am I able to say that 3 things are equal in one field without using "and"?</p>

<a name="163994748"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994748" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994748">Greg Conneen (Apr 23 2019 at 14:29)</a>:</h4>
<p>like how I wrote above</p>

<a name="163994885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163994885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163994885">Patrick Massot (Apr 23 2019 at 14:31)</a>:</h4>
<p>there are stupid indirect ways to say it, but using <code>and</code> is the reasonable one</p>

<a name="163995024"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995024" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995024">Greg Conneen (Apr 23 2019 at 14:32)</a>:</h4>
<p>Okay. Unfortunate, but I guess it's better than defining two separate fields</p>

<a name="163995099"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995099" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995099">Patrick Massot (Apr 23 2019 at 14:33)</a>:</h4>
<p>If you really want to you can build an API around this</p>

<a name="163995181"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995181" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995181">Greg Conneen (Apr 23 2019 at 14:34)</a>:</h4>
<p>No thank you lol</p>

<a name="163995227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995227">Patrick Massot (Apr 23 2019 at 14:34)</a>:</h4>
<p>You will need lemmas about heaps saying that anyway</p>

<a name="163995273"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995273" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995273">Patrick Massot (Apr 23 2019 at 14:35)</a>:</h4>
<p>Whatever is inside your field, you'll want a lemma asserting the three relevant equalities</p>

<a name="163995312"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995312" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995312">Greg Conneen (Apr 23 2019 at 14:35)</a>:</h4>
<p>I don't know what you mean</p>

<a name="163995379"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995379" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995379">Greg Conneen (Apr 23 2019 at 14:36)</a>:</h4>
<p>Why would I need a lemma? Are you talking about showing that some object is a heap?</p>

<a name="163995408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995408">Greg Conneen (Apr 23 2019 at 14:36)</a>:</h4>
<p>I'd expect that just implementing the classes wouldn't require lemmas</p>

<a name="163995431"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995431" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995431">Johan Commelin (Apr 23 2019 at 14:36)</a>:</h4>
<p>No, he is talking about making it usable</p>

<a name="163995485"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995485" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995485">Greg Conneen (Apr 23 2019 at 14:37)</a>:</h4>
<p>Oh, okay. So I can't refer to the fields until I define lemmas for them?</p>

<a name="163995586"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995586" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995586">Patrick Massot (Apr 23 2019 at 14:39)</a>:</h4>
<p>You will have:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">heap</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">:=</span>
<span class="bp">...</span>

<span class="kn">namespace</span> <span class="n">heap</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">X</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">heap</span> <span class="n">X</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">X</span><span class="o">)</span>
<span class="kn">lemma</span> <span class="n">assoc1</span>  <span class="o">:</span> <span class="o">[[</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">]</span> <span class="n">d</span> <span class="n">e</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span> <span class="o">[</span><span class="n">d</span> <span class="n">c</span> <span class="n">b</span><span class="o">]</span> <span class="n">e</span><span class="o">]</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">lemma</span> <span class="n">assoc2</span>  <span class="o">:</span> <span class="o">[</span><span class="n">a</span> <span class="o">[</span><span class="n">d</span> <span class="n">c</span> <span class="n">b</span><span class="o">]</span> <span class="n">e</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span> <span class="n">b</span> <span class="o">[</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">]]</span> <span class="o">:=</span> <span class="n">sorry</span>

<span class="kn">lemma</span> <span class="n">assoc3</span>  <span class="o">:</span> <span class="o">[[</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">]</span> <span class="n">d</span> <span class="n">e</span><span class="o">]</span> <span class="bp">=</span> <span class="o">[</span><span class="n">a</span> <span class="n">b</span> <span class="o">[</span><span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">]]</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">end</span> <span class="n">heap</span>
</pre></div>

<a name="163995601"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995601" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995601">Chris Hughes (Apr 23 2019 at 14:39)</a>:</h4>
<p>I would have three fields rather than an <code>and</code></p>

<a name="163995610"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995610" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995610">Johan Commelin (Apr 23 2019 at 14:39)</a>:</h4>
<p>You can refer to them, otherwise you can't state the lemmas. What Patrick is saying is that with only the fields you'll have something that is cumbersome to use.</p>

<a name="163995614"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995614" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995614">Greg Conneen (Apr 23 2019 at 14:39)</a>:</h4>
<p>yeah I'm putting it into 3 fields. I've realised that's easier</p>

<a name="163995629"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995629" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995629">Patrick Massot (Apr 23 2019 at 14:39)</a>:</h4>
<p>The point is: whatever the implementaion chosen, after writing  those three lemmas, you will have your three equalities</p>

<a name="163995708"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995708" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995708">Greg Conneen (Apr 23 2019 at 14:40)</a>:</h4>
<p>What does that change? Just being able to refer to the property without using semiheap.*?</p>

<a name="163995709"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995709" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995709">Patrick Massot (Apr 23 2019 at 14:40)</a>:</h4>
<p>Of course if you put all three lemmas as fields then you don't have to state theses lemmas to use them (unless for some reason you want to change binder types, but that's a more advanced discussion)</p>

<a name="163995722"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995722" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995722">Greg Conneen (Apr 23 2019 at 14:41)</a>:</h4>
<p>Also, is Type* a way of referring to an arbitrary Type level without defining a universe?</p>

<a name="163995769"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995769" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995769">Patrick Massot (Apr 23 2019 at 14:41)</a>:</h4>
<p>And if you use redundant fields like that you will probably want a custom constructor</p>

<a name="163995886"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995886" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995886">Greg Conneen (Apr 23 2019 at 14:43)</a>:</h4>
<p>How would a custom constructor help me?</p>

<a name="163995931"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163995931" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163995931">Greg Conneen (Apr 23 2019 at 14:43)</a>:</h4>
<p>Sorry, but I'm still very new, and I don't really see the big picture yet</p>

<a name="163996078"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163996078" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163996078">Patrick Massot (Apr 23 2019 at 14:45)</a>:</h4>
<p>I think the discussion would be much easier if you write something and then we comment it</p>

<a name="163996098"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163996098" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163996098">Patrick Massot (Apr 23 2019 at 14:45)</a>:</h4>
<p>Abstract discussion won't help</p>

<a name="163996115"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163996115" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163996115">Greg Conneen (Apr 23 2019 at 14:45)</a>:</h4>
<p>Yeah I agree. I'll post in just a second</p>

<a name="163997611"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163997611" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163997611">Greg Conneen (Apr 23 2019 at 15:00)</a>:</h4>
<p>This is what I've got so far:</p>
<div class="codehilite"><pre><span></span><span class="n">class</span> <span class="n">semiheap</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">)</span> <span class="o">:=</span>
<span class="o">(</span><span class="n">tern_op</span> <span class="o">:</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="bp">→</span> <span class="n">α</span> <span class="o">)</span>
<span class="o">(</span><span class="n">para_assoc1</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
    <span class="n">tern_op</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="n">d</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">tern_op</span> <span class="n">a</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">d</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="n">e</span><span class="o">)</span>
<span class="o">(</span><span class="n">para_assoc2</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
    <span class="n">tern_op</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">)</span> <span class="n">d</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">tern_op</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">))</span>
<span class="o">(</span><span class="n">para_assoc3</span> <span class="o">:</span> <span class="bp">∀</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span>
    <span class="n">tern_op</span> <span class="n">a</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">d</span> <span class="n">c</span> <span class="n">b</span><span class="o">)</span> <span class="n">e</span> <span class="bp">=</span> <span class="n">tern_op</span> <span class="n">a</span> <span class="n">b</span> <span class="o">(</span><span class="n">tern_op</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span><span class="o">))</span>


<span class="kn">namespace</span> <span class="n">semiheap</span>
<span class="kn">notation</span> <span class="bp">`</span><span class="o">[</span><span class="bp">`</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">_</span> <span class="bp">`</span><span class="o">]</span><span class="bp">`</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">tern_op</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span><span class="bp">*</span><span class="o">}</span> <span class="o">[</span><span class="n">semiheap</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>

<span class="kn">lemma</span> <span class="n">para_assoc1</span> <span class="o">:</span> <span class="n">sorry</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">lemma</span> <span class="n">para_assoc2</span> <span class="o">:</span> <span class="n">sorry</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">lemma</span> <span class="n">para_assoc3</span> <span class="o">:</span> <span class="n">sorry</span> <span class="o">:=</span> <span class="n">sorry</span>
<span class="kn">end</span> <span class="n">semiheap</span>
</pre></div>


<p>The semiheap as defined is fine. I'm just having trouble with the notation, since it throws an error saying I'm referencing local variables if I put it below them, and I don't know how to reference the semiheap alpha if I put it above.</p>

<a name="163998753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163998753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163998753">Patrick Massot (Apr 23 2019 at 15:12)</a>:</h4>
<p>I don't think you can use space as a delimiter in this notation. You can play with</p>
<div class="codehilite"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="n">semiheap</span><span class="w"> </span><span class="p">(</span><span class="err">α</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nc">Type</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="p">(</span><span class="n">tern_op</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">notation</span><span class="w"> </span><span class="n">`</span><span class="p">[</span><span class="n">`</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">`</span><span class="o">|</span><span class="n">`</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">`</span><span class="o">|</span><span class="n">`</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">`</span><span class="p">]</span><span class="n">`</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">tern_op</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">para_assoc1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="p">,</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">])</span><span class="w"></span>
<span class="p">(</span><span class="n">para_assoc2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">]])</span><span class="w"></span>
<span class="p">(</span><span class="n">para_assoc3</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="p">,</span><span class="w"> </span><span class="p">[[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="p">]</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">[</span><span class="n">c</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">e</span><span class="p">]])</span><span class="w"></span>


<span class="n">def</span><span class="w"> </span><span class="n">semiheap</span><span class="o">.</span><span class="n">mk</span><span class="err">&#39;</span><span class="w"> </span><span class="p">{</span><span class="err">α</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="nc">Type</span><span class="o">*</span><span class="p">}</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="o">:</span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">α</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">h1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">op</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"></span>
<span class="p">(</span><span class="n">h2</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="err">α</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">op</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="p">))</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">semiheap</span><span class="w"> </span><span class="err">α</span><span class="w"> </span><span class="o">:=</span><span class="w"></span>
<span class="p">{</span><span class="w"> </span><span class="n">tern_op</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">para_assoc1</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h1</span><span class="p">,</span><span class="w"></span>
<span class="w">  </span><span class="n">para_assoc2</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="err">λ</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">h1</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="err">▸</span><span class="w"> </span><span class="p">(</span><span class="n">h2</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="n">e</span><span class="p">),</span><span class="w"></span>
<span class="w">  </span><span class="n">para_assoc3</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">h2</span><span class="p">}</span><span class="w"></span>
</pre></div>

<a name="163998816"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163998816" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163998816">Patrick Massot (Apr 23 2019 at 15:13)</a>:</h4>
<p>The function is the custom constructor, it lets you build a structure by providing only two equalities</p>

<a name="163999075"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163999075" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163999075">Greg Conneen (Apr 23 2019 at 15:16)</a>:</h4>
<p>Why have we defined .mk'? What does it do? Also, what is ▸?</p>

<a name="163999113"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163999113" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163999113">Patrick Massot (Apr 23 2019 at 15:17)</a>:</h4>
<p>Please first try to define an instance of <code>semiheap</code></p>

<a name="163999124"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163999124" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163999124">Greg Conneen (Apr 23 2019 at 15:17)</a>:</h4>
<p>It clearly rewrote, but what does it do in general?</p>

<a name="163999130"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/163999130" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#163999130">Greg Conneen (Apr 23 2019 at 15:17)</a>:</h4>
<p>Okay, I will</p>

<a name="164003046"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003046" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003046">Greg Conneen (Apr 23 2019 at 16:01)</a>:</h4>
<p>I've got it.</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">tern_add</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="bp">+</span><span class="n">b</span><span class="bp">+</span><span class="n">c</span>
<span class="kn">instance</span> <span class="n">int_semiheap</span> <span class="o">:</span> <span class="n">semiheap</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">apply</span> <span class="n">semiheap</span><span class="bp">.</span><span class="n">mk&#39;</span> <span class="n">tern_add</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">tern_add</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="n">rw</span> <span class="n">tern_add</span><span class="o">,</span>
<span class="n">simp</span><span class="o">,</span>
<span class="kn">end</span>
</pre></div>

<a name="164003070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003070">Greg Conneen (Apr 23 2019 at 16:01)</a>:</h4>
<p>Thank you so much for your help.</p>

<a name="164003572"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003572" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003572">Patrick Massot (Apr 23 2019 at 16:06)</a>:</h4>
<p>Does that code compile?</p>

<a name="164003623"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003623" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003623">Patrick Massot (Apr 23 2019 at 16:07)</a>:</h4>
<p>Anyway, the point is you had to prove only para-associativity equalities instead of three</p>

<a name="164003676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003676">Patrick Massot (Apr 23 2019 at 16:07)</a>:</h4>
<p>You can also study (after adding <code>import tactic.abel</code> on top of your file):</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">tern_add</span> <span class="o">:</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="bp">→</span> <span class="bp">ℤ</span> <span class="o">:=</span> <span class="bp">λ</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="o">,</span> <span class="n">a</span><span class="bp">+</span><span class="n">b</span><span class="bp">+</span><span class="n">c</span>

<span class="kn">example</span> <span class="o">:</span> <span class="n">semiheap</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="o">{</span> <span class="n">tern_op</span> <span class="o">:=</span> <span class="n">tern_add</span><span class="o">,</span>
  <span class="n">para_assoc1</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">[</span><span class="n">tern_add</span><span class="o">],</span> <span class="n">abel</span> <span class="o">},</span>
  <span class="n">para_assoc2</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">[</span><span class="n">tern_add</span><span class="o">],</span> <span class="n">abel</span> <span class="o">},</span>
  <span class="n">para_assoc3</span> <span class="o">:=</span> <span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span><span class="o">[</span><span class="n">tern_add</span><span class="o">],</span> <span class="n">abel</span> <span class="o">}</span> <span class="o">}</span>


<span class="kn">example</span> <span class="o">:</span> <span class="n">semiheap</span> <span class="bp">ℤ</span> <span class="o">:=</span>
<span class="n">semiheap</span><span class="bp">.</span><span class="n">mk&#39;</span> <span class="n">tern_add</span> <span class="o">(</span><span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">tern_add</span><span class="o">],</span> <span class="n">abel</span> <span class="o">})</span> <span class="o">(</span><span class="k">by</span> <span class="o">{</span> <span class="n">intros</span><span class="o">,</span> <span class="n">dsimp</span> <span class="o">[</span><span class="n">tern_add</span><span class="o">],</span> <span class="n">abel</span> <span class="o">}</span>
</pre></div>

<a name="164003782"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003782" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003782">Patrick Massot (Apr 23 2019 at 16:08)</a>:</h4>
<p>you can also replace <code>dsimp [tern_add]</code> by <code>unfold tern_add</code></p>

<a name="164003941"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164003941" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164003941">Greg Conneen (Apr 23 2019 at 16:10)</a>:</h4>
<p>Okay, I will. I'm currently implementing heaps as an extension of semiheaps. How do I avoid having to write the notation as a field over and over?</p>

<a name="164004090"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164004090" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164004090">Patrick Massot (Apr 23 2019 at 16:12)</a>:</h4>
<p>you need to reissue the notation command after the semiheap definition. The one inside the definition has limited scope</p>

<a name="164004118"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164004118" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164004118">Greg Conneen (Apr 23 2019 at 16:12)</a>:</h4>
<p>Gotcha. So at most I'll only have to write it twice</p>

<a name="164004140"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164004140" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164004140">Patrick Massot (Apr 23 2019 at 16:13)</a>:</h4>
<p>yes</p>

<a name="164019736"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164019736" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164019736">Greg Conneen (Apr 23 2019 at 19:07)</a>:</h4>
<p>Is the symmetric group defined anywhere in mathlib? If not, I'd like to go about implementing it, and in doing so would need some guidance</p>

<a name="164019868"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164019868" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164019868">Johan Commelin (Apr 23 2019 at 19:08)</a>:</h4>
<p>It is:</p>
<div class="codehilite"><pre><span></span><span class="n">src</span><span class="bp">/</span><span class="n">data</span><span class="bp">/</span><span class="n">equiv</span><span class="bp">/</span><span class="n">basic</span><span class="bp">.</span><span class="n">lean</span><span class="o">:</span><span class="c">/-</span><span class="cm">- `perm α` is the type of bijections from `α` to itself. -/</span>
</pre></div>

<a name="164019920"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164019920" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164019920">Greg Conneen (Apr 23 2019 at 19:09)</a>:</h4>
<p>Thank you</p>

<a name="164020042"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020042" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020042">Greg Conneen (Apr 23 2019 at 19:10)</a>:</h4>
<p>Followup question, has Cayley's theorem been proven?</p>

<a name="164020295"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020295" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020295">Johan Commelin (Apr 23 2019 at 19:13)</a>:</h4>
<p><span class="user-mention" data-user-id="110044">@Chris Hughes</span> I guess you did Cayley somewhere, right?</p>

<a name="164020371"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020371" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020371">Chris Hughes (Apr 23 2019 at 19:14)</a>:</h4>
<p>No.</p>

<a name="164020394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020394">Chris Hughes (Apr 23 2019 at 19:14)</a>:</h4>
<p>But it won't be hard.</p>

<a name="164020421"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020421" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020421">Johan Commelin (Apr 23 2019 at 19:14)</a>:</h4>
<p><span class="user-mention" data-user-id="218940">@Greg Conneen</span> It would be a very nice project to start with!</p>

<a name="164020443"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020443" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020443">Greg Conneen (Apr 23 2019 at 19:14)</a>:</h4>
<p>Okay. I assume it won't be. That sounds like a great thing to do.</p>

<a name="164020496"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020496" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020496">Greg Conneen (Apr 23 2019 at 19:15)</a>:</h4>
<p>I'm going to need help understanding data.equiv.basic though</p>

<a name="164020674"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164020674" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164020674">Greg Conneen (Apr 23 2019 at 19:17)</a>:</h4>
<p>It looks like α ≃ β means α is isomorphic to β, given the defn. perm α makes sense. I'm still not completely comfortable with set theory notation and techniques in Lean, since I was introduced almost exclusively through propositions</p>

<a name="164021104"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021104" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021104">Johan Commelin (Apr 23 2019 at 19:21)</a>:</h4>
<p><span class="user-mention" data-user-id="218940">@Greg Conneen</span> Do you have an idea how you would formalise the statement?</p>

<a name="164021263"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021263" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021263">Greg Conneen (Apr 23 2019 at 19:23)</a>:</h4>
<p>I'm looking into that now. The proof is trivial to me on paper. I should be fine in abstracting it. I'll definitely ask for help with it when I need it</p>

<a name="164021723"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021723" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021723">Patrick Massot (Apr 23 2019 at 19:28)</a>:</h4>
<blockquote>
<p>It looks like α ≃ β means α is isomorphic to β</p>
</blockquote>
<p>This is an extremely confusing notation, but you'll get used to it</p>

<a name="164021787"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021787" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021787">Patrick Massot (Apr 23 2019 at 19:29)</a>:</h4>
<p>The first piece of truth is <code>α ≃ β</code> is the type of isomorphisms from <code>α</code> to <code>β</code></p>

<a name="164021806"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021806" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021806">Patrick Massot (Apr 23 2019 at 19:29)</a>:</h4>
<p>So it's not a <code>Prop</code>, it contains data</p>

<a name="164021815"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021815" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021815">Greg Conneen (Apr 23 2019 at 19:29)</a>:</h4>
<p>oh no</p>

<a name="164021875"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021875" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021875">Greg Conneen (Apr 23 2019 at 19:30)</a>:</h4>
<p>lol that's certainly unintuitive</p>

<a name="164021956"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164021956" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164021956">Patrick Massot (Apr 23 2019 at 19:30)</a>:</h4>
<p>The next layer of confusion is that an isomorphism from <code>α</code> to <code>β</code> is not only a map from <code>α</code> to <code>β</code> which happens to be an isomorphism, it's a bundle containing such a map, the corresponding inverse map and two proofs</p>

<a name="164022067"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022067" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022067">Patrick Massot (Apr 23 2019 at 19:31)</a>:</h4>
<p>you need to read <a href="https://github.com/leanprover-community/mathlib/blob/master/src/data/equiv/basic.lean" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/src/data/equiv/basic.lean">https://github.com/leanprover-community/mathlib/blob/master/src/data/equiv/basic.lean</a></p>

<a name="164022095"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022095" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022095">Patrick Massot (Apr 23 2019 at 19:31)</a>:</h4>
<p>keeping the above explanation in mind</p>

<a name="164022151"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022151" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022151">Greg Conneen (Apr 23 2019 at 19:32)</a>:</h4>
<p>That's perfectly fine. I can understand that such a map needs more info packaged in with it. So, what's the actual prop that A is iso to B?</p>

<a name="164022152"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022152" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022152">Patrick Massot (Apr 23 2019 at 19:32)</a>:</h4>
<p>don't forget to first read back the section on coercions in TPIL</p>

<a name="164022169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022169">Greg Conneen (Apr 23 2019 at 19:32)</a>:</h4>
<p>And yeah I've been reading that file</p>

<a name="164022251"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022251" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022251">Patrick Massot (Apr 23 2019 at 19:33)</a>:</h4>
<p><code>nonempty (α ≃ β)</code></p>

<a name="164022274"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022274" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022274">Patrick Massot (Apr 23 2019 at 19:33)</a>:</h4>
<p>This is the Prop you are looking for</p>

<a name="164022456"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022456" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022456">Patrick Massot (Apr 23 2019 at 19:35)</a>:</h4>
<p>Probably I missed that piece of information: at what stage of your math studies are you? (Knowing this will help choosing explanations for you)</p>

<a name="164022688"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022688" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022688">Greg Conneen (Apr 23 2019 at 19:38)</a>:</h4>
<p>I don't think I've fully elaborated. I'm a 2nd year undergraduate math major currently taking my first semester of graduate real and complex analysis, and my third semester of graduate algebra. I plan on studying algebraic combinatorics, algebraic geometry, or algebraic topology. Either way, interested in algebra</p>

<a name="164022856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164022856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164022856">Patrick Massot (Apr 23 2019 at 19:40)</a>:</h4>
<p>I'm afraid my knowledge of the American university system is clearly not good enough to understand that answer. Can you give a couple of examples of theorems you recently learned in your most advanced courses?</p>

<a name="164023106"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164023106" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164023106">Kevin Buzzard (Apr 23 2019 at 19:42)</a>:</h4>
<blockquote>
<p><code>nonempty (α ≃ β)</code></p>
</blockquote>
<p>That just says alpha bijects with beta. You want an isomorphism of what structure?</p>

<a name="164023186"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164023186" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164023186">Johan Commelin (Apr 23 2019 at 19:43)</a>:</h4>
<p>He doesn't need more structure. He is trying to formalise Cayley's theorem.</p>

<a name="164023555"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164023555" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164023555">Greg Conneen (Apr 23 2019 at 19:48)</a>:</h4>
<p>Yeah. I'm currently in a course on wedderburn theory/commutative algebra. So, for example, we just covered the classification theorem for semisimple rings and semisimple algebras. In manifolds, we just covered the generalisation of stokes' theorem, and we just had an ending seminar on the Poincare lemma and the DeRham cohomology.</p>

<a name="164023653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164023653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164023653">Patrick Massot (Apr 23 2019 at 19:49)</a>:</h4>
<p>Thanks, this I understand (but I have no idea how to relate this to your abstract answer)</p>

<a name="164023777"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164023777" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164023777">Greg Conneen (Apr 23 2019 at 19:50)</a>:</h4>
<p>Well, I'm glad I could clarify for you</p>

<a name="164249738"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164249738" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164249738">Kevin Kappelmann (Apr 26 2019 at 10:27)</a>:</h4>
<p>What is the recommended/most elegant way to simplify/rewrite a hypothesis/assumption while re-stating the desired outcome of the simplification/rewriting? For example, doing</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">hyp</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="bp">=</span> <span class="n">false</span><span class="o">)</span> <span class="o">:</span> <span class="n">false</span> <span class="o">:=</span>
<span class="k">have</span> <span class="n">hyp</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">=</span> <span class="n">false</span><span class="o">,</span> <span class="k">by</span> <span class="o">{</span> <span class="n">simp</span> <span class="n">at</span> <span class="n">hyp</span><span class="o">,</span> <span class="n">assumption</span> <span class="o">},</span>
<span class="n">sorry</span>
</pre></div>


<p>is not quite perfect as I have to write <code>by { simp at hyp, assumption }</code> (preferably, I'd like to simply write <code>by simp at hyp</code>) and leaves me with two hypotheses called <code>hyp</code>, namely</p>
<div class="codehilite"><pre><span></span><span class="n">hyp</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">∧</span> <span class="n">true</span> <span class="bp">=</span> <span class="n">false</span><span class="o">,</span>
<span class="n">hyp</span> <span class="o">:</span> <span class="n">true</span> <span class="bp">=</span> <span class="n">false</span>
</pre></div>


<p>Is there something like <code>change</code> for hypotheses?</p>

<a name="164251420"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251420" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251420">Johan Commelin (Apr 26 2019 at 10:59)</a>:</h4>
<p>There is <code>rwa</code> and <code>simpa</code>. Do those help you?</p>

<a name="164251567"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251567" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251567">Kevin Kappelmann (Apr 26 2019 at 11:01)</a>:</h4>
<p>Alright, that solves the former issue. Can I also somehow drop the non-simplified version from the list of assumptions?</p>

<a name="164251650"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251650" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251650">Johan Commelin (Apr 26 2019 at 11:03)</a>:</h4>
<p><span class="user-mention" data-user-id="198376">@Kevin Kappelmann</span>  <code>replace hyp : bla, by foobar</code>?</p>

<a name="164251946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251946">Kevin Kappelmann (Apr 26 2019 at 11:08)</a>:</h4>
<p>Yeah, that's exactly what I was looking for! thanks :) I do not think <code>replace</code> is mentioned in the tutorial. Is there some sort of document/website with "advanced tactics/APIs" that I can consult in such cases?</p>

<a name="164251990"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251990" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251990">Johan Commelin (Apr 26 2019 at 11:09)</a>:</h4>
<p>Which tutorial?</p>

<a name="164251998"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164251998" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164251998">Johan Commelin (Apr 26 2019 at 11:09)</a>:</h4>
<p>See the <code>docs/</code> folder in mathlib. There is some stuff there.</p>

<a name="164252005"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164252005" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164252005">Kevin Kappelmann (Apr 26 2019 at 11:10)</a>:</h4>
<p>This document: <a href="https://leanprover.github.io/theorem_proving_in_lean/theorem_proving_in_lean.pdf" target="_blank" title="https://leanprover.github.io/theorem_proving_in_lean/theorem_proving_in_lean.pdf">https://leanprover.github.io/theorem_proving_in_lean/theorem_proving_in_lean.pdf</a></p>

<a name="164253453"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164253453" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164253453">Patrick Massot (Apr 26 2019 at 11:38)</a>:</h4>
<blockquote>
<p>Is there something like <code>change</code> for hypotheses?</p>
</blockquote>
<p>Yes, it's called <code>change</code></p>

<a name="164253515"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164253515" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164253515">Patrick Massot (Apr 26 2019 at 11:39)</a>:</h4>
<p>If you have <code>hyp : 1 + 1 = 2</code> you can <code>change 2 = 2 at hyp</code></p>

<a name="164446721"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164446721" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164446721">Kevin Kappelmann (Apr 29 2019 at 12:20)</a>:</h4>
<p>It's me again :') I'm having some problems when using <code>let</code>-expressions + cases/induction. For example, this does not work</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span> <span class="c1">-- error: could not find open goal of given case</span>
<span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="o">{</span><span class="n">sorry</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>whereas this works</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">zero</span> <span class="o">:</span> <span class="o">{</span><span class="n">sorry</span><span class="o">},</span>
<span class="n">case</span> <span class="n">nat</span><span class="bp">.</span><span class="n">succ</span> <span class="o">:</span> <span class="o">{</span><span class="n">sorry</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>


<p>Does someone know what I am doing wrong?</p>

<a name="164446952"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164446952" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164446952">Kevin Buzzard (Apr 29 2019 at 12:24)</a>:</h4>
<p>Maybe that's a bug in <code>case</code>? You know that you don't need it, right?</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">(</span><span class="n">n</span> <span class="n">m</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">:</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span> <span class="bp">=</span> <span class="n">m</span> <span class="bp">+</span> <span class="n">n</span> <span class="o">:=</span>
<span class="k">begin</span>
<span class="k">let</span> <span class="n">s</span> <span class="o">:=</span> <span class="n">n</span> <span class="bp">+</span> <span class="n">m</span><span class="o">,</span>
<span class="n">induction</span> <span class="n">n</span><span class="o">,</span>
<span class="o">{</span><span class="n">sorry</span><span class="o">},</span>
<span class="o">{</span><span class="n">sorry</span><span class="o">}</span>
<span class="kn">end</span>
</pre></div>

<a name="164447000"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164447000" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164447000">Kevin Kappelmann (Apr 29 2019 at 12:25)</a>:</h4>
<p>Yep, I'd really like to keep the <code>case nat.xxx</code> annotations though to keep my proofs more readable.</p>

<a name="164447056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164447056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164447056">Kevin Buzzard (Apr 29 2019 at 12:25)</a>:</h4>
<p>Make it a comment within the <code>{}</code>. And complain to the devs :-)</p>

<a name="164447163"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164447163" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164447163">Kevin Kappelmann (Apr 29 2019 at 12:27)</a>:</h4>
<p>Haha, alright :D Thanks</p>

<a name="164447324"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164447324" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164447324">Kevin Buzzard (Apr 29 2019 at 12:29)</a>:</h4>
<p><span class="user-mention" data-user-id="110026">@Simon Hudon</span> is this a bug?</p>

<a name="164447705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164447705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164447705">Simon Hudon (Apr 29 2019 at 12:35)</a>:</h4>
<p>I think it is. I'll look into it</p>

<a name="164506505"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164506505" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164506505">Greg Conneen (Apr 30 2019 at 02:51)</a>:</h4>
<p>Does <code>unfold</code> actually do anything other than change what the goal looks like? Isn't <code>#print</code> or <code>Ctrl-click</code> on what you're unfolding a replacement, since it's just a method of getting information about your goal? It seems that any proof can have the <code>unfold</code> statement removed, and it works just the same</p>

<a name="164506888"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164506888" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164506888">Mario Carneiro (Apr 30 2019 at 03:01)</a>:</h4>
<p>yes and no (and no). <code>unfold</code> will rewrite with equations that are not necessarily definitional equalities, so it might do more than just change the appearance of the goal. It's really a wrapper around <code>simp</code> with particular config options. <code>dunfold</code> is closer to your description, as it only does defeq simplifications. But there are two reasons that it's still not correct to say that it "doesn't actually do anything other than change what the goal looks like" and "any proof can have the <code>dunfold</code> statement removed and it works just the same". First, it does actually do something - it inserts an <code>id</code> term into the result (the partial proof being constructed). So you can see the result of <code>dsimp</code> and <code>dunfold</code> applications in the resulting proof if you <code>#print</code> it. This is done to keep typechecking time down by remembering the simplification path in the proof term.</p>
<p>The more important reason why <code>dunfold</code> and friends can't necessarily be removed from a proof is because many tactics depend on the syntactic shape of the goal or a hypothesis. For example, <code>rw</code> will not match against the goal if some definitional unfolding is required to see the constant that appears. For example if the goal is <code>2 * n = 0</code> where <code>n : nat</code>, then this is defeq to <code>n + n = 0</code> but <code>rw add_comm</code> would only work on the second form of the goal. So anything that "changes what the goal looks like" could potentially affect whether a later tactic succeeds. That said, many tactics don't care about anything beyond defeq, in particular <code>apply</code>, <code>refine</code> and <code>exact</code>, and in many cases you can remove superfluous <code>unfold</code> and <code>dunfold</code> tactics without breaking the proof.</p>

<a name="164832882"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164832882" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164832882">Simon Hudon (May 03 2019 at 21:45)</a>:</h4>
<p><span class="user-mention" data-user-id="198376">@Kevin Kappelmann</span> I now have a fix for your <code>let</code> / <code>case</code> issue. It should be in the next nightly build of Lean 3.5.0c</p>

<a name="164884660"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884660" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884660">Greg Conneen (May 04 2019 at 20:07)</a>:</h4>
<p>Real quick, what is a meta variable and why is <code>tactic.finish</code> absolutely packed with them? I'm not sure exactly what's going on, but it seems that any trivial propositional technique is proven immediately with <code>by finish</code></p>

<a name="164884711"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884711" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884711">Patrick Massot (May 04 2019 at 20:08)</a>:</h4>
<p>What do you mean <code>finish</code> is packed with metavariable?</p>

<a name="164884724"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884724" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884724">Patrick Massot (May 04 2019 at 20:09)</a>:</h4>
<p>A meta-variable is a kind of hole Lean will have to fill in. It can be the goal you need to solve or some implicit argument to be inferred by unification</p>

<a name="164884862"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884862" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884862">Greg Conneen (May 04 2019 at 20:13)</a>:</h4>
<p>I just mean that when I pressed <code>Ctrl-Click</code> on <code>tactic.finish</code>, I came upon a file that was filled with the keyword <code>meta</code> and I wasn't sure what any of it meant</p>

<a name="164884865"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884865" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884865">Patrick Massot (May 04 2019 at 20:14)</a>:</h4>
<p>oohh</p>

<a name="164884911"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884911" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884911">Patrick Massot (May 04 2019 at 20:14)</a>:</h4>
<p>that's a different meta</p>

<a name="164884923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884923">Greg Conneen (May 04 2019 at 20:15)</a>:</h4>
<p>I suppose so, I just assumed that <code>meta def</code> was defining a metavariable, although I suppose that wouldn't make sense given my preconceived notion of what a metavariable is</p>

<a name="164884925"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884925" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884925">Patrick Massot (May 04 2019 at 20:15)</a>:</h4>
<p><code>meta</code> in this context means "unsafe". It's code that won't be checked by Lean. It particular it doesn't have to be provably terminating</p>

<a name="164884946"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884946" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884946">Greg Conneen (May 04 2019 at 20:15)</a>:</h4>
<p>Why would one ever need such a thing?</p>

<a name="164884950"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164884950" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164884950">Patrick Massot (May 04 2019 at 20:15)</a>:</h4>
<p>Typically tactics (the commands you type between begin and end) are meta. They produce proofs that <em>will</em> be checked by Lean. But the way they produces those proofs is freestyle</p>

<a name="164885023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885023">Greg Conneen (May 04 2019 at 20:17)</a>:</h4>
<p>Ah, okay. So it's not just a cheeky way of making axioms. So the reason I can solve so many things with <code>by finish</code> is because all of the structures in <code>finish</code> are using this meta keyword? I assume without it, there wouldn't be a way of taking arbitrary propositions and figuring out how to solve them</p>

<a name="164885069"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885069" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885069">Greg Conneen (May 04 2019 at 20:18)</a>:</h4>
<p>That is, <code>finish</code> wouldn't know how to solve a proposition handed to it if it weren't in a specific order of some sort</p>

<a name="164885070"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885070" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885070">Scott Morrison (May 04 2019 at 20:18)</a>:</h4>
<p><code>meta</code> code can do non-terminating recursion, and it can also work with "reflected" versions of mathematical objects, i.e. their actual representations as <code>expr</code> objects in the C++ code.</p>

<a name="164885074"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885074" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885074">Patrick Massot (May 04 2019 at 20:18)</a>:</h4>
<p><code>finish</code> constructs a proof for you</p>

<a name="164885086"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885086" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885086">Greg Conneen (May 04 2019 at 20:19)</a>:</h4>
<p>Okay, that's really cool <span class="user-mention" data-user-id="110087">@Scott Morrison</span></p>

<a name="164885089"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885089" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885089">Patrick Massot (May 04 2019 at 20:19)</a>:</h4>
<p>I don't think there is any risk of non-termination here. But the type of Lean expressions is meta, for reasons too long to explain (unless you understand what Scott wrote)</p>

<a name="164885133"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885133" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885133">Scott Morrison (May 04 2019 at 20:20)</a>:</h4>
<p>This is one of the lovely things about Lean --- you can write new tactics (i.e. programs that construct proofs, but aren't necessarily themselves correct) in Lean itself.</p>

<a name="164885135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885135">Greg Conneen (May 04 2019 at 20:20)</a>:</h4>
<p>I understand C++ enough to generally know what he means</p>

<a name="164885145"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885145" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885145">Scott Morrison (May 04 2019 at 20:20)</a>:</h4>
<p>In previous interactive theorem provers you needed to step out, either into the base implementation language, or some DSL, to write new tactics.</p>

<a name="164885155"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885155" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885155">Greg Conneen (May 04 2019 at 20:21)</a>:</h4>
<p>So, even with meta, there's still no way to prove false? Because a bad tactic won't construct a good proof?</p>

<a name="164885159"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885159" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885159">Greg Conneen (May 04 2019 at 20:21)</a>:</h4>
<p>That makes sense</p>

<a name="164885161"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885161" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885161">Scott Morrison (May 04 2019 at 20:21)</a>:</h4>
<p>The <code>meta</code> keyword <em>protects</em> the real maths from these "helper" functions that we write to help construct proofs.</p>

<a name="164885165"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885165" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885165">Greg Conneen (May 04 2019 at 20:21)</a>:</h4>
<p>ahh</p>

<a name="164885169"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885169" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885169">Scott Morrison (May 04 2019 at 20:22)</a>:</h4>
<p>Exactly. The tactic framework lets you <em>run</em> meta code to produce proof terms, but those proof terms will be rejected if they refer to any <code>meta</code> functions.</p>

<a name="164885214"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885214" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885214">Greg Conneen (May 04 2019 at 20:22)</a>:</h4>
<p>so, how would a noob go about using meta? Or, should I just not even touch the thing?</p>

<a name="164885226"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885226" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885226">Patrick Massot (May 04 2019 at 20:23)</a>:</h4>
<p>It depends on your taste, background and goals</p>

<a name="164885227"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885227" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885227">Scott Morrison (May 04 2019 at 20:23)</a>:</h4>
<p>Read <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md">https://github.com/leanprover-community/mathlib/blob/master/docs/extras/tactic_writing.md</a></p>

<a name="164885234"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885234" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885234">Scott Morrison (May 04 2019 at 20:23)</a>:</h4>
<p>And start reading all the files in <code>src/tactic/</code> in the mathlib repository.</p>

<a name="164885236"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885236" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885236">Scott Morrison (May 04 2019 at 20:23)</a>:</h4>
<p>and ask here :-)</p>

<a name="164885242"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885242" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885242">Patrick Massot (May 04 2019 at 20:23)</a>:</h4>
<p>Yes, reading that tutorial will give you a first glance at what it looks like</p>

<a name="164885244"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885244" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885244">Patrick Massot (May 04 2019 at 20:24)</a>:</h4>
<p>Reading <code>src/tactic/</code> will give you a lot more (after a <em>lot</em> more time)</p>

<a name="164885297"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885297" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885297">Greg Conneen (May 04 2019 at 20:24)</a>:</h4>
<p>Great, thank you. My goal generally is to git gud in Lean, but eventually I want to start implementing some actual maths. I expect that will take me some time, given I'll have to read quite a bit of mathlib</p>

<a name="164885311"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885311" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885311">Patrick Massot (May 04 2019 at 20:25)</a>:</h4>
<p>You don't have to read all of mathlib before starting to implement actual maths</p>

<a name="164885428"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885428" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885428">Greg Conneen (May 04 2019 at 20:28)</a>:</h4>
<p>sure, but I'd like to understand a chunk of what's already there on a fundamental level</p>

<a name="164885432"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885432" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885432">Scott Morrison (May 04 2019 at 20:28)</a>:</h4>
<p>Do you have an idea what maths you'd like to do?</p>

<a name="164885440"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885440" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885440">Scott Morrison (May 04 2019 at 20:29)</a>:</h4>
<p>If you're ever tempted to add documentation to stuff you're reading, documentation-only pull requests are very welcome. :-)</p>

<a name="164885457"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885457" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885457">Greg Conneen (May 04 2019 at 20:29)</a>:</h4>
<p>I'd like to define a manifold, and maybe prove the inverse/implicit function theorem</p>

<a name="164885514"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885514" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885514">Greg Conneen (May 04 2019 at 20:30)</a>:</h4>
<p>I just really need to look over how topology and euclidean space are implemented first</p>

<a name="164885519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885519">Greg Conneen (May 04 2019 at 20:30)</a>:</h4>
<p>Also, do we have the definition of a metric space?</p>

<a name="164885594"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885594" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885594">Kevin Buzzard (May 04 2019 at 20:32)</a>:</h4>
<p><span class="user-mention" data-user-id="218940">@Greg Conneen</span> If you want to implement some actual maths in Lean, then don't try to get good at Lean first, just try to implement some actual maths in Lean, get stuck, ask for help here, and you will succeed.</p>

<a name="164885598"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885598" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885598">Sebastien Gouezel (May 04 2019 at 20:32)</a>:</h4>
<p>I am precisely working on the definition of a manifold. Work in progress (very much in a preliminary state) at <a href="https://github.com/sgouezel/mathlib/blob/aa7fbab39d1e6a01665e24e6197b09338e855467/src/geometry/manifolds/basic.lean#L1598" target="_blank" title="https://github.com/sgouezel/mathlib/blob/aa7fbab39d1e6a01665e24e6197b09338e855467/src/geometry/manifolds/basic.lean#L1598">https://github.com/sgouezel/mathlib/blob/aa7fbab39d1e6a01665e24e6197b09338e855467/src/geometry/manifolds/basic.lean#L1598</a></p>

<a name="164885608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885608">Kevin Buzzard (May 04 2019 at 20:32)</a>:</h4>
<p>I have no idea how to write tactics. Tactics are written in meta code because they can fail. You don't need to know anything about tactic-writing (which is what people use meta code for) to write maths.</p>

<a name="164885624"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885624" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885624">Kevin Buzzard (May 04 2019 at 20:33)</a>:</h4>
<p>However, what you do need to know is what is already there and what is being worked on, because this changes <em>fast</em> here</p>

<a name="164885676"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885676" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885676">Kevin Buzzard (May 04 2019 at 20:34)</a>:</h4>
<p>Yes we have metric spaces. You can see this yourself by firing up a project with mathlib as a dependency in VS Code and searching for metric space. This is a really important beginner skill to learn.</p>

<a name="164885695"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885695" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885695">Kevin Buzzard (May 04 2019 at 20:35)</a>:</h4>
<p>Make sure that "the cog doesn't have a box around it" in "files to exclude" in VS Code. That way you can search your dependencies.</p>

<a name="164885701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885701">Kevin Buzzard (May 04 2019 at 20:35)</a>:</h4>
<p>Several people would like to define manifolds and people are sort of in the middle of things, so it might not be a perfect project right now for a beginner.</p>

<a name="164885752"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885752" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885752">Kevin Buzzard (May 04 2019 at 20:36)</a>:</h4>
<p>Definitions are harder than theorems; proofs can be sloppy but it's important to get definitions right.</p>

<a name="164885756"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885756" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885756">Kevin Buzzard (May 04 2019 at 20:36)</a>:</h4>
<p>One big obstruction to doing much with manifolds is that we don't have enough calculus, but again people are working on this and things are changing fast.</p>

<a name="164885771"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885771" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885771">Kevin Buzzard (May 04 2019 at 20:37)</a>:</h4>
<p>Bump functions are still a little out of reach at the minute, but it won't be long until we have them.</p>

<a name="164885840"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885840" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885840">Kevin Buzzard (May 04 2019 at 20:38)</a>:</h4>
<p>For polynomials we have multivariable ones and single variable ones; I am not an expert in either analysis or Lean-analysis, but I am wondering whether we are going to need a robust theory of calculus in one real variable, proving basic theorems such that the derivative of the integral is the function. I don't think we even have that.</p>

<a name="164885857"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885857" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885857">Kevin Buzzard (May 04 2019 at 20:39)</a>:</h4>
<p>We have no complex analysis worth mentioning, not even integrating along a reasonable path.</p>

<a name="164885923"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164885923" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164885923">Kevin Buzzard (May 04 2019 at 20:40)</a>:</h4>
<p>Because of our lack of analysis, this makes manifolds harder to do, however having goals like manifolds in mind is driving the library forwards in the right direction (as far as I am concerned). Lean seems to me to be focussing on the kind of mathematics mathematicians do, as opposed to the kind of mathematics that computer scientists have managed to pick up somehow.</p>

<a name="164886015"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164886015" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164886015">Greg Conneen (May 04 2019 at 20:43)</a>:</h4>
<p>Gotcha, thanks for the information. Do you think that complex would be a good thing to get working on, or do we not have it because it's hard to implement?</p>

<a name="164886260"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164886260" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164886260">Kevin Buzzard (May 04 2019 at 20:49)</a>:</h4>
<p>I am not an analyst and it's been nearly 30 years since I thought about the basics, Cauchy's integral formula etc. I've never taught the course either, so I am not the person to ask.</p>

<a name="164886319"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164886319" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164886319">Kevin Buzzard (May 04 2019 at 20:50)</a>:</h4>
<p>One thing I know was an issue is that someone has to make a decision about in what generality to define path integrals -- C^infinity paths isn't good enough because you want to integrate round semicircles and rectangles etc.</p>

<a name="164886332"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164886332" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164886332">Kevin Buzzard (May 04 2019 at 20:51)</a>:</h4>
<p>I really don't know what's there already though; I know a lot of the algebra stuff in Lean but the analysis stuff is changing quickly at the minute.</p>

<a name="164886554"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164886554" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164886554">Patrick Massot (May 04 2019 at 20:56)</a>:</h4>
<p>Kevin, the way this is going, we'll soon have manifolds with boundary <em>and</em> corners. When we'll have differential forms this will be much more than enough for rectangle and semi-circles</p>

<a name="164887338"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/164887338" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#164887338">Kevin Buzzard (May 04 2019 at 21:17)</a>:</h4>
<p>Woo hoo we'll have de Rham. cohomology one day. Is this in any other theorem prover?</p>

<a name="167754387"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167754387" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167754387">Wojciech Nawrocki (Jun 10 2019 at 12:24)</a>:</h4>
<p>Is it possible to "unimport" <code>core</code>/<code>prelude</code>, i.e. the basic definitions of <code>nat</code>, <code>eq</code>, etc, leaving an environment pretty much free of any definitions?</p>

<a name="167754427"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167754427" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167754427">Kevin Buzzard (Jun 10 2019 at 12:25)</a>:</h4>
<p>You can put <code>prelude</code> at the top of your file</p>

<a name="167754438"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167754438" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167754438">Kevin Buzzard (Jun 10 2019 at 12:25)</a>:</h4>
<p>which translates to "this file is part of the prelude" (so don't be importing all the prelude)</p>

<a name="167754444"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167754444" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167754444">Kevin Buzzard (Jun 10 2019 at 12:25)</a>:</h4>
<p>I've never used it, I've just seen people suggest it</p>

<a name="167754516"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167754516" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167754516">Wojciech Nawrocki (Jun 10 2019 at 12:26)</a>:</h4>
<p>Yup, that seems to work. Thank you!</p>

<a name="167898225"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/167898225" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#167898225">Wojciech Nawrocki (Jun 11 2019 at 22:56)</a>:</h4>
<p>Is the notation <code>h.fn arg</code> given <code>class myclass (α: Type*) := (fn: α → ℕ)</code> and <code>[h: myclass α]</code> discouraged? It stops working for example if <code>fn: ℕ → α</code> because the type argument <code>α </code> to <code>myclass.fn</code> becomes explicit, i.e. <code>myclass.fn : Π (α : Type u_1) [c : myclass α], ℕ → α</code>.</p>

<a name="168518423"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168518423" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168518423">Adrian Chu (Jun 19 2019 at 15:44)</a>:</h4>
<p>Given a positive integer n, how to define a vector with n entries? Thanks</p>

<a name="168518493"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168518493" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168518493">Kenny Lau (Jun 19 2019 at 15:45)</a>:</h4>
<p><code>vector \alpha n</code></p>

<a name="168518616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168518616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168518616">Adrian Chu (Jun 19 2019 at 15:46)</a>:</h4>
<p>Oh, and say x is the vector, how do we decribe its i-th entry?</p>

<a name="168518620"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168518620" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168518620">Kenny Lau (Jun 19 2019 at 15:46)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span>
</pre></div>

<a name="168518656"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168518656" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168518656">Kenny Lau (Jun 19 2019 at 15:47)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span> <span class="o">(</span><span class="n">k</span> <span class="o">:</span> <span class="n">fin</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">v</span><span class="bp">.</span><span class="n">nth</span> <span class="n">k</span>
</pre></div>

<a name="168519365"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168519365" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168519365">Adrian Chu (Jun 19 2019 at 15:55)</a>:</h4>
<p>how to do summation from i=1 to n ?</p>

<a name="168519856"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168519856" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168519856">Kenny Lau (Jun 19 2019 at 16:00)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector2</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">v</span><span class="bp">.</span><span class="n">to_list</span><span class="bp">.</span><span class="n">sum</span>
</pre></div>

<a name="168521168"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521168" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521168">Adrian Chu (Jun 19 2019 at 16:18)</a>:</h4>
<p>one more question: how do we define new 3-vector, say, (x,y,x+y) where x, y are variable?</p>

<a name="168521321"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521321" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521321">Adrian Chu (Jun 19 2019 at 16:20)</a>:</h4>
<p>and more importantly, is there some online resource where I can read and get familiarized with these simple commands? I skimmed through theorem_proving_in_lean.pdf and couldn't find what I want... I feel like i'm asking too many noob questions like an idiot lol</p>

<a name="168521500"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521500" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521500">Kenny Lau (Jun 19 2019 at 16:23)</a>:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span> <span class="n">y</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">⟨</span><span class="o">[</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="bp">+</span><span class="n">y</span><span class="o">],</span> <span class="n">rfl</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="mi">3</span><span class="o">)</span>
</pre></div>

<a name="168521617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521617">Adrian Chu (Jun 19 2019 at 16:25)</a>:</h4>
<p>how about an n-vector like (x, 2x, 3x, ..., nx)? <span aria-label="mischievous" class="emoji emoji-1f61b" role="img" title="mischievous">:mischievous:</span></p>

<a name="168521647"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521647" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521647">Bryan Gin-ge Chen (Jun 19 2019 at 16:25)</a>:</h4>
<blockquote>
<p>is there some online resource where I can read and get familiarized with these simple commands</p>
</blockquote>
<p>Unfortunately there isn't much beyond TPiL. You'll have to get used to reading source files. <a href="https://github.com/leanprover/lean/blob/master/library/data/vector.lean" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/data/vector.lean">Here's data.vector</a>.</p>

<a name="168521728"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521728" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521728">Adrian Chu (Jun 19 2019 at 16:26)</a>:</h4>
<blockquote>
<blockquote>
<p>is there some online resource where I can read and get familiarized with these simple commands</p>
</blockquote>
<p>Unfortunately there isn't much beyond TPiL. You'll have to get used to reading source files. <a href="https://github.com/leanprover/lean/blob/master/library/data/vector.lean" target="_blank" title="https://github.com/leanprover/lean/blob/master/library/data/vector.lean">Here's data.vector</a>.</p>
</blockquote>
<p>Oh i see, thanks</p>

<a name="168521872"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521872" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521872">Floris van Doorn (Jun 19 2019 at 16:28)</a>:</h4>
<p>Currently, if you want to figure these things out yourself, the best way is just to look through the library files in mathlib (and core). You can go to <code>data/vector2</code> in mathlib or the file Bryan mentioned in core. Also, operations on list might be useful to know for vectors. Other ways to find things you're searching for: </p>
<ul>
<li>Browse through files (either on Github or locally)</li>
<li>"Go to definition" and "peek definition" (F12 and alt-F12 / option-F12?)</li>
<li>Search in VSCode (ctrl+shift+F)</li>
<li>Search on Github</li>
<li>Execute <code>#print prefix vector</code> in Lean</li>
<li>Find lemmas using the tactic <code>library_search</code></li>
</ul>

<a name="168521944"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168521944" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168521944">Floris van Doorn (Jun 19 2019 at 16:29)</a>:</h4>
<blockquote>
<p>(x, 2x, 3x, ..., nx)</p>
</blockquote>
<p>without looking at the library: hopefully <code>vector.range</code> and <code>vector.map</code> both exists, from which you should be able to figure it out (if not, use <code>list.range</code> and/or <code>list.map</code>)</p>

<a name="168522426"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168522426" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168522426">Kenny Lau (Jun 19 2019 at 16:35)</a>:</h4>
<blockquote>
<p>how about an n-vector like (x, 2x, 3x, ..., nx)? <span aria-label="mischievous" class="emoji emoji-1f61b" role="img" title="mischievous">:mischievous:</span></p>
</blockquote>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">algebra</span><span class="bp">.</span><span class="n">group_power</span> <span class="n">data</span><span class="bp">.</span><span class="n">pnat</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">{</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">}</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span>
<span class="n">def</span> <span class="n">multiple</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">:</span> <span class="bp">ℕ</span> <span class="bp">→</span> <span class="n">α</span>
<span class="bp">|</span> <span class="mi">0</span> <span class="o">:=</span> <span class="n">x</span> <span class="c1">-- junk value</span>
<span class="bp">|</span> <span class="mi">1</span> <span class="o">:=</span> <span class="n">x</span>
<span class="bp">|</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">2</span><span class="o">)</span> <span class="o">:=</span> <span class="n">multiple</span> <span class="o">(</span><span class="n">n</span><span class="bp">+</span><span class="mi">1</span><span class="o">)</span> <span class="bp">+</span> <span class="n">x</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">)</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="o">(</span><span class="bp">⟨</span><span class="o">(</span><span class="n">list</span><span class="bp">.</span><span class="n">range</span> <span class="n">n</span><span class="o">)</span><span class="bp">.</span><span class="n">map</span> <span class="o">(</span><span class="bp">λ</span> <span class="n">i</span><span class="o">,</span> <span class="n">multiple</span> <span class="n">x</span> <span class="o">(</span><span class="n">i</span><span class="bp">+</span><span class="mi">1</span><span class="o">)),</span> <span class="k">by</span> <span class="n">simp</span><span class="bp">⟩</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span>
</pre></div>

<a name="168523081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168523081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168523081">Floris van Doorn (Jun 19 2019 at 16:43)</a>:</h4>
<p>If \a is an <code>add_monoid</code>, you can use <code>add_monoid.smul</code> instead of <code>multiple</code></p>

<a name="168524430"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168524430" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168524430">Adrian Chu (Jun 19 2019 at 17:00)</a>:</h4>
<blockquote>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="n">data</span><span class="bp">.</span><span class="n">vector2</span>
<span class="n">universes</span> <span class="n">u</span>
<span class="kn">variables</span> <span class="o">(</span><span class="n">α</span> <span class="o">:</span> <span class="kt">Type</span> <span class="n">u</span><span class="o">)</span> <span class="o">[</span><span class="n">has_zero</span> <span class="n">α</span><span class="o">]</span> <span class="o">[</span><span class="n">has_add</span> <span class="n">α</span><span class="o">]</span> <span class="o">(</span><span class="n">n</span> <span class="o">:</span> <span class="bp">ℕ</span><span class="o">)</span> <span class="o">(</span><span class="n">v</span> <span class="o">:</span> <span class="n">vector</span> <span class="n">α</span> <span class="n">n</span><span class="o">)</span>
<span class="bp">#</span><span class="kn">check</span> <span class="n">v</span><span class="bp">.</span><span class="n">to_list</span><span class="bp">.</span><span class="n">sum</span>
</pre></div>


</blockquote>
<p>Is there a way to do summation without using vector?</p>

<a name="168524753"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168524753" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168524753">Johan Commelin (Jun 19 2019 at 17:02)</a>:</h4>
<p>You might be interested in <code>finset.sum</code> and <code>finset.range</code>. The first gives you sums, the second gives you the <code>finset</code> "{0, ..., n-1}"</p>

<a name="168524885"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168524885" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168524885">Kevin Buzzard (Jun 19 2019 at 17:04)</a>:</h4>
<p><span class="user-mention" data-user-id="218709">@Adrian Chu</span> the problem is that TPIL just deals with core Lean, and you are asking about how to use stuff in the maths library. When I was learning the basics, I found the maths library very intimidating, but when I realised that I should just stop reading the proofs and instead just look at the definitions, I found that I could proceed with my mathematics very nicely, which in turn led to more understanding, which in turn made reading the proofs which I had been ignoring all this time much easier.</p>
<p>One thing I learnt fairly quickly was to abstract exactly what I wanted. For example you asked how to make (x, 2x, 3x, ..., nx). But in fact you can break this down into smaller questions. Probably you know well how to make a function like <code>lam n, (n + 1) * x</code>, so then you realise that what you really need is how to make (f 0, f 1, ..., f m). Now from general functional programming you might know that they like things like working out how to take a function f and to apply it to a vector like (0 1 2 ... n) so now you have two smaller questions -- how to make a vector like (0 1 2 ... n) and how to apply a function to every element of a vector. By this stage we are in the world where these ideas have a common name -- <code>range</code> for (0 1 2 ... n) and <code>map</code> for applying a function to a bunch of things at once. Now you can begin to guess the actual names of the functions you want. </p>
<p>Learning to think this way was a very important stepping stone for me; I slowly began to realise that I was developing a method for being able to answer my own questions of this nature. I am still learning, but this is the way to think about it. For every question, figure out how to build it from general tools and then figure out where those general tools are, perhaps by figuring out first what they should be called.</p>

<a name="168525940"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168525940" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168525940">Adrian Chu (Jun 19 2019 at 17:16)</a>:</h4>
<p>I see... I feel that TPiL is like a book teaching grammar, while mathlib is a dictionary. And knowing all the grammar does not immediately guarantee one can fluently read a dictionary, let alone writing sentences or paragraphs.</p>

<a name="168538087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168538087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168538087">Kevin Buzzard (Jun 19 2019 at 19:27)</a>:</h4>
<p>If you look through something like <code>data.list.basic</code> and take a look at just the names and the statements of the theorems, you can learn a lot about mathlib's naming conventions. The description above (breaking what you want down into small pieces) is I think how you're supposed to think about functional programming; the same sort of themes come up again and again; import <code>data.finset</code> and then use <code>#check</code> to look at the types of <code>list.map</code> and <code>multiset.map</code> and <code>finset.map</code> and it slowly dawns on you that <code>map</code> means a very specific thing in this game. Then try <code>list.range</code> and <code>multiset.range</code> and <code>finset.range</code>. It will slowly dawn on you by people are suggesting that you use <code>vector.map</code> and <code>vector.range</code> without even knowing if these functions are defined in Lean -- and if they're not then it's not hard to make them.</p>

<a name="168565250"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168565250" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168565250">Luis Berlioz (Jun 20 2019 at 04:08)</a>:</h4>
<p>Can I place a variable declaration in the middle of a proof? <br>
For example instead of this:</p>
<div class="codehilite"><pre><span></span><span class="kn">variable</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span>
<span class="kn">example</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="o">(</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">hr</span> <span class="o">:</span> <span class="n">r</span><span class="o">,</span>
<span class="k">show</span> <span class="o">(</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span><span class="o">),</span> <span class="k">from</span>  <span class="bp">⟨</span> <span class="n">s</span><span class="o">,</span> <span class="n">hr</span> <span class="bp">⟩</span>
</pre></div>


<p>I want the variable <code>s : α </code> declared inside the proof, like:</p>
<div class="codehilite"><pre><span></span><span class="kn">example</span> <span class="o">:</span> <span class="n">r</span> <span class="bp">→</span> <span class="o">(</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">:=</span>
<span class="k">assume</span> <span class="n">hr</span> <span class="o">:</span> <span class="n">r</span><span class="o">,</span>
<span class="kn">variable</span> <span class="n">s</span> <span class="o">:</span> <span class="n">α</span>
<span class="k">show</span> <span class="o">(</span> <span class="bp">∃</span> <span class="n">x</span> <span class="o">:</span> <span class="n">α</span><span class="o">,</span> <span class="n">r</span><span class="o">),</span> <span class="k">from</span>  <span class="bp">⟨</span> <span class="n">s</span><span class="o">,</span> <span class="n">hr</span> <span class="bp">⟩</span>
</pre></div>

<a name="168565314"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168565314" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168565314">Johan Commelin (Jun 20 2019 at 04:10)</a>:</h4>
<p>No, that's not possible. Maybe you mean <code>have</code> or <code>let</code>?</p>

<a name="168565329"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168565329" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168565329">Johan Commelin (Jun 20 2019 at 04:11)</a>:</h4>
<p>The goal is to prove that some <code>alpha</code> exists. You can't just grab it out of nowhere.</p>

<a name="168565408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168565408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168565408">Luis Berlioz (Jun 20 2019 at 04:13)</a>:</h4>
<p>Ok, that makes sense.</p>

<a name="168583023"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583023" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583023">Adrian Chu (Jun 20 2019 at 10:14)</a>:</h4>
<p>how to fix <br>
<code>def y := [1,2,3] 
#eval 4+y.nth 2</code> ? why can't I add?</p>

<a name="168583185"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583185" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583185">Mario Carneiro (Jun 20 2019 at 10:16)</a>:</h4>
<p>nth returns <code>option nat</code></p>

<a name="168583205"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583205" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583205">Mario Carneiro (Jun 20 2019 at 10:17)</a>:</h4>
<p>you should be able to use <code>y.nth_le 2 dec_trivial</code></p>

<a name="168583631"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583631" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583631">Adrian Chu (Jun 20 2019 at 10:25)</a>:</h4>
<p>oh it works, thanks! but what do .nth_le and dec_trivial means?</p>

<a name="168583717"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583717" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583717">Mario Carneiro (Jun 20 2019 at 10:26)</a>:</h4>
<p>no one wants an array out of bounds exception</p>

<a name="168583726"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168583726" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168583726">Mario Carneiro (Jun 20 2019 at 10:26)</a>:</h4>
<p>the dec_trivial is a proof that 2 &lt; 3</p>

<a name="168584110"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168584110" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168584110">Adrian Chu (Jun 20 2019 at 10:32)</a>:</h4>
<p>i see</p>

<a name="168585134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168585134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168585134">Adrian Chu (Jun 20 2019 at 10:52)</a>:</h4>
<p>How about </p>
<div class="codehilite"><pre><span></span>def y := [1,2,3]
def g (i : fin 3) : ℕ := y.nth_le i-1
def f (i : fin 3) : ℕ := 4 + y.nth_le i-1 dec_trivial
</pre></div>


<p>? What's wrong?</p>

<a name="168587909"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168587909" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168587909">Reid Barton (Jun 20 2019 at 11:42)</a>:</h4>
<p>Clearly you intended to have parentheses around <code>i-1</code>, but I'm not sure what you are trying to achieve</p>

<a name="168588087"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168588087" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168588087">Wojciech Nawrocki (Jun 20 2019 at 11:45)</a>:</h4>
<p>Yep, function application binds tighter than subtraction, so to express what you want you need to put parentheses around <code>i-1</code>. You're also missing a proof that <code>(i-i &lt; list.length y)</code> in <code>g</code> (no second argument is given).</p>

<a name="168589081"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168589081" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168589081">Adrian Chu (Jun 20 2019 at 12:03)</a>:</h4>
<blockquote>
<p>Yep, function application binds tighter than subtraction, so to express what you want you need to put parentheses around <code>i-1</code>. You're also missing a proof that <code>(i-i &lt; list.length y)</code> in <code>g</code> (no second argument is given).</p>
</blockquote>
<p>How exactly should I give the proof then?</p>

<a name="168589164"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168589164" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168589164">Mario Carneiro (Jun 20 2019 at 12:04)</a>:</h4>
<p>You could use <code>fin.last</code> instead</p>

<a name="168589276"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168589276" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168589276">Mario Carneiro (Jun 20 2019 at 12:06)</a>:</h4>
<p>If you were doing this from scratch, you would be proving i-1 &lt; 3 given i &lt; 3. There are theorems in data.nat.basic to help with this</p>

<a name="168589294"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168589294" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168589294">Mario Carneiro (Jun 20 2019 at 12:06)</a>:</h4>
<p>alternatively, you can skip the proof and just handle the possibility of error using <code>nth</code></p>

<a name="168589705"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168589705" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168589705">Wojciech Nawrocki (Jun 20 2019 at 12:14)</a>:</h4>
<p>I'm kinda surprised that <code>forall (n m k: nat), n &lt; m -&gt; n-k &lt; m</code> isn't already in mathlib.</p>

<a name="168590997"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168590997" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168590997">Mario Carneiro (Jun 20 2019 at 12:36)</a>:</h4>
<p>it's just the composition of lt_of_le_of_lt and sub_le</p>

<a name="168641043"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641043" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641043">Scott Morrison (Jun 20 2019 at 22:45)</a>:</h4>
<p>That said, I think we should add it. Finding these lemmas is excruciating for beginners (who haven't even learnt that you can in principle guess the names of most basic facts, let alone learnt how to do it).</p>

<a name="168641134"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641134" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641134">Scott Morrison (Jun 20 2019 at 22:47)</a>:</h4>
<p>How bad is the downside of swamping Lean with these sort of "composition of two lemmas" lemmas?</p>

<a name="168641154"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641154" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641154">Mario Carneiro (Jun 20 2019 at 22:47)</a>:</h4>
<p>there is a combinatorial explosion</p>

<a name="168641198"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641198" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641198">Mario Carneiro (Jun 20 2019 at 22:48)</a>:</h4>
<p>it's not even clear which compositions are the most common</p>

<a name="168641218"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641218" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641218">Mario Carneiro (Jun 20 2019 at 22:48)</a>:</h4>
<p>and we don't even have the complete set of basic lemmas</p>

<a name="168641245"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168641245" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168641245">Mario Carneiro (Jun 20 2019 at 22:49)</a>:</h4>
<p>I would rather put more smarts into <code>library_search</code>type provers than flood the library with random facts</p>

<a name="168643353"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168643353" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168643353">Scott Morrison (Jun 20 2019 at 23:27)</a>:</h4>
<p>/me needs to get back to <code>back</code></p>

<a name="168646368"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646368" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646368">Tim Daly (Jun 21 2019 at 00:35)</a>:</h4>
<p>There need not be a combinatorial explosion, nor does the naming convention have to be so baroque.</p>
<p>It appears to me that Lean is using a flat namespace.  The naming convention makes it really hard to guess what you need.</p>
<p>Farmer and Carette (McMaster U.) have the notion of "tiny theories" which intrioduce a single axiom or a single signature. These can be combined to form larger objects which inherit the axioms and signatures. So, for instance, there would be a "commutative" axiom which can be inherited everywhere it makes sense.</p>
<p>This hierarchical organization enables re-use of axioms and signatures and allows the same name to occur in different paths in the inheritance graph.</p>

<a name="168646462"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646462" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646462">Mario Carneiro (Jun 21 2019 at 00:37)</a>:</h4>
<p>Lean has namespaces, which are used to label the major components in the theorem, or the broad area in which it lives</p>

<a name="168646544"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646544" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646544">Mario Carneiro (Jun 21 2019 at 00:39)</a>:</h4>
<p>The naming convention is designed to be easy to guess based on the statement, so you can think of a statement that you think is true and then search for the corresponding name. I'm curious how you would propose to improve on that scheme</p>

<a name="168646671"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646671" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646671">Mario Carneiro (Jun 21 2019 at 00:41)</a>:</h4>
<p>The number of theorems does increase exponentially as the depth increases. If there are n theorems, then there are O(n^2) ways to compose two of them, O(n^3) ways to compose three, and so on. Even 2n theorems is a major increase; n^2 is totally intractable</p>

<a name="168646829"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646829" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646829">Tim Daly (Jun 21 2019 at 00:44)</a>:</h4>
<p>Namespaces don't implement an inheritance graph in any generality. You'd like to state the commutative axiom in one place in the graph and have it available whereever it is used.  What you really want is genreal "name polymorphism" so that the name 'factor' can have different semantics in different contexts. Using 'dotted namespace notation' forces the user to manage the namespace. This doesn't scale.</p>

<a name="168646851"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646851" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646851">Scott Morrison (Jun 21 2019 at 00:45)</a>:</h4>
<p>Well... only a fraction of those n^2 theorems actually make sense. I wish I had a better sense of what that fraction was. I guess this could be automated. :-)</p>

<a name="168646874"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646874" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646874">Scott Morrison (Jun 21 2019 at 00:45)</a>:</h4>
<p><span class="user-mention" data-user-id="223495">@Tim Daly</span>, of course Lean does state the commutative axiom only once.</p>

<a name="168646924"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168646924" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168646924">Scott Morrison (Jun 21 2019 at 00:46)</a>:</h4>
<p>(Okay, twice, once for "additive" structures and once for "multiplicative", which is lame, but still, it's only 2. :-)</p>

<a name="168647408"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168647408" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168647408">Tim Daly (Jun 21 2019 at 00:58)</a>:</h4>
<p>How does Lean handle a Lie algebra? Lie groups are skew-symmetric and they are non-associative. So</p>
<p>x*y = -y * x and</p>
<p>x * (y  * z) = (x * y) * z + y * (x * z)</p>
<p>Do you have to "built it from nothing" using an odd naming convention for things like "algebra.lie.cross_product_skew_symmetric."?</p>
<p>Axiom, which uses something similar to Farmer/Carette "tiny theories" has 10,000 functions but a much smaller set of names.</p>

<a name="168647526"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168647526" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168647526">Scott Morrison (Jun 21 2019 at 01:01)</a>:</h4>
<p>As far as I'm aware no one has done anything on Lie algebras yet.</p>

<a name="168647779"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168647779" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168647779">Mario Carneiro (Jun 21 2019 at 01:08)</a>:</h4>
<p>We would normally use some naming convention based on the symbols in the axiom, but for core laws that have names we have a small set of name segments to describe the law. We've not dealt with these laws before, so I guess they would require a new terminology; I would use something like <code>lie_algebra.mul_anticomm</code> and <code>lie_algebra.jacobi</code> for these</p>

<a name="168647854"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168647854" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168647854">Mario Carneiro (Jun 21 2019 at 01:10)</a>:</h4>
<p>You should take a look at <a href="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md" target="_blank" title="https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md">https://github.com/leanprover-community/mathlib/blob/master/docs/contribute/naming.md</a></p>

<a name="168647855"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168647855" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168647855">Scott Morrison (Jun 21 2019 at 01:10)</a>:</h4>
<p>I wonder, actually, if we'd even want to use <code>mul</code> for a Lie algebra. It's true that it distributes over addition just as a "normal" multiplication does, but otherwise has little in common.</p>

<a name="168648328"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648328" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648328">Tim Daly (Jun 21 2019 at 01:23)</a>:</h4>
<p>This places the burden of finding multiplication in an algebra on the user's ability to infer names. Polymorphic names could be disambiguated by a prolog-like match algorithm. The naming convention "is what it is", of course.  But it seems to me that I have to read the original sources and "internalize" the names in my mind, which is a very small place.</p>

<a name="168648394"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648394" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648394">Mario Carneiro (Jun 21 2019 at 01:24)</a>:</h4>
<p>I'm not sure what problem you are trying to solve. There are multiple theorems with the same name in different namespaces, and we take care to have them be the same or clearly analogous</p>

<a name="168648474"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648474" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648474">Mario Carneiro (Jun 21 2019 at 01:26)</a>:</h4>
<p>If you have multiple theorems with the same name in scope (because you have opened multiple namespaces), it will disambiguate them based on the type</p>

<a name="168648560"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648560" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648560">Andrew Ashworth (Jun 21 2019 at 01:29)</a>:</h4>
<p>isn't this tiny theory system the type class inference system in disguise?</p>

<a name="168648564"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648564" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648564">Tim Daly (Jun 21 2019 at 01:29)</a>:</h4>
<p>Namespaces are a kind of type in that case. If they were all "in scope" then there is no need for namespaces?</p>

<a name="168648615"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648615" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648615">Andrew Ashworth (Jun 21 2019 at 01:30)</a>:</h4>
<p>specifically the often linked "unbundled type classes" section here: <a href="https://github.com/leanprover/lean/wiki/Refactoring-structures" target="_blank" title="https://github.com/leanprover/lean/wiki/Refactoring-structures">https://github.com/leanprover/lean/wiki/Refactoring-structures</a></p>

<a name="168648616"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648616" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648616">Mario Carneiro (Jun 21 2019 at 01:30)</a>:</h4>
<p>well no, namespaces are separate from types. The type system is DTT, the namespace system is just names and overloading</p>

<a name="168648617"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648617" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648617">Tim Daly (Jun 21 2019 at 01:30)</a>:</h4>
<p>Disguise? It is the type class inference problem.</p>

<a name="168648639"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648639" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648639">Tim Daly (Jun 21 2019 at 01:31)</a>:</h4>
<p>I admit ignorance of the full details. Further study on my part is needed.</p>

<a name="168648694"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168648694" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168648694">Mario Carneiro (Jun 21 2019 at 01:32)</a>:</h4>
<p>You can always refer to a theorem by its full name if the file that defines it has been imported. Opening a namespace just makes the name a bit shorter to reference</p>

<a name="168653056"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653056" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653056">Adrian Chu (Jun 21 2019 at 03:35)</a>:</h4>
<p>Btw, when Lean 4 comes out one day, what will happen to mathlib?</p>

<a name="168653498"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653498" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653498">Mario Carneiro (Jun 21 2019 at 03:48)</a>:</h4>
<p>Lean 4 is already "out", but not production ready. When it is solid we will start working on a port</p>

<a name="168653519"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653519" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653519">Mario Carneiro (Jun 21 2019 at 03:49)</a>:</h4>
<p>there isn't much point working on it at scale yet because it's too unstable and unfinished, although testing out a single file might be worthwhile</p>

<a name="168653626"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653626" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653626">Adrian Chu (Jun 21 2019 at 03:52)</a>:</h4>
<p>I see, then when it's stable enough, how much manual work is needed to update mathlib?</p>

<a name="168653653"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653653" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653653">Bryan Gin-ge Chen (Jun 21 2019 at 03:53)</a>:</h4>
<p>(deleted)</p>

<a name="168653654"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653654" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653654">Mario Carneiro (Jun 21 2019 at 03:53)</a>:</h4>
<p>somewhere between "a significant endeavor" and "a total overhaul"</p>

<a name="168653715"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168653715" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168653715">Mario Carneiro (Jun 21 2019 at 03:54)</a>:</h4>
<p>If we can get any refactoring tools in lean 3.5c then it may make this a lot easier. There is a lot of silly busywork like changing the naming convention</p>

<a name="168666562"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168666562" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168666562">Adrian Chu (Jun 21 2019 at 09:12)</a>:</h4>
<div class="codehilite"><pre><span></span>variable n : ℕ
def vec_exp1 (i : fin n) (x : vector ℕ n) (y : vector ℕ n) : ℕ :=
    (x.nth i)^(y.nth i)
def vec_exp2 (x : vector ℕ n) (y : vector ℕ n) : vector ℕ n :=
    ⟨(list.range n).map (λ i, vec_exp1 i x y), by simp⟩
</pre></div>

<a name="168666608"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168666608" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168666608">Adrian Chu (Jun 21 2019 at 09:13)</a>:</h4>
<p>I am trying to compute the entry-wise exponential of two n-vector. but the last line has error: the term x has type vector N n but is expected to have type fin i. what is wrong??</p>

<a name="168666669"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168666669" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168666669">Adrian Chu (Jun 21 2019 at 09:14)</a>:</h4>
<p>btw if i change n to 3, it works</p>

<a name="168666781"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168666781" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168666781">Mario Carneiro (Jun 21 2019 at 09:17)</a>:</h4>
<p>the variable <code>n : N</code> is getting added to <code>vec_exp1</code>, so it actually takes four arguments</p>

<a name="168666785"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168666785" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168666785">Mario Carneiro (Jun 21 2019 at 09:17)</a>:</h4>
<p>you should make it implicit by writing it in braces</p>

<a name="168667135"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168667135" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168667135">Adrian Chu (Jun 21 2019 at 09:24)</a>:</h4>
<p>ah i see! but now I'm getting another error in the last line: vec_exp1 i, the term i has type \N but is expected to have type fin ?m_1. how can I fix it?</p>

<a name="168668282"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168668282" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168668282">Kevin Buzzard (Jun 21 2019 at 09:48)</a>:</h4>
<p>If you hover over <code>vec_exp1</code> you can see it has type <code>vec_exp1 : Π {n : ℕ}, fin n → vector ℕ n → vector ℕ n → ℕ</code>. So it wants an input of type <code>fin n</code> and an input of type <code>vector ℕ n</code>. If you hover over <code>i</code> you see it has type <code>ℕ</code>. So now you can understand the error. How to fix it -- make the types correct ;-) Do you have a more specific question?</p>

<a name="168668574"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168668574" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168668574">Kevin Buzzard (Jun 21 2019 at 09:54)</a>:</h4>
<p>Do you understand how to interpret <code>(list.range n).map</code>? Hover over <code>list.range</code>  to see it has type <code>ℕ → list ℕ</code>. So <code>list.range n</code> has type <code>list ℕ</code>. Now this clever <code>l.map</code> thing means <code>list.map l</code> and doing <code>#check list.map</code> you can see the type of that too. You can just unravel everything. Your code doesn't work because when you unravel it it doesn't make sense.</p>

<a name="168668701"></a>
<h4><a href="https://leanprover.zulipchat.com/#narrow/stream/113489-new%20members/topic/noob%20question%28s%29/near/168668701" class="zl"><img src="https://leanprover-community.github.io/assets/img/zulip2.png" alt="view this post on Zulip"></a> <a href="https://leanprover-community.github.io/archive/113489newmembers/52075noobquestions.html#168668701">Kevin Buzzard (Jun 21 2019 at 09:57)</a>:</h4>
<p>Figuring out yourself what you want to do and then the types of the functions you want which will do them is a really good exercise for Lean beginners. It gets you thinking in the "functional programming" way.</p>


{% endraw %}
